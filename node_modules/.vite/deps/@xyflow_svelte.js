import "./chunk-PKPICXSY.js";
import "./chunk-2M4JNLCF.js";
import {
  derived,
  readable,
  writable
} from "./chunk-4RNI2LOR.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  hasContext,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  not_equal,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_style,
  space,
  subscribe,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-K2MCD2D6.js";
import "./chunk-GTNPPDQJ.js";
import "./chunk-WTEL7FPM.js";

// node_modules/.pnpm/classcat@5.0.5/node_modules/classcat/index.js
function cc(names) {
  if (typeof names === "string" || typeof names === "number")
    return "" + names;
  let out = "";
  if (Array.isArray(names)) {
    for (let i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (let k in names) {
      if (names[k])
        out += (out && " ") + k;
    }
  }
  return out;
}

// node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key2.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key2.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key2) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node))
      if (!(node = node.parentNode))
        return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter2.call(this, event, d))
      return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture)
      return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter2.call(this, event, d))
      return;
    var touches = event.changedTouches, c = container.call(this, event, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container2, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s;
    if ((s = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null)
      return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event2, touch2) {
      var p0 = p, n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer_default(touch2 || event2, container2), n = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event2,
          subject: s,
          target: drag2,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : filter2;
  };
  drag2.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag2) : container;
  };
  drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag2) : subject;
  };
  drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition)
    prototype[key2] = definition[key2];
  return prototype;
}

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x) => () => x;

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default3(isNaN(a) ? b : a);
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start2, end) {
      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s(t);
        start2.l = l(Math.pow(t, y));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/.pnpm/d3-timer@3.0.1/node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/.pnpm/d3-timer@3.0.1/node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty3)
    delete node.__transition;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolate(name, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key2 = "attr." + name;
  if (arguments.length < 2)
    return (key2 = this.tween(key2)) && key2._value;
  if (value == null)
    return this.tween(key2, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init2(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init2(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event = "end." + key2, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key2] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2)
    return (key2 = this.tween(key2)) && key2._value;
  if (value == null)
    return this.tween(key2, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key2, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key2 = "text";
  if (arguments.length < 1)
    return (key2 = this.tween(key2)) && key2._value;
  if (value == null)
    return this.tween(key2, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key2, textTween(value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity2;
  return node.__zoom;
}

// node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom2.scaleTo = function(selection2, k, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t02 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t02, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom2.translateBy = function(selection2, x, y, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x, y, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key2, transform2) {
      if (this.mouse && key2 !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key2 !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key2 !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation2(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default2(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default2(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var t02 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t02.invert(p0), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default2(event);
    if (duration > 0)
      select_default2(this).transition().duration(duration).call(schedule, t12, p0, event);
    else
      select_default2(this).call(zoom2.transform, t12, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation2(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ === "function" ? _ : constant_default4(+_), zoom2) : wheelDelta2;
  };
  zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : filter2;
  };
  zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : touchable;
  };
  zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  };
  zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  };
  zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom2) : interpolate;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  };
  return zoom2;
}

// node_modules/.pnpm/@xyflow+system@0.0.11/node_modules/@xyflow/system/dist/esm/index.mjs
var errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${!sourceHandle ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`
};
var internalsSymbol = Symbol.for("internals");
var infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
];
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  ConnectionLineType2["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
var isEdgeBase = (element2) => "id" in element2 && "source" in element2 && "target" in element2;
var isNodeBase = (element2) => "id" in element2 && !("source" in element2) && !("target" in element2);
var getOutgoersBase = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const outgoerIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.source === node.id) {
      outgoerIds.add(edge.target);
    }
  });
  return nodes.filter((n) => outgoerIds.has(n.id));
};
var getIncomersBase = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const incomersIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.target === node.id) {
      incomersIds.add(edge.source);
    }
  });
  return nodes.filter((n) => incomersIds.has(n.id));
};
var getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  var _a, _b, _c;
  if (!node) {
    return {
      x: 0,
      y: 0,
      positionAbsolute: {
        x: 0,
        y: 0
      }
    };
  }
  const offsetX = (((_a = node.computed) == null ? void 0 : _a.width) ?? node.width ?? 0) * nodeOrigin[0];
  const offsetY = (((_b = node.computed) == null ? void 0 : _b.height) ?? node.height ?? 0) * nodeOrigin[1];
  const position = {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
  return {
    ...position,
    positionAbsolute: ((_c = node.computed) == null ? void 0 : _c.positionAbsolute) ? {
      x: node.computed.positionAbsolute.x - offsetX,
      y: node.computed.positionAbsolute.y - offsetY
    } : position
  };
};
var getNodesBounds = (nodes, nodeOrigin = [0, 0]) => {
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  const box = nodes.reduce((currBox, node) => {
    var _a, _b;
    const { x, y } = getNodePositionWithOrigin(node, node.origin || nodeOrigin).positionAbsolute;
    return getBoundsOfBoxes(currBox, rectToBox({
      x,
      y,
      width: ((_a = node.computed) == null ? void 0 : _a.width) ?? node.width ?? 0,
      height: ((_b = node.computed) == null ? void 0 : _b.height) ?? node.height ?? 0
    }));
  }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
  return boxToRect(box);
};
var getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false, nodeOrigin = [0, 0]) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  };
  const visibleNodes = nodes.reduce((res, node) => {
    const { computed, selectable = true, hidden = false } = node;
    const width = (computed == null ? void 0 : computed.width) ?? node.width ?? null;
    const height = (computed == null ? void 0 : computed.height) ?? node.height ?? null;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      return res;
    }
    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node, nodeOrigin));
    const notInitialized = width === null || height === null;
    const partiallyVisible = partially && overlappingArea > 0;
    const area = (width ?? 0) * (height ?? 0);
    const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;
    if (isVisible || node.dragging) {
      res.push(node);
    }
    return res;
  }, []);
  return visibleNodes;
};
var getConnectedEdgesBase = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  nodes.forEach((node) => {
    nodeIds.add(node.id);
  });
  return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function fitView({ nodes, width, height, panZoom, minZoom, maxZoom, nodeOrigin = [0, 0] }, options) {
  const filteredNodes = nodes.filter((n) => {
    var _a, _b, _c;
    const isVisible = ((_a = n.computed) == null ? void 0 : _a.width) && ((_b = n.computed) == null ? void 0 : _b.height) && ((options == null ? void 0 : options.includeHiddenNodes) || !n.hidden);
    if ((_c = options == null ? void 0 : options.nodes) == null ? void 0 : _c.length) {
      return isVisible && (options == null ? void 0 : options.nodes.some((optionNode) => optionNode.id === n.id));
    }
    return isVisible;
  });
  if (filteredNodes.length > 0) {
    const bounds = getNodesBounds(filteredNodes, nodeOrigin);
    const viewport = getViewportForBounds(bounds, width, height, (options == null ? void 0 : options.minZoom) ?? minZoom, (options == null ? void 0 : options.maxZoom) ?? maxZoom, (options == null ? void 0 : options.padding) ?? 0.1);
    panZoom.setViewport(viewport, { duration: options == null ? void 0 : options.duration });
    return true;
  }
  return false;
}
function clampNodeExtent(node, extent) {
  var _a, _b;
  if (!extent || extent === "parent") {
    return extent;
  }
  return [extent[0], [extent[1][0] - (((_a = node.computed) == null ? void 0 : _a.width) ?? 0), extent[1][1] - (((_b = node.computed) == null ? void 0 : _b.height) ?? 0)]];
}
function calcNextPosition(node, nextPosition, nodes, nodeExtent, nodeOrigin = [0, 0], onError) {
  var _a, _b, _c, _d, _e, _f;
  const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);
  let currentExtent = clampedNodeExtent;
  let parentNode = null;
  let parentPos = { x: 0, y: 0 };
  if (node.parentNode) {
    parentNode = nodes.find((n) => n.id === node.parentNode) || null;
    parentPos = parentNode ? getNodePositionWithOrigin(parentNode, parentNode.origin || nodeOrigin).positionAbsolute : parentPos;
  }
  if (node.extent === "parent" && !node.expandParent) {
    const nodeWidth = (_a = node.computed) == null ? void 0 : _a.width;
    const nodeHeight = (_b = node.computed) == null ? void 0 : _b.height;
    if (node.parentNode && nodeWidth && nodeHeight) {
      const currNodeOrigin = node.origin || nodeOrigin;
      currentExtent = parentNode && isNumeric((_c = parentNode.computed) == null ? void 0 : _c.width) && isNumeric((_d = parentNode.computed) == null ? void 0 : _d.height) ? [
        [parentPos.x + nodeWidth * currNodeOrigin[0], parentPos.y + nodeHeight * currNodeOrigin[1]],
        [
          parentPos.x + (((_e = parentNode.computed) == null ? void 0 : _e.width) ?? 0) - nodeWidth + nodeWidth * currNodeOrigin[0],
          parentPos.y + (((_f = parentNode.computed) == null ? void 0 : _f.height) ?? 0) - nodeHeight + nodeHeight * currNodeOrigin[1]
        ]
      ] : currentExtent;
    } else {
      onError == null ? void 0 : onError("005", errorMessages["error005"]());
      currentExtent = clampedNodeExtent;
    }
  } else if (node.extent && node.parentNode && node.extent !== "parent") {
    currentExtent = [
      [node.extent[0][0] + parentPos.x, node.extent[0][1] + parentPos.y],
      [node.extent[1][0] + parentPos.x, node.extent[1][1] + parentPos.y]
    ];
  }
  const positionAbsolute = currentExtent && currentExtent !== "parent" ? clampPosition(nextPosition, currentExtent) : nextPosition;
  return {
    position: {
      x: positionAbsolute.x - parentPos.x,
      y: positionAbsolute.y - parentPos.y
    },
    positionAbsolute
  };
}
function getElementsToRemove({ nodesToRemove, edgesToRemove, nodes, edges }) {
  const nodeIds = nodesToRemove.map((node) => node.id);
  const edgeIds = edgesToRemove.map((edge) => edge.id);
  const matchingNodes = nodes.reduce((res, node) => {
    const parentHit = !nodeIds.includes(node.id) && node.parentNode && res.find((n) => n.id === node.parentNode);
    const deletable = typeof node.deletable === "boolean" ? node.deletable : true;
    if (deletable && (nodeIds.includes(node.id) || parentHit)) {
      res.push(node);
    }
    return res;
  }, []);
  const deletableEdges = edges.filter((e) => typeof e.deletable === "boolean" ? e.deletable : true);
  const initialHitEdges = deletableEdges.filter((e) => edgeIds.includes(e.id));
  const connectedEdges = getConnectedEdgesBase(matchingNodes, deletableEdges);
  const matchingEdges = connectedEdges.reduce((res, edge) => {
    if (!res.find((e) => e.id === edge.id)) {
      res.push(edge);
    }
    return res;
  }, initialHitEdges);
  return {
    matchingEdges,
    matchingNodes
  };
}
var clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
var clampPosition = (position = { x: 0, y: 0 }, extent) => ({
  x: clamp(position.x, extent[0][0], extent[1][0]),
  y: clamp(position.y, extent[0][1], extent[1][1])
});
var calcAutoPanVelocity = (value, min, max) => {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, 50) / 50;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, 50) / 50;
  }
  return 0;
};
var calcAutoPan = (pos, bounds) => {
  const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;
  const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;
  return [xMovement, yMovement];
};
var getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
});
var rectToBox = ({ x, y, width, height }) => ({
  x,
  y,
  x2: x + width,
  y2: y + height
});
var boxToRect = ({ x, y, x2, y2 }) => ({
  x,
  y,
  width: x2 - x,
  height: y2 - y
});
var nodeToRect = (node, nodeOrigin = [0, 0]) => {
  var _a, _b;
  const { positionAbsolute } = getNodePositionWithOrigin(node, node.origin || nodeOrigin);
  return {
    ...positionAbsolute,
    width: ((_a = node.computed) == null ? void 0 : _a.width) ?? node.width ?? 0,
    height: ((_b = node.computed) == null ? void 0 : _b.height) ?? node.height ?? 0
  };
};
var nodeToBox = (node, nodeOrigin = [0, 0]) => {
  var _a, _b;
  const { positionAbsolute } = getNodePositionWithOrigin(node, node.origin || nodeOrigin);
  return {
    ...positionAbsolute,
    x2: positionAbsolute.x + (((_a = node.computed) == null ? void 0 : _a.width) ?? node.width ?? 0),
    y2: positionAbsolute.y + (((_b = node.computed) == null ? void 0 : _b.height) ?? node.height ?? 0)
  };
};
var getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
var getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
var isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
var isNumeric = (n) => !isNaN(n) && isFinite(n);
var devWarn = (id2, message) => {
  if (true) {
    console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id2}`);
  }
};
var getPositionWithOrigin = ({ x, y, width, height, origin = [0, 0] }) => {
  if (!width || !height || origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {
    return { x, y };
  }
  return {
    x: x - width * origin[0],
    y: y - height * origin[1]
  };
};
function snapPosition(position, snapGrid = [1, 1]) {
  return {
    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
    y: snapGrid[1] * Math.round(position.y / snapGrid[1])
  };
}
var pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {
  const position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
};
var rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
var getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const xZoom = width / (bounds.width * (1 + padding));
  const yZoom = height / (bounds.height * (1 + padding));
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom;
  const y = height / 2 - boundsCenterY * clampedZoom;
  return { x, y, zoom: clampedZoom };
};
var isMacOs = () => {
  var _a;
  return typeof navigator !== "undefined" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.indexOf("Mac")) >= 0;
};
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform: transform2 }) {
  const { x, y } = getEventPosition(event);
  const pointerPos = pointToRendererPoint({ x, y }, transform2);
  const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
var getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
});
var getHostForElement = (element2) => {
  var _a;
  return ((_a = element2.getRootNode) == null ? void 0 : _a.call(element2)) || (window == null ? void 0 : window.document);
};
var isMouseEvent = (event) => "clientX" in event;
var getEventPosition = (event, bounds) => {
  var _a, _b;
  const isMouse = isMouseEvent(event);
  const evtX = isMouse ? event.clientX : (_a = event.touches) == null ? void 0 : _a[0].clientX;
  const evtY = isMouse ? event.clientY : (_b = event.touches) == null ? void 0 : _b[0].clientY;
  return {
    x: evtX - ((bounds == null ? void 0 : bounds.left) ?? 0),
    y: evtY - ((bounds == null ? void 0 : bounds.top) ?? 0)
  };
};
var getHandleBounds = (selector, nodeElement, zoom2, nodeOrigin = [0, 0]) => {
  const handles = nodeElement.querySelectorAll(selector);
  if (!handles || !handles.length) {
    return null;
  }
  const handlesArray = Array.from(handles);
  const nodeBounds = nodeElement.getBoundingClientRect();
  const nodeOffset = {
    x: nodeBounds.width * nodeOrigin[0],
    y: nodeBounds.height * nodeOrigin[1]
  };
  return handlesArray.map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom2,
      y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  }
  return curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
var defaultEdgeTree = [{ level: 0, isMaxLevel: true, edges: [] }];
function groupEdgesByZLevel(edges, nodeLookup, elevateEdgesOnSelect = false) {
  let maxLevel = -1;
  const levelLookup = edges.reduce((tree, edge) => {
    var _a, _b;
    const hasZIndex = isNumeric(edge.zIndex);
    let z = hasZIndex ? edge.zIndex : 0;
    if (elevateEdgesOnSelect) {
      const targetNode = nodeLookup.get(edge.target);
      const sourceNode = nodeLookup.get(edge.source);
      const edgeOrConnectedNodeSelected = edge.selected || (targetNode == null ? void 0 : targetNode.selected) || (sourceNode == null ? void 0 : sourceNode.selected);
      const selectedZIndex = Math.max(((_a = sourceNode == null ? void 0 : sourceNode[internalsSymbol]) == null ? void 0 : _a.z) || 0, ((_b = targetNode == null ? void 0 : targetNode[internalsSymbol]) == null ? void 0 : _b.z) || 0, 1e3);
      z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
    }
    if (tree[z]) {
      tree[z].push(edge);
    } else {
      tree[z] = [edge];
    }
    maxLevel = z > maxLevel ? z : maxLevel;
    return tree;
  }, {});
  const edgeTree = Object.entries(levelLookup).map(([key2, edges2]) => {
    const level = +key2;
    return {
      edges: edges2,
      level,
      isMaxLevel: level === maxLevel
    };
  });
  if (edgeTree.length === 0) {
    return defaultEdgeTree;
  }
  return edgeTree;
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
var getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xyflow__edge-${source}${sourceHandle || ""}-${target}${targetHandle || ""}`;
var connectionExists = (edge, edges) => {
  return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
};
var addEdgeBase = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target) {
    devWarn("006", errorMessages["error006"]());
    return edges;
  }
  let edge;
  if (isEdgeBase(edgeParams)) {
    edge = { ...edgeParams };
  } else {
    edge = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  return edges.concat(edge);
};
var updateEdgeBase = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {
  const { id: oldEdgeId, ...rest } = oldEdge;
  if (!newConnection.source || !newConnection.target) {
    devWarn("006", errorMessages["error006"]());
    return edges;
  }
  const foundEdge = edges.find((e) => e.id === oldEdge.id);
  if (!foundEdge) {
    devWarn("007", errorMessages["error007"](oldEdgeId));
    return edges;
  }
  const edge = {
    ...rest,
    id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,
    source: newConnection.source,
    target: newConnection.target,
    sourceHandle: newConnection.sourceHandle,
    targetHandle: newConnection.targetHandle
  };
  return edges.filter((e) => e.id !== oldEdgeId).concat(edge);
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
var handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
var getDirection = ({ source, sourcePosition = Position.Bottom, target }) => {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
var distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
  const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
  const dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center.x || defaultCenterX;
    centerY = center.y || defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset
  });
  const path = points.reduce((res, p, i) => {
    let segment = "";
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
function getEdgePosition(params) {
  var _a;
  const [sourceNodeRect, sourceHandleBounds, isSourceValid] = getHandleDataByNode(params.sourceNode);
  const [targetNodeRect, targetHandleBounds, isTargetValid] = getHandleDataByNode(params.targetNode);
  if (!isSourceValid || !isTargetValid) {
    return null;
  }
  const targetNodeHandles = params.connectionMode === ConnectionMode.Strict ? targetHandleBounds.target : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);
  const sourceHandle = getHandle(sourceHandleBounds.source, params.sourceHandle);
  const targetHandle = getHandle(targetNodeHandles, params.targetHandle);
  const sourcePosition = (sourceHandle == null ? void 0 : sourceHandle.position) || Position.Bottom;
  const targetPosition = (targetHandle == null ? void 0 : targetHandle.position) || Position.Top;
  if (!sourceHandle || !targetHandle) {
    (_a = params.onError) == null ? void 0 : _a.call(params, "008", errorMessages["error008"](!sourceHandle ? "source" : "target", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    }));
    return null;
  }
  const { x: sourceX, y: sourceY } = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);
  const { x: targetX, y: targetY } = getHandlePosition(targetPosition, targetNodeRect, targetHandle);
  return {
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles) {
    return null;
  }
  return handles.reduce((res, item) => {
    var _a, _b;
    item.width = item.width || 1;
    item.height = item.height || 1;
    if (item.type === "source") {
      (_a = res.source) == null ? void 0 : _a.push(item);
    }
    if (item.type === "target") {
      (_b = res.target) == null ? void 0 : _b.push(item);
    }
    return res;
  }, {
    source: [],
    target: []
  });
}
function getHandleDataByNode(node) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const handleBounds = ((_a = node == null ? void 0 : node[internalsSymbol]) == null ? void 0 : _a.handleBounds) || toHandleBounds(node == null ? void 0 : node.handles) || null;
  const nodeWidth = ((_b = node == null ? void 0 : node.computed) == null ? void 0 : _b.width) || (node == null ? void 0 : node.width);
  const nodeHeight = ((_c = node == null ? void 0 : node.computed) == null ? void 0 : _c.height) || (node == null ? void 0 : node.height);
  const isValid = handleBounds && nodeWidth && nodeHeight && typeof ((_e = (_d = node == null ? void 0 : node.computed) == null ? void 0 : _d.positionAbsolute) == null ? void 0 : _e.x) !== "undefined" && typeof ((_g = (_f = node == null ? void 0 : node.computed) == null ? void 0 : _f.positionAbsolute) == null ? void 0 : _g.y) !== "undefined";
  return [
    {
      x: ((_i = (_h = node == null ? void 0 : node.computed) == null ? void 0 : _h.positionAbsolute) == null ? void 0 : _i.x) || 0,
      y: ((_k = (_j = node == null ? void 0 : node.computed) == null ? void 0 : _j.positionAbsolute) == null ? void 0 : _k.y) || 0,
      width: nodeWidth || 0,
      height: nodeHeight || 0
    },
    handleBounds,
    !!isValid
  ];
}
function getHandlePosition(position, nodeRect, handle = null) {
  const x = ((handle == null ? void 0 : handle.x) || 0) + nodeRect.x;
  const y = ((handle == null ? void 0 : handle.y) || 0) + nodeRect.y;
  const width = (handle == null ? void 0 : handle.width) || nodeRect.width;
  const height = (handle == null ? void 0 : handle.height) || nodeRect.height;
  switch (position) {
    case Position.Top:
      return {
        x: x + width / 2,
        y
      };
    case Position.Right:
      return {
        x: x + width,
        y: y + height / 2
      };
    case Position.Bottom:
      return {
        x: x + width / 2,
        y: y + height
      };
    case Position.Left:
      return {
        x,
        y: y + height / 2
      };
  }
}
function getHandle(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  if (bounds.length === 1 || !handleId) {
    return bounds[0];
  } else if (handleId) {
    return bounds.find((d) => d.id === handleId) || null;
  }
  return null;
}
function getMarkerId(marker, id2) {
  if (!marker) {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = id2 ? `${id2}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key2) => `${key2}=${marker[key2]}`).join("&")}`;
}
function createMarkerIds(edges, { id: id2, defaultColor }) {
  const ids = [];
  return edges.reduce((markers, edge) => {
    [edge.markerStart, edge.markerEnd].forEach((marker) => {
      if (marker && typeof marker === "object") {
        const markerId = getMarkerId(marker, id2);
        if (!ids.includes(markerId)) {
          markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
          ids.push(markerId);
        }
      }
    });
    return markers;
  }, []).sort((a, b) => a.id.localeCompare(b.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {
  let alignmentOffset = 0.5;
  if (align === "start") {
    alignmentOffset = 0;
  } else if (align === "end") {
    alignmentOffset = 1;
  }
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset
  ];
  let shift = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;
      shift[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;
}
function updateAbsolutePositions(nodes, nodeLookup, nodeOrigin = [0, 0], parentNodes) {
  return nodes.map((node) => {
    var _a;
    if (node.parentNode && !nodeLookup.has(node.parentNode)) {
      throw new Error(`Parent node ${node.parentNode} not found`);
    }
    if (node.parentNode || (parentNodes == null ? void 0 : parentNodes[node.id])) {
      const parentNode = node.parentNode ? nodeLookup.get(node.parentNode) : null;
      const { x, y, z } = calculateXYZPosition(node, nodes, nodeLookup, {
        ...node.position,
        z: ((_a = node[internalsSymbol]) == null ? void 0 : _a.z) ?? 0
      }, (parentNode == null ? void 0 : parentNode.origin) || nodeOrigin);
      node.computed.positionAbsolute = {
        x,
        y
      };
      node[internalsSymbol].z = z;
      if (parentNodes == null ? void 0 : parentNodes[node.id]) {
        node[internalsSymbol].isParent = true;
      }
    }
    return node;
  });
}
function updateNodes(nodes, nodeLookup, options = {
  nodeOrigin: [0, 0],
  elevateNodesOnSelect: true,
  defaults: {}
}) {
  const parentNodes = {};
  const selectedNodeZ = (options == null ? void 0 : options.elevateNodesOnSelect) ? 1e3 : 0;
  const nextNodes = nodes.map((n) => {
    var _a, _b, _c, _d;
    const currentStoreNode = nodeLookup.get(n.id);
    const node = {
      ...options.defaults,
      ...n,
      computed: {
        positionAbsolute: n.position,
        width: ((_a = n.computed) == null ? void 0 : _a.width) || ((_b = currentStoreNode == null ? void 0 : currentStoreNode.computed) == null ? void 0 : _b.width),
        height: ((_c = n.computed) == null ? void 0 : _c.height) || ((_d = currentStoreNode == null ? void 0 : currentStoreNode.computed) == null ? void 0 : _d.height)
      }
    };
    const z = (isNumeric(n.zIndex) ? n.zIndex : 0) + (n.selected ? selectedNodeZ : 0);
    const currInternals = (n == null ? void 0 : n[internalsSymbol]) || (currentStoreNode == null ? void 0 : currentStoreNode[internalsSymbol]);
    if (node.parentNode) {
      parentNodes[node.parentNode] = true;
    }
    Object.defineProperty(node, internalsSymbol, {
      enumerable: false,
      value: {
        handleBounds: currInternals == null ? void 0 : currInternals.handleBounds,
        z
      }
    });
    nodeLookup.set(node.id, node);
    return node;
  });
  const nodesWithPositions = updateAbsolutePositions(nextNodes, nodeLookup, options.nodeOrigin, parentNodes);
  return nodesWithPositions;
}
function calculateXYZPosition(node, nodes, nodeLookup, result, nodeOrigin) {
  var _a, _b;
  if (!node.parentNode) {
    return result;
  }
  const parentNode = nodeLookup.get(node.parentNode);
  const parentNodePosition = getNodePositionWithOrigin(parentNode, (parentNode == null ? void 0 : parentNode.origin) || nodeOrigin);
  return calculateXYZPosition(parentNode, nodes, nodeLookup, {
    x: (result.x ?? 0) + parentNodePosition.x,
    y: (result.y ?? 0) + parentNodePosition.y,
    z: (((_a = parentNode[internalsSymbol]) == null ? void 0 : _a.z) ?? 0) > (result.z ?? 0) ? ((_b = parentNode[internalsSymbol]) == null ? void 0 : _b.z) ?? 0 : result.z ?? 0
  }, parentNode.origin || nodeOrigin);
}
function updateNodeDimensions(updates, nodes, nodeLookup, domNode, nodeOrigin, onUpdate) {
  const viewportNode = domNode == null ? void 0 : domNode.querySelector(".xyflow__viewport");
  if (!viewportNode) {
    return null;
  }
  const style = window.getComputedStyle(viewportNode);
  const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
  const nextNodes = nodes.map((node) => {
    var _a, _b;
    const update = updates.get(node.id);
    if (update) {
      const dimensions = getDimensions(update.nodeElement);
      const doUpdate = !!(dimensions.width && dimensions.height && (((_a = node.computed) == null ? void 0 : _a.width) !== dimensions.width || ((_b = node.computed) == null ? void 0 : _b.height) !== dimensions.height || update.forceUpdate));
      if (doUpdate) {
        onUpdate == null ? void 0 : onUpdate(node.id, dimensions);
        const newNode = {
          ...node,
          computed: {
            ...node.computed,
            ...dimensions
          },
          [internalsSymbol]: {
            ...node[internalsSymbol],
            handleBounds: {
              source: getHandleBounds(".source", update.nodeElement, zoom2, node.origin || nodeOrigin),
              target: getHandleBounds(".target", update.nodeElement, zoom2, node.origin || nodeOrigin)
            }
          }
        };
        nodeLookup.set(node.id, newNode);
        return newNode;
      }
    }
    return node;
  });
  return nextNodes;
}
function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y) {
    return false;
  }
  const nextViewport = panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent);
  const transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return transformChanged;
}
function wrapSelectionDragFunc(selectionFunc) {
  return (event, _, nodes) => selectionFunc == null ? void 0 : selectionFunc(event, nodes);
}
function isParentSelected(node, nodes) {
  if (!node.parentNode) {
    return false;
  }
  const parentNode = nodes.find((node2) => node2.id === node2.parentNode);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodes);
}
function hasSelector(target, selector, domNode) {
  let current = target;
  do {
    if (current == null ? void 0 : current.matches(selector))
      return true;
    if (current === domNode)
      return false;
    current = current.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodes, nodesDraggable, mousePos, nodeId) {
  return nodes.filter((n) => (n.selected || n.id === nodeId) && (!n.parentNode || !isParentSelected(n, nodes)) && (n.draggable || nodesDraggable && typeof n.draggable === "undefined")).map((n) => {
    var _a, _b, _c, _d, _e, _f, _g;
    return {
      id: n.id,
      position: n.position || { x: 0, y: 0 },
      distance: {
        x: mousePos.x - (((_b = (_a = n.computed) == null ? void 0 : _a.positionAbsolute) == null ? void 0 : _b.x) ?? 0),
        y: mousePos.y - (((_d = (_c = n.computed) == null ? void 0 : _c.positionAbsolute) == null ? void 0 : _d.y) ?? 0)
      },
      delta: {
        x: 0,
        y: 0
      },
      extent: n.extent,
      parentNode: n.parentNode,
      origin: n.origin,
      expandParent: n.expandParent,
      computed: {
        positionAbsolute: ((_e = n.computed) == null ? void 0 : _e.positionAbsolute) || { x: 0, y: 0 },
        width: ((_f = n.computed) == null ? void 0 : _f.width) || 0,
        height: ((_g = n.computed) == null ? void 0 : _g.height) || 0
      }
    };
  });
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup }) {
  const nodesFromDragItems = dragItems.map((n) => {
    const node = nodeLookup.get(n.id);
    return {
      ...node,
      position: n.position,
      computed: {
        ...n.computed,
        positionAbsolute: n.computed.positionAbsolute
      }
    };
  });
  return [nodeId ? nodesFromDragItems.find((n) => n.id === nodeId) : nodesFromDragItems[0], nodesFromDragItems];
}
function XYDrag({ domNode, onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null };
  let autoPanId = 0;
  let dragItems = [];
  let autoPanStarted = false;
  let mousePosition = { x: 0, y: 0 };
  let dragEvent = null;
  let containerBounds = null;
  let dragStarted = false;
  const d3Selection = select_default2(domNode);
  function update({ noDragClassName, handleSelector, domNode: domNode2, isSelectable, nodeId }) {
    function updateNodes2({ x, y }) {
      const { nodes, nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x, y };
      let hasChange = false;
      let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
      if (dragItems.length > 1 && nodeExtent) {
        const rect = getNodesBounds(dragItems, nodeOrigin);
        nodesBox = rectToBox(rect);
      }
      dragItems = dragItems.map((n) => {
        var _a, _b;
        let nextPosition = { x: x - n.distance.x, y: y - n.distance.y };
        if (snapToGrid) {
          nextPosition = snapPosition(nextPosition, snapGrid);
        }
        const adjustedNodeExtent = [
          [nodeExtent[0][0], nodeExtent[0][1]],
          [nodeExtent[1][0], nodeExtent[1][1]]
        ];
        if (dragItems.length > 1 && nodeExtent && !n.extent) {
          adjustedNodeExtent[0][0] = n.computed.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];
          adjustedNodeExtent[1][0] = n.computed.positionAbsolute.x + (((_a = n.computed) == null ? void 0 : _a.width) ?? 0) - nodesBox.x2 + nodeExtent[1][0];
          adjustedNodeExtent[0][1] = n.computed.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];
          adjustedNodeExtent[1][1] = n.computed.positionAbsolute.y + (((_b = n.computed) == null ? void 0 : _b.height) ?? 0) - nodesBox.y2 + nodeExtent[1][1];
        }
        const updatedPos = calcNextPosition(n, nextPosition, nodes, adjustedNodeExtent, nodeOrigin, onError);
        hasChange = hasChange || n.position.x !== updatedPos.position.x || n.position.y !== updatedPos.position.y;
        n.position = updatedPos.position;
        n.computed.positionAbsolute = updatedPos.positionAbsolute;
        return n;
      });
      if (!hasChange) {
        return;
      }
      updateNodePositions(dragItems, true, true);
      const onNodeOrSelectionDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);
      if (dragEvent && (onDrag || onNodeOrSelectionDrag)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag == null ? void 0 : onDrag(dragEvent, dragItems, currentNode, currentNodes);
        onNodeOrSelectionDrag == null ? void 0 : onNodeOrSelectionDrag(dragEvent, currentNode, currentNodes);
      }
    }
    function autoPan() {
      if (!containerBounds) {
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds);
      if (xMovement !== 0 || yMovement !== 0) {
        const { transform: transform2, panBy: panBy2 } = getStoreItems();
        lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2];
        lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2];
        if (panBy2({ x: xMovement, y: yMovement })) {
          updateNodes2(lastPos);
        }
      }
      autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      var _a;
      const { nodes, nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = true;
      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
        if (!((_a = nodeLookup.get(nodeId)) == null ? void 0 : _a.selected)) {
          unselectNodesAndEdges();
        }
      }
      if (isSelectable && selectNodesOnDrag && nodeId) {
        onNodeMouseDown == null ? void 0 : onNodeMouseDown(nodeId);
      }
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      lastPos = pointerPos;
      dragItems = getDragItems(nodes, nodesDraggable, pointerPos, nodeId);
      const onNodeOrSelectionDragStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);
      if (dragItems && (onDragStart || onNodeOrSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart == null ? void 0 : onDragStart(event.sourceEvent, dragItems, currentNode, currentNodes);
        onNodeOrSelectionDragStart == null ? void 0 : onNodeOrSelectionDragStart(event.sourceEvent, currentNode, currentNodes);
      }
    }
    const d3DragInstance = drag_default().on("start", (event) => {
      const { domNode: domNode3, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      if (nodeDragThreshold === 0) {
        startDrag(event);
      }
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      lastPos = pointerPos;
      containerBounds = (domNode3 == null ? void 0 : domNode3.getBoundingClientRect()) || null;
      mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold } = getStoreItems();
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {
        autoPanStarted = true;
        autoPan();
      }
      if (!dragStarted) {
        const x = pointerPos.xSnapped - (lastPos.x ?? 0);
        const y = pointerPos.ySnapped - (lastPos.y ?? 0);
        const distance2 = Math.sqrt(x * x + y * y);
        if (distance2 > nodeDragThreshold) {
          startDrag(event);
        }
      }
      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {
        dragEvent = event.sourceEvent;
        mousePosition = getEventPosition(event.sourceEvent, containerBounds);
        updateNodes2(pointerPos);
      }
    }).on("end", (event) => {
      if (!dragStarted) {
        return;
      }
      autoPanStarted = false;
      dragStarted = false;
      cancelAnimationFrame(autoPanId);
      if (dragItems) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        const onNodeOrSelectionDragStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);
        updateNodePositions(dragItems, false, false);
        if (onDragStop || onNodeOrSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup
          });
          onDragStop == null ? void 0 : onDragStop(event.sourceEvent, dragItems, currentNode, currentNodes);
          onNodeOrSelectionDragStop == null ? void 0 : onNodeOrSelectionDragStop(event.sourceEvent, currentNode, currentNodes);
        }
      }
    }).filter((event) => {
      const target = event.target;
      const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode2)) && (!handleSelector || hasSelector(target, handleSelector, domNode2));
      return isDraggable;
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getHandles(node, handleBounds, type, currentHandle) {
  return (handleBounds[type] || []).reduce((res, h) => {
    var _a, _b, _c, _d;
    if (`${node.id}-${h.id}-${type}` !== currentHandle) {
      res.push({
        id: h.id || null,
        type,
        nodeId: node.id,
        x: (((_b = (_a = node.computed) == null ? void 0 : _a.positionAbsolute) == null ? void 0 : _b.x) ?? 0) + h.x + h.width / 2,
        y: (((_d = (_c = node.computed) == null ? void 0 : _c.positionAbsolute) == null ? void 0 : _d.y) ?? 0) + h.y + h.height / 2
      });
    }
    return res;
  }, []);
}
function getClosestHandle(pos, connectionRadius, handles) {
  let closestHandles = [];
  let minDistance = Infinity;
  handles.forEach((handle) => {
    const distance2 = Math.sqrt(Math.pow(handle.x - pos.x, 2) + Math.pow(handle.y - pos.y, 2));
    if (distance2 <= connectionRadius) {
      if (distance2 < minDistance) {
        closestHandles = [handle];
      } else if (distance2 === minDistance) {
        closestHandles.push(handle);
      }
      minDistance = distance2;
    }
  });
  if (!closestHandles.length) {
    return null;
  }
  return closestHandles.length === 1 ? closestHandles[0] : (
    // if multiple handles are layouted on top of each other we take the one with type = target because it's more likely that the user wants to connect to this one
    closestHandles.find((handle) => handle.type === "target") || closestHandles[0]
  );
}
function getHandleLookup({ nodes, nodeId, handleId, handleType }) {
  return nodes.reduce((res, node) => {
    if (node[internalsSymbol]) {
      const { handleBounds } = node[internalsSymbol];
      let sourceHandles = [];
      let targetHandles = [];
      if (handleBounds) {
        sourceHandles = getHandles(node, handleBounds, "source", `${nodeId}-${handleId}-${handleType}`);
        targetHandles = getHandles(node, handleBounds, "target", `${nodeId}-${handleId}-${handleType}`);
      }
      res.push(...sourceHandles, ...targetHandles);
    }
    return res;
  }, []);
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("target")) {
    return "target";
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("source")) {
    return "source";
  }
  return null;
}
function resetRecentHandle(handleDomNode, lib) {
  handleDomNode == null ? void 0 : handleDomNode.classList.remove("valid", "connecting", `${lib}-flow__handle-valid`, `${lib}-flow__handle-connecting`);
}
function getConnectionStatus(isInsideConnectionRadius, isHandleValid) {
  let connectionStatus = null;
  if (isHandleValid) {
    connectionStatus = "valid";
  } else if (isInsideConnectionRadius && !isHandleValid) {
    connectionStatus = "invalid";
  }
  return connectionStatus;
}
var nullConnection = { source: null, target: null, sourceHandle: null, targetHandle: null };
var alwaysValid = () => true;
var connectionStartHandle = null;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodes, lib, autoPanOnConnect, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onEdgeUpdateEnd, updateConnection, getTransform }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0;
  let closestHandle;
  const { x, y } = getEventPosition(event);
  const clickedHandle = doc == null ? void 0 : doc.elementFromPoint(x, y);
  const handleType = getHandleType(edgeUpdaterType, clickedHandle);
  const containerBounds = domNode == null ? void 0 : domNode.getBoundingClientRect();
  if (!containerBounds || !handleType) {
    return;
  }
  let prevActiveHandle;
  let connectionPosition = getEventPosition(event, containerBounds);
  let autoPanStarted = false;
  let connection = null;
  let isValid = false;
  let handleDomNode = null;
  const handleLookup = getHandleLookup({
    nodes,
    nodeId,
    handleId,
    handleType
  });
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds) {
      return;
    }
    const [x2, y2] = calcAutoPan(connectionPosition, containerBounds);
    panBy2({ x: x2, y: y2 });
    autoPanId = requestAnimationFrame(autoPan);
  }
  connectionStartHandle = {
    nodeId,
    handleId,
    type: handleType
  };
  updateConnection({
    connectionPosition,
    connectionStatus: null,
    // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle
    connectionStartHandle,
    connectionEndHandle: null
  });
  onConnectStart == null ? void 0 : onConnectStart(event, { nodeId, handleId, handleType });
  function onPointerMove(event2) {
    const transform2 = getTransform();
    connectionPosition = getEventPosition(event2, containerBounds);
    closestHandle = getClosestHandle(pointToRendererPoint(connectionPosition, transform2, false, [1, 1]), connectionRadius, handleLookup);
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib
    });
    handleDomNode = result.handleDomNode;
    connection = result.connection;
    isValid = result.isValid;
    updateConnection({
      connectionStartHandle,
      connectionPosition: closestHandle && isValid ? rendererPointToPoint({
        x: closestHandle.x,
        y: closestHandle.y
      }, transform2) : connectionPosition,
      connectionStatus: getConnectionStatus(!!closestHandle, isValid),
      connectionEndHandle: result.endHandle
    });
    if (!closestHandle && !isValid && !handleDomNode) {
      return resetRecentHandle(prevActiveHandle, lib);
    }
    if (connection.source !== connection.target && handleDomNode) {
      resetRecentHandle(prevActiveHandle, lib);
      prevActiveHandle = handleDomNode;
      handleDomNode.classList.add("connecting", `${lib}-flow__handle-connecting`);
      handleDomNode.classList.toggle("valid", isValid);
      handleDomNode.classList.toggle(`${lib}-flow__handle-valid`, isValid);
    }
  }
  function onPointerUp(event2) {
    if ((closestHandle || handleDomNode) && connection && isValid) {
      onConnect == null ? void 0 : onConnect(connection);
    }
    onConnectEnd == null ? void 0 : onConnectEnd(event2);
    if (edgeUpdaterType) {
      onEdgeUpdateEnd == null ? void 0 : onEdgeUpdateEnd(event2);
    }
    resetRecentHandle(prevActiveHandle, lib);
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    handleDomNode = null;
    connectionStartHandle = null;
    doc.removeEventListener("mousemove", onPointerMove);
    doc.removeEventListener("mouseup", onPointerUp);
    doc.removeEventListener("touchmove", onPointerMove);
    doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove);
  doc.addEventListener("mouseup", onPointerUp);
  doc.addEventListener("touchmove", onPointerMove);
  doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, isValidConnection = alwaysValid }) {
  const isTarget = fromType === "target";
  const handleDomNode = doc.querySelector(`.${lib}-flow__handle[data-id="${handle == null ? void 0 : handle.nodeId}-${handle == null ? void 0 : handle.id}-${handle == null ? void 0 : handle.type}"]`);
  const { x, y } = getEventPosition(event);
  const handleBelow = doc.elementFromPoint(x, y);
  const handleToCheck = (handleBelow == null ? void 0 : handleBelow.classList.contains(`${lib}-flow__handle`)) ? handleBelow : handleDomNode;
  const result = {
    handleDomNode: handleToCheck,
    isValid: false,
    connection: nullConnection,
    endHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    if (isValid) {
      result.endHandle = {
        nodeId: handleNodeId,
        handleId,
        type: handleType
      };
      result.isValid = isValidConnection(connection);
    }
  }
  return result;
}
var XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select_default2(domNode);
  function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false }) {
    const zoomHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "wheel" || !panZoom) {
        return;
      }
      const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep;
      const nextZoom = transform2[2] * Math.pow(2, pinchDelta);
      panZoom.scaleTo(nextZoom);
    };
    const panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" || !panZoom) {
        return;
      }
      const moveScale = getViewScale() * Math.max(1, transform2[2]) * (inversePan ? -1 : 1);
      const position = {
        x: transform2[0] - event.sourceEvent.movementX * moveScale,
        y: transform2[1] - event.sourceEvent.movementY * moveScale
      };
      const extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    };
    const zoomAndPanHandler = zoom_default2().on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer: pointer_default
  };
}
var viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;
var transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
});
var viewportToTransform = ({ x, y, zoom: zoom2 }) => identity2.translate(x, y).scale(zoom2);
var isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);
var isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
var getD3Transition = (selection2, duration = 0) => typeof duration === "number" && duration > 0 ? selection2.transition().duration(duration) : selection2;
var wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName)) {
      return false;
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    const _isMacOs = isMacOs();
    if (event.ctrlKey && zoomOnPinch && _isMacOs) {
      const point = pointer_default(event);
      const pinchDelta = wheelDelta(event);
      const zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    if (!_isMacOs && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
      deltaX = event.deltaY * deltaNormalize;
      deltaY = 0;
    }
    d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: true }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout);
    if (!zoomPanValues.isPanScrolling) {
      zoomPanValues.isPanScrolling = true;
      onPanZoomStart == null ? void 0 : onPanZoomStart(event, nextViewport);
    }
    if (zoomPanValues.isPanScrolling) {
      onPanZoom == null ? void 0 : onPanZoom(event, nextViewport);
      zoomPanValues.panScrollTimeout = setTimeout(() => {
        onPanZoomEnd == null ? void 0 : onPanZoomEnd(event, nextViewport);
        zoomPanValues.isPanScrolling = false;
      }, 150);
    }
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d) {
    if (!preventScrolling || isWrappedWithClass(event, noWheelClassName)) {
      return null;
    }
    event.preventDefault();
    d3ZoomHandler.call(this, event, d);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    var _a, _b, _c;
    if ((_a = event.sourceEvent) == null ? void 0 : _a.internal) {
      return;
    }
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = ((_b = event.sourceEvent) == null ? void 0 : _b.button) || 0;
    zoomPanValues.isZoomingOrPanning = true;
    zoomPanValues.prevViewport = viewport;
    if (((_c = event.sourceEvent) == null ? void 0 : _c.type) === "mousedown") {
      onDraggingChange(true);
    }
    if (onPanZoomStart) {
      onPanZoomStart == null ? void 0 : onPanZoomStart(event.sourceEvent, viewport);
    }
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    var _a, _b;
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));
    if (!((_a = event.sourceEvent) == null ? void 0 : _a.sync)) {
      onTransformChange([event.transform.x, event.transform.y, event.transform.k]);
    }
    if (onPanZoom && !((_b = event.sourceEvent) == null ? void 0 : _b.internal)) {
      onPanZoom == null ? void 0 : onPanZoom(event.sourceEvent, transformToViewport(event.transform));
    }
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    var _a;
    if ((_a = event.sourceEvent) == null ? void 0 : _a.internal) {
      return;
    }
    zoomPanValues.isZoomingOrPanning = false;
    if (onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent) {
      onPaneContextMenu(event.sourceEvent);
    }
    zoomPanValues.usedRightMouseButton = false;
    onDraggingChange(false);
    if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport;
      clearTimeout(zoomPanValues.timerId);
      zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd == null ? void 0 : onPanZoomEnd(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib }) {
  return (event) => {
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
    const pinchZoom = zoomOnPinch && event.ctrlKey;
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {
      return true;
    }
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
      return false;
    }
    if (userSelectionActive) {
      return false;
    }
    if (!zoomOnDoubleClick && event.type === "dblclick") {
      return false;
    }
    if (isWrappedWithClass(event, noWheelClassName) && event.type === "wheel") {
      return false;
    }
    if (isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed)) {
      return false;
    }
    if (!zoomOnPinch && event.ctrlKey && event.type === "wheel") {
      return false;
    }
    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel") {
      return false;
    }
    if (!panOnDrag && (event.type === "mousedown" || event.type === "touchstart")) {
      return false;
    }
    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && (event.type === "mousedown" || event.type === "touchstart")) {
      return false;
    }
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onTransformChange, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: false,
    usedRightMouseButton: false,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: false
  };
  const bbox = domNode.getBoundingClientRect();
  const d3ZoomInstance = zoom_default2().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
  const d3Selection = select_default2(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    if (d3Selection) {
      d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(getD3Transition(d3Selection, options == null ? void 0 : options.duration), transform2);
    }
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib }) {
    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {
      destroy();
    }
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    d3Selection.on("wheel.zoom", wheelHandler, { passive: false });
    if (!userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib
    });
    d3ZoomInstance.filter(filter2);
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2);
    const contrainedTransform = d3ZoomInstance == null ? void 0 : d3ZoomInstance.constrain()(nextTransform, extent, translateExtent2);
    if (contrainedTransform) {
      setTransform(contrainedTransform);
    }
    return contrainedTransform;
  }
  function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    setTransform(nextTransform, options);
    return nextTransform;
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2);
      const currentTransform = d3Selection.property("__zoom");
      if (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(d3Selection, nextTransform, null, { sync: true });
      }
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    if (d3Selection) {
      d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleTo(getD3Transition(d3Selection, options == null ? void 0 : options.duration), zoom2);
    }
  }
  function scaleBy(factor, options) {
    if (d3Selection) {
      d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleBy(getD3Transition(d3Selection, options == null ? void 0 : options.duration), factor);
    }
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.translateExtent(translateExtent2);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/utils/index.js
var isNode = isNodeBase;
var isEdge = isEdgeBase;
var getOutgoers = getOutgoersBase;
var getIncomers = getIncomersBase;
var addEdge = addEdgeBase;
var updateEdge = updateEdgeBase;
var getConnectedEdges = getConnectedEdgesBase;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte
var file = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte";
function create_fragment(ctx) {
  let div;
  let div_data_id_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "data-handleid",
        /*handleId*/
        ctx[9]
      );
      attr_dev(
        div,
        "data-nodeid",
        /*nodeId*/
        ctx[7]
      );
      attr_dev(
        div,
        "data-handlepos",
        /*position*/
        ctx[2]
      );
      attr_dev(div, "data-id", div_data_id_value = /*nodeId*/
      ctx[7] + "-" + /*id*/
      (ctx[0] || null) + "-" + /*type*/
      ctx[1]);
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__handle",
        `svelte-flow__handle-${/*position*/
        ctx[2]}`,
        "nodrag",
        "nopan",
        /*position*/
        ctx[2],
        /*className*/
        ctx[4]
      ]));
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[3]
      );
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      toggle_class(div, "source", !/*isTarget*/
      ctx[6]);
      toggle_class(
        div,
        "target",
        /*isTarget*/
        ctx[6]
      );
      toggle_class(
        div,
        "connectablestart",
        /*handleConnectable*/
        ctx[5]
      );
      toggle_class(
        div,
        "connectableend",
        /*handleConnectable*/
        ctx[5]
      );
      toggle_class(
        div,
        "connectable",
        /*handleConnectable*/
        ctx[5]
      );
      toggle_class(
        div,
        "connectionindicator",
        /*handleConnectable*/
        ctx[5]
      );
      add_location(div, file, 107, 0, 2034);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "mousedown",
            /*onPointerDown*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchstart",
            /*onPointerDown*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*position*/
      4) {
        attr_dev(
          div,
          "data-handlepos",
          /*position*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*id, type*/
      3 && div_data_id_value !== (div_data_id_value = /*nodeId*/
      ctx2[7] + "-" + /*id*/
      (ctx2[0] || null) + "-" + /*type*/
      ctx2[1])) {
        attr_dev(div, "data-id", div_data_id_value);
      }
      if (!current || dirty[0] & /*position, className*/
      20 && div_class_value !== (div_class_value = cc([
        "svelte-flow__handle",
        `svelte-flow__handle-${/*position*/
        ctx2[2]}`,
        "nodrag",
        "nopan",
        /*position*/
        ctx2[2],
        /*className*/
        ctx2[4]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style*/
      8) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*position, className, isTarget*/
      84) {
        toggle_class(div, "source", !/*isTarget*/
        ctx2[6]);
      }
      if (!current || dirty[0] & /*position, className, isTarget*/
      84) {
        toggle_class(
          div,
          "target",
          /*isTarget*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*position, className, handleConnectable*/
      52) {
        toggle_class(
          div,
          "connectablestart",
          /*handleConnectable*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*position, className, handleConnectable*/
      52) {
        toggle_class(
          div,
          "connectableend",
          /*handleConnectable*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*position, className, handleConnectable*/
      52) {
        toggle_class(
          div,
          "connectable",
          /*handleConnectable*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*position, className, handleConnectable*/
      52) {
        toggle_class(
          div,
          "connectionindicator",
          /*handleConnectable*/
          ctx2[5]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let handleConnectable;
  let $viewport;
  let $isValidConnection;
  let $autoPanOnConnect;
  let $lib;
  let $connectionMode;
  let $nodes;
  let $domNode;
  let $connectionRadius;
  let $connectable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Handle", slots, ["default"]);
  let { id: id2 = void 0 } = $$props;
  let { type = "source" } = $$props;
  let { position = Position.Top } = $$props;
  let { style = void 0 } = $$props;
  let { isConnectable = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const isTarget = type === "target";
  const nodeId = getContext("svelteflow__node_id");
  const connectable = getContext("svelteflow__node_connectable");
  validate_store(connectable, "connectable");
  component_subscribe($$self, connectable, (value) => $$invalidate(20, $connectable = value));
  const handleId = id2 || null;
  const dispatch2 = createEventDispatcher();
  const store = useStore();
  const { connectionMode, domNode, nodes, connectionRadius, viewport, isValidConnection, lib, addEdge: addEdge2, panBy: panBy2, cancelConnection, updateConnection, autoPanOnConnect } = store;
  validate_store(connectionMode, "connectionMode");
  component_subscribe($$self, connectionMode, (value) => $$invalidate(27, $connectionMode = value));
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(29, $domNode = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(28, $nodes = value));
  validate_store(connectionRadius, "connectionRadius");
  component_subscribe($$self, connectionRadius, (value) => $$invalidate(30, $connectionRadius = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(23, $viewport = value));
  validate_store(isValidConnection, "isValidConnection");
  component_subscribe($$self, isValidConnection, (value) => $$invalidate(24, $isValidConnection = value));
  validate_store(lib, "lib");
  component_subscribe($$self, lib, (value) => $$invalidate(26, $lib = value));
  validate_store(autoPanOnConnect, "autoPanOnConnect");
  component_subscribe($$self, autoPanOnConnect, (value) => $$invalidate(25, $autoPanOnConnect = value));
  function onPointerDown2(event) {
    const isMouseTriggered = isMouseEvent(event);
    if (isMouseTriggered && event.button === 0 || !isMouseTriggered) {
      XYHandle.onPointerDown(event, {
        handleId,
        nodeId,
        isTarget,
        connectionRadius: $connectionRadius,
        domNode: $domNode,
        nodes: $nodes,
        connectionMode: $connectionMode,
        lib: $lib,
        autoPanOnConnect: $autoPanOnConnect,
        isValidConnection: $isValidConnection,
        updateConnection,
        cancelConnection,
        panBy: panBy2,
        onConnect: (connection) => {
          addEdge2(connection);
          dispatch2("connect", { connection });
        },
        onConnectStart: (event2, startParams) => {
          dispatch2("connectstart", {
            event: event2,
            nodeId: startParams.nodeId,
            handleId: startParams.handleId,
            handleType: startParams.handleType
          });
        },
        onConnectEnd: (event2) => {
          dispatch2("connectend", { event: event2 });
        },
        getTransform: () => [$viewport.x, $viewport.y, $viewport.zoom]
      });
    }
  }
  const writable_props = ["id", "type", "position", "style", "isConnectable", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Handle> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("isConnectable" in $$props2)
      $$invalidate(19, isConnectable = $$props2.isConnectable);
    if ("class" in $$props2)
      $$invalidate(4, className = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    createEventDispatcher,
    cc,
    Position,
    XYHandle,
    isMouseEvent,
    useStore,
    id: id2,
    type,
    position,
    style,
    isConnectable,
    className,
    isTarget,
    nodeId,
    connectable,
    handleId,
    dispatch: dispatch2,
    store,
    connectionMode,
    domNode,
    nodes,
    connectionRadius,
    viewport,
    isValidConnection,
    lib,
    addEdge: addEdge2,
    panBy: panBy2,
    cancelConnection,
    updateConnection,
    autoPanOnConnect,
    onPointerDown: onPointerDown2,
    handleConnectable,
    $viewport,
    $isValidConnection,
    $autoPanOnConnect,
    $lib,
    $connectionMode,
    $nodes,
    $domNode,
    $connectionRadius,
    $connectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("isConnectable" in $$props2)
      $$invalidate(19, isConnectable = $$props2.isConnectable);
    if ("className" in $$props2)
      $$invalidate(4, className = $$props2.className);
    if ("handleConnectable" in $$props2)
      $$invalidate(5, handleConnectable = $$props2.handleConnectable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*isConnectable, $connectable*/
    1572864) {
      $:
        $$invalidate(5, handleConnectable = isConnectable !== void 0 ? isConnectable : $connectable);
    }
  };
  return [
    id2,
    type,
    position,
    style,
    className,
    handleConnectable,
    isTarget,
    nodeId,
    connectable,
    handleId,
    connectionMode,
    domNode,
    nodes,
    connectionRadius,
    viewport,
    isValidConnection,
    lib,
    autoPanOnConnect,
    onPointerDown2,
    isConnectable,
    $connectable,
    $$scope,
    slots
  ];
}
var Handle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        id: 0,
        type: 1,
        position: 2,
        style: 3,
        isConnectable: 19,
        class: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Handle",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Handle_default = Handle;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte
function create_fragment2(ctx) {
  var _a;
  let handle0;
  let t02;
  let t1_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t12;
  let t22;
  let handle1;
  let current;
  handle0 = new Handle_default({
    props: {
      type: "target",
      position: (
        /*targetPosition*/
        ctx[1]
      )
    },
    $$inline: true
  });
  handle0.$on(
    "connectstart",
    /*connectstart_handler*/
    ctx[13]
  );
  handle0.$on(
    "connect",
    /*connect_handler*/
    ctx[14]
  );
  handle0.$on(
    "connectend",
    /*connectend_handler*/
    ctx[15]
  );
  handle1 = new Handle_default({
    props: {
      type: "source",
      position: (
        /*sourcePosition*/
        ctx[2]
      )
    },
    $$inline: true
  });
  handle1.$on(
    "connectstart",
    /*connectstart_handler_1*/
    ctx[16]
  );
  handle1.$on(
    "connect",
    /*connect_handler_1*/
    ctx[17]
  );
  handle1.$on(
    "connectend",
    /*connectend_handler_1*/
    ctx[18]
  );
  const block = {
    c: function create2() {
      create_component(handle0.$$.fragment);
      t02 = space();
      t12 = text(t1_value);
      t22 = space();
      create_component(handle1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(handle0, target, anchor);
      insert_dev(target, t02, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, t22, anchor);
      mount_component(handle1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      const handle0_changes = {};
      if (dirty & /*targetPosition*/
      2)
        handle0_changes.position = /*targetPosition*/
        ctx2[1];
      handle0.$set(handle0_changes);
      if ((!current || dirty & /*data*/
      1) && t1_value !== (t1_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + ""))
        set_data_dev(t12, t1_value);
      const handle1_changes = {};
      if (dirty & /*sourcePosition*/
      4)
        handle1_changes.position = /*sourcePosition*/
        ctx2[2];
      handle1.$set(handle1_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(handle0.$$.fragment, local2);
      transition_in(handle1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(handle0.$$.fragment, local2);
      transition_out(handle1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(t22);
      }
      destroy_component(handle0, detaching);
      destroy_component(handle1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { targetPosition = Position.Top } = $$props;
  let { sourcePosition = Position.Bottom } = $$props;
  let { id: id2 = "" } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { selected = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { dragging = false } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { positionAbsolute = { x: 0, y: 0 } } = $$props;
  let { isConnectable = void 0 } = $$props;
  id2;
  width;
  height;
  selected;
  type;
  zIndex;
  dragging;
  dragHandle;
  positionAbsolute;
  isConnectable;
  const writable_props = [
    "data",
    "targetPosition",
    "sourcePosition",
    "id",
    "width",
    "height",
    "selected",
    "type",
    "zIndex",
    "dragging",
    "dragHandle",
    "positionAbsolute",
    "isConnectable"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<DefaultNode> was created with unknown prop '${key2}'`);
  });
  function connectstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectstart_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("targetPosition" in $$props2)
      $$invalidate(1, targetPosition = $$props2.targetPosition);
    if ("sourcePosition" in $$props2)
      $$invalidate(2, sourcePosition = $$props2.sourcePosition);
    if ("id" in $$props2)
      $$invalidate(3, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("selected" in $$props2)
      $$invalidate(6, selected = $$props2.selected);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  $$self.$capture_state = () => ({
    Position,
    Handle: Handle_default,
    data,
    targetPosition,
    sourcePosition,
    id: id2,
    width,
    height,
    selected,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("targetPosition" in $$props2)
      $$invalidate(1, targetPosition = $$props2.targetPosition);
    if ("sourcePosition" in $$props2)
      $$invalidate(2, sourcePosition = $$props2.sourcePosition);
    if ("id" in $$props2)
      $$invalidate(3, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("selected" in $$props2)
      $$invalidate(6, selected = $$props2.selected);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    targetPosition,
    sourcePosition,
    id2,
    width,
    height,
    selected,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable,
    connectstart_handler,
    connect_handler,
    connectend_handler,
    connectstart_handler_1,
    connect_handler_1,
    connectend_handler_1
  ];
}
var DefaultNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      data: 0,
      targetPosition: 1,
      sourcePosition: 2,
      id: 3,
      width: 4,
      height: 5,
      selected: 6,
      type: 7,
      zIndex: 8,
      dragging: 9,
      dragHandle: 10,
      positionAbsolute: 11,
      isConnectable: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultNode",
      options,
      id: create_fragment2.name
    });
  }
  get data() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionAbsolute() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionAbsolute(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultNode_default = DefaultNode;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte
function create_fragment3(ctx) {
  var _a;
  let t0_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t02;
  let t12;
  let handle;
  let current;
  handle = new Handle_default({
    props: {
      type: "source",
      position: (
        /*sourcePosition*/
        ctx[1]
      )
    },
    $$inline: true
  });
  handle.$on(
    "connectstart",
    /*connectstart_handler*/
    ctx[13]
  );
  handle.$on(
    "connect",
    /*connect_handler*/
    ctx[14]
  );
  handle.$on(
    "connectend",
    /*connectend_handler*/
    ctx[15]
  );
  const block = {
    c: function create2() {
      t02 = text(t0_value);
      t12 = space();
      create_component(handle.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t02, anchor);
      insert_dev(target, t12, anchor);
      mount_component(handle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if ((!current || dirty & /*data*/
      1) && t0_value !== (t0_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + ""))
        set_data_dev(t02, t0_value);
      const handle_changes = {};
      if (dirty & /*sourcePosition*/
      2)
        handle_changes.position = /*sourcePosition*/
        ctx2[1];
      handle.$set(handle_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(handle.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(handle.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
      }
      destroy_component(handle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { sourcePosition = Position.Bottom } = $$props;
  let { id: id2 = "" } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { selected = void 0 } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { dragging = false } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { positionAbsolute = { x: 0, y: 0 } } = $$props;
  let { isConnectable = void 0 } = $$props;
  id2;
  width;
  height;
  selected;
  targetPosition;
  type;
  zIndex;
  dragging;
  dragHandle;
  positionAbsolute;
  isConnectable;
  const writable_props = [
    "data",
    "sourcePosition",
    "id",
    "width",
    "height",
    "selected",
    "targetPosition",
    "type",
    "zIndex",
    "dragging",
    "dragHandle",
    "positionAbsolute",
    "isConnectable"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<InputNode> was created with unknown prop '${key2}'`);
  });
  function connectstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("sourcePosition" in $$props2)
      $$invalidate(1, sourcePosition = $$props2.sourcePosition);
    if ("id" in $$props2)
      $$invalidate(2, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("targetPosition" in $$props2)
      $$invalidate(6, targetPosition = $$props2.targetPosition);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  $$self.$capture_state = () => ({
    Position,
    Handle: Handle_default,
    data,
    sourcePosition,
    id: id2,
    width,
    height,
    selected,
    targetPosition,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("sourcePosition" in $$props2)
      $$invalidate(1, sourcePosition = $$props2.sourcePosition);
    if ("id" in $$props2)
      $$invalidate(2, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("targetPosition" in $$props2)
      $$invalidate(6, targetPosition = $$props2.targetPosition);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    sourcePosition,
    id2,
    width,
    height,
    selected,
    targetPosition,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable,
    connectstart_handler,
    connect_handler,
    connectend_handler
  ];
}
var InputNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      data: 0,
      sourcePosition: 1,
      id: 2,
      width: 3,
      height: 4,
      selected: 5,
      targetPosition: 6,
      type: 7,
      zIndex: 8,
      dragging: 9,
      dragHandle: 10,
      positionAbsolute: 11,
      isConnectable: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputNode",
      options,
      id: create_fragment3.name
    });
  }
  get data() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionAbsolute() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionAbsolute(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputNode_default = InputNode;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte
function create_fragment4(ctx) {
  var _a;
  let t0_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t02;
  let t12;
  let handle;
  let current;
  handle = new Handle_default({
    props: {
      type: "target",
      position: (
        /*targetPosition*/
        ctx[1]
      )
    },
    $$inline: true
  });
  handle.$on(
    "connectstart",
    /*connectstart_handler*/
    ctx[13]
  );
  handle.$on(
    "connect",
    /*connect_handler*/
    ctx[14]
  );
  handle.$on(
    "connectend",
    /*connectend_handler*/
    ctx[15]
  );
  const block = {
    c: function create2() {
      t02 = text(t0_value);
      t12 = space();
      create_component(handle.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t02, anchor);
      insert_dev(target, t12, anchor);
      mount_component(handle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if ((!current || dirty & /*data*/
      1) && t0_value !== (t0_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + ""))
        set_data_dev(t02, t0_value);
      const handle_changes = {};
      if (dirty & /*targetPosition*/
      2)
        handle_changes.position = /*targetPosition*/
        ctx2[1];
      handle.$set(handle_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(handle.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(handle.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
      }
      destroy_component(handle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutputNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { targetPosition = Position.Top } = $$props;
  let { id: id2 = "" } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { selected = void 0 } = $$props;
  let { sourcePosition = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { dragging = false } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { positionAbsolute = { x: 0, y: 0 } } = $$props;
  let { isConnectable = void 0 } = $$props;
  id2;
  width;
  height;
  selected;
  sourcePosition;
  type;
  zIndex;
  dragging;
  dragHandle;
  positionAbsolute;
  isConnectable;
  const writable_props = [
    "data",
    "targetPosition",
    "id",
    "width",
    "height",
    "selected",
    "sourcePosition",
    "type",
    "zIndex",
    "dragging",
    "dragHandle",
    "positionAbsolute",
    "isConnectable"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<OutputNode> was created with unknown prop '${key2}'`);
  });
  function connectstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("targetPosition" in $$props2)
      $$invalidate(1, targetPosition = $$props2.targetPosition);
    if ("id" in $$props2)
      $$invalidate(2, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("sourcePosition" in $$props2)
      $$invalidate(6, sourcePosition = $$props2.sourcePosition);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  $$self.$capture_state = () => ({
    Position,
    Handle: Handle_default,
    data,
    targetPosition,
    id: id2,
    width,
    height,
    selected,
    sourcePosition,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("targetPosition" in $$props2)
      $$invalidate(1, targetPosition = $$props2.targetPosition);
    if ("id" in $$props2)
      $$invalidate(2, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("sourcePosition" in $$props2)
      $$invalidate(6, sourcePosition = $$props2.sourcePosition);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    data,
    targetPosition,
    id2,
    width,
    height,
    selected,
    sourcePosition,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable,
    connectstart_handler,
    connect_handler,
    connectend_handler
  ];
}
var OutputNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      data: 0,
      targetPosition: 1,
      id: 2,
      width: 3,
      height: 4,
      selected: 5,
      sourcePosition: 6,
      type: 7,
      zIndex: 8,
      dragging: 9,
      dragHandle: 10,
      positionAbsolute: 11,
      isConnectable: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutputNode",
      options,
      id: create_fragment4.name
    });
  }
  get data() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionAbsolute() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionAbsolute(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OutputNode_default = OutputNode;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte
function create_fragment5(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GroupNode", slots, []);
  let { id: id2 = "" } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { data = {} } = $$props;
  let { selected = void 0 } = $$props;
  let { sourcePosition = void 0 } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { dragging = false } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { positionAbsolute = { x: 0, y: 0 } } = $$props;
  let { isConnectable = void 0 } = $$props;
  id2;
  width;
  height;
  data;
  selected;
  sourcePosition;
  targetPosition;
  type;
  zIndex;
  dragging;
  dragHandle;
  positionAbsolute;
  isConnectable;
  const writable_props = [
    "id",
    "width",
    "height",
    "data",
    "selected",
    "sourcePosition",
    "targetPosition",
    "type",
    "zIndex",
    "dragging",
    "dragHandle",
    "positionAbsolute",
    "isConnectable"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<GroupNode> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("selected" in $$props2)
      $$invalidate(4, selected = $$props2.selected);
    if ("sourcePosition" in $$props2)
      $$invalidate(5, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2)
      $$invalidate(6, targetPosition = $$props2.targetPosition);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  $$self.$capture_state = () => ({
    id: id2,
    width,
    height,
    data,
    selected,
    sourcePosition,
    targetPosition,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("selected" in $$props2)
      $$invalidate(4, selected = $$props2.selected);
    if ("sourcePosition" in $$props2)
      $$invalidate(5, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2)
      $$invalidate(6, targetPosition = $$props2.targetPosition);
    if ("type" in $$props2)
      $$invalidate(7, type = $$props2.type);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("dragging" in $$props2)
      $$invalidate(9, dragging = $$props2.dragging);
    if ("dragHandle" in $$props2)
      $$invalidate(10, dragHandle = $$props2.dragHandle);
    if ("positionAbsolute" in $$props2)
      $$invalidate(11, positionAbsolute = $$props2.positionAbsolute);
    if ("isConnectable" in $$props2)
      $$invalidate(12, isConnectable = $$props2.isConnectable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id2,
    width,
    height,
    data,
    selected,
    sourcePosition,
    targetPosition,
    type,
    zIndex,
    dragging,
    dragHandle,
    positionAbsolute,
    isConnectable
  ];
}
var GroupNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      id: 0,
      width: 1,
      height: 2,
      data: 3,
      selected: 4,
      sourcePosition: 5,
      targetPosition: 6,
      type: 7,
      zIndex: 8,
      dragging: 9,
      dragHandle: 10,
      positionAbsolute: 11,
      isConnectable: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GroupNode",
      options,
      id: create_fragment5.name
    });
  }
  get id() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionAbsolute() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionAbsolute(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<GroupNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<GroupNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GroupNode_default = GroupNode;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/actions/portal/index.js
function tryToMount(node, domNode, target) {
  if (!domNode) {
    return;
  }
  const targetEl = target ? domNode.querySelector(target) : domNode;
  if (targetEl) {
    targetEl.appendChild(node);
  }
}
function portal_default(node, { target, domNode }) {
  tryToMount(node, domNode, target);
  return {
    async update({ target: target2, domNode: domNode2 }) {
      tryToMount(node, domNode2, target2);
    },
    destroy() {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/EdgeLabelRenderer/EdgeLabelRenderer.svelte
var file2 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/EdgeLabelRenderer/EdgeLabelRenderer.svelte";
function create_fragment6(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      add_location(div, file2, 9, 0, 144);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, {
          target: ".svelte-flow__edgelabel-renderer",
          domNode: (
            /*$domNode*/
            ctx[0]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      1)
        portal_action.update.call(null, {
          target: ".svelte-flow__edgelabel-renderer",
          domNode: (
            /*$domNode*/
            ctx2[0]
          )
        });
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeLabelRenderer", slots, ["default"]);
  const { domNode } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(0, $domNode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<EdgeLabelRenderer> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portal: portal_default, useStore, domNode, $domNode });
  return [$domNode, domNode, $$scope, slots];
}
var EdgeLabelRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeLabelRenderer",
      options,
      id: create_fragment6.name
    });
  }
};
var EdgeLabelRenderer_default = EdgeLabelRenderer;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/BaseEdge/BaseEdge.svelte
var file3 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/BaseEdge/BaseEdge.svelte";
function create_if_block_1(ctx) {
  let path_1;
  let path_1_stroke_opacity_value;
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[1]
      );
      attr_dev(path_1, "stroke-opacity", path_1_stroke_opacity_value = 0);
      attr_dev(
        path_1,
        "stroke-width",
        /*interactionWidthValue*/
        ctx[10]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(path_1, "class", "svelte-flow__edge-interaction");
      add_location(path_1, file3, 35, 2, 719);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      2) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(28:0) {#if interactionWidthValue}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let edgelabelrenderer;
  let current;
  edgelabelrenderer = new EdgeLabelRenderer_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(edgelabelrenderer.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(edgelabelrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgelabelrenderer_changes = {};
      if (dirty & /*$$scope, labelStyle, labelX, labelY, label*/
      4156) {
        edgelabelrenderer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      edgelabelrenderer.$set(edgelabelrenderer_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(edgelabelrenderer.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgelabelrenderer.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(edgelabelrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(38:0) {#if label}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let t;
  let style_transform = `translate(-50%, -50%) translate(${/*labelX*/
  ctx[3]}px,${/*labelY*/
  ctx[4]}px)`;
  const block = {
    c: function create2() {
      div = element("div");
      t = text(
        /*label*/
        ctx[2]
      );
      attr_dev(div, "class", "svelte-flow__edge-label");
      attr_dev(
        div,
        "style",
        /*labelStyle*/
        ctx[5]
      );
      set_style(div, "transform", style_transform);
      add_location(div, file3, 46, 4, 910);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      4)
        set_data_dev(
          t,
          /*label*/
          ctx2[2]
        );
      if (dirty & /*labelStyle*/
      32) {
        attr_dev(
          div,
          "style",
          /*labelStyle*/
          ctx2[5]
        );
      }
      const style_changed = dirty & /*labelStyle*/
      32;
      if (dirty & /*labelX, labelY, labelStyle*/
      56 && style_transform !== (style_transform = `translate(-50%, -50%) translate(${/*labelX*/
      ctx2[3]}px,${/*labelY*/
      ctx2[4]}px)`) || style_changed) {
        set_style(div, "transform", style_transform);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(39:2) <EdgeLabelRenderer>",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let path_1;
  let path_1_class_value;
  let t02;
  let t12;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*interactionWidthValue*/
    ctx[10] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*label*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      t02 = space();
      if (if_block0)
        if_block0.c();
      t12 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr_dev(
        path_1,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[1]
      );
      attr_dev(path_1, "class", path_1_class_value = cc([
        "svelte-flow__edge-path",
        /*className*/
        ctx[9]
      ]));
      attr_dev(
        path_1,
        "marker-start",
        /*markerStart*/
        ctx[6]
      );
      attr_dev(
        path_1,
        "marker-end",
        /*markerEnd*/
        ctx[7]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(
        path_1,
        "style",
        /*style*/
        ctx[8]
      );
      add_location(path_1, file3, 24, 0, 531);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
      insert_dev(target, t02, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      1) {
        attr_dev(
          path_1,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*path*/
      2) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*className*/
      512 && path_1_class_value !== (path_1_class_value = cc([
        "svelte-flow__edge-path",
        /*className*/
        ctx2[9]
      ]))) {
        attr_dev(path_1, "class", path_1_class_value);
      }
      if (!current || dirty & /*markerStart*/
      64) {
        attr_dev(
          path_1,
          "marker-start",
          /*markerStart*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*markerEnd*/
      128) {
        attr_dev(
          path_1,
          "marker-end",
          /*markerEnd*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*style*/
      256) {
        attr_dev(
          path_1,
          "style",
          /*style*/
          ctx2[8]
        );
      }
      if (
        /*interactionWidthValue*/
        ctx2[10]
      )
        if_block0.p(ctx2, dirty);
      if (
        /*label*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*label*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BaseEdge", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { path } = $$props;
  let { label = void 0 } = $$props;
  let { labelX = void 0 } = $$props;
  let { labelY = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { interactionWidth = 20 } = $$props;
  let { class: className = void 0 } = $$props;
  let interactionWidthValue = interactionWidth === void 0 ? 20 : interactionWidth;
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<BaseEdge> was created without expected prop 'path'");
    }
  });
  const writable_props = [
    "id",
    "path",
    "label",
    "labelX",
    "labelY",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "style",
    "interactionWidth",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<BaseEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("labelX" in $$props2)
      $$invalidate(3, labelX = $$props2.labelX);
    if ("labelY" in $$props2)
      $$invalidate(4, labelY = $$props2.labelY);
    if ("labelStyle" in $$props2)
      $$invalidate(5, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2)
      $$invalidate(6, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2)
      $$invalidate(7, markerEnd = $$props2.markerEnd);
    if ("style" in $$props2)
      $$invalidate(8, style = $$props2.style);
    if ("interactionWidth" in $$props2)
      $$invalidate(11, interactionWidth = $$props2.interactionWidth);
    if ("class" in $$props2)
      $$invalidate(9, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    EdgeLabelRenderer: EdgeLabelRenderer_default,
    id: id2,
    path,
    label,
    labelX,
    labelY,
    labelStyle,
    markerStart,
    markerEnd,
    style,
    interactionWidth,
    className,
    interactionWidthValue
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("labelX" in $$props2)
      $$invalidate(3, labelX = $$props2.labelX);
    if ("labelY" in $$props2)
      $$invalidate(4, labelY = $$props2.labelY);
    if ("labelStyle" in $$props2)
      $$invalidate(5, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2)
      $$invalidate(6, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2)
      $$invalidate(7, markerEnd = $$props2.markerEnd);
    if ("style" in $$props2)
      $$invalidate(8, style = $$props2.style);
    if ("interactionWidth" in $$props2)
      $$invalidate(11, interactionWidth = $$props2.interactionWidth);
    if ("className" in $$props2)
      $$invalidate(9, className = $$props2.className);
    if ("interactionWidthValue" in $$props2)
      $$invalidate(10, interactionWidthValue = $$props2.interactionWidthValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id2,
    path,
    label,
    labelX,
    labelY,
    labelStyle,
    markerStart,
    markerEnd,
    style,
    className,
    interactionWidthValue,
    interactionWidth
  ];
}
var BaseEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      id: 0,
      path: 1,
      label: 2,
      labelX: 3,
      labelY: 4,
      labelStyle: 5,
      markerStart: 6,
      markerEnd: 7,
      style: 8,
      interactionWidth: 11,
      class: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BaseEdge",
      options,
      id: create_fragment7.name
    });
  }
  get id() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelX() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelX(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelY() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelY(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BaseEdge_default = BaseEdge;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte
function create_fragment8(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[2]
      ),
      labelX: (
        /*labelX*/
        ctx[1]
      ),
      labelY: (
        /*labelY*/
        ctx[0]
      ),
      id: (
        /*$$props*/
        ctx[3].id
      ),
      label: (
        /*$$props*/
        ctx[3].label
      ),
      labelStyle: (
        /*$$props*/
        ctx[3].labelStyle
      ),
      markerStart: (
        /*$$props*/
        ctx[3].markerStart
      ),
      markerEnd: (
        /*$$props*/
        ctx[3].markerEnd
      ),
      interactionWidth: (
        /*$$props*/
        ctx[3].interactionWidth
      ),
      style: (
        /*$$props*/
        ctx[3].style
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      4)
        baseedge_changes.path = /*path*/
        ctx2[2];
      if (dirty & /*labelX*/
      2)
        baseedge_changes.labelX = /*labelX*/
        ctx2[1];
      if (dirty & /*labelY*/
      1)
        baseedge_changes.labelY = /*labelY*/
        ctx2[0];
      if (dirty & /*$$props*/
      8)
        baseedge_changes.id = /*$$props*/
        ctx2[3].id;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.label = /*$$props*/
        ctx2[3].label;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.labelStyle = /*$$props*/
        ctx2[3].labelStyle;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerStart = /*$$props*/
        ctx2[3].markerStart;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerEnd = /*$$props*/
        ctx2[3].markerEnd;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.interactionWidth = /*$$props*/
        ctx2[3].interactionWidth;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.style = /*$$props*/
        ctx2[3].style;
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BezierEdge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    getBezierPath,
    BaseEdge: BaseEdge_default,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("labelY" in $$props)
      $$invalidate(0, labelY = $$new_props.labelY);
    if ("labelX" in $$props)
      $$invalidate(1, labelX = $$new_props.labelX);
    if ("path" in $$props)
      $$invalidate(2, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(
        2,
        [path, labelX, labelY] = getBezierPath({
          sourceX: $$props.sourceX,
          sourceY: $$props.sourceY,
          targetX: $$props.targetX,
          targetY: $$props.targetY,
          sourcePosition: $$props.sourcePosition,
          targetPosition: $$props.targetPosition
        }),
        path,
        ($$invalidate(1, labelX), $$invalidate(3, $$props)),
        ($$invalidate(0, labelY), $$invalidate(3, $$props))
      );
  };
  $$props = exclude_internal_props($$props);
  return [labelY, labelX, path, $$props];
}
var BezierEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BezierEdge",
      options,
      id: create_fragment8.name
    });
  }
};
var BezierEdge_default = BezierEdge;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte
function create_fragment9(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[2]
      ),
      labelX: (
        /*labelX*/
        ctx[1]
      ),
      labelY: (
        /*labelY*/
        ctx[0]
      ),
      id: (
        /*$$props*/
        ctx[3].id
      ),
      label: (
        /*$$props*/
        ctx[3].label
      ),
      labelStyle: (
        /*$$props*/
        ctx[3].labelStyle
      ),
      markerStart: (
        /*$$props*/
        ctx[3].markerStart
      ),
      markerEnd: (
        /*$$props*/
        ctx[3].markerEnd
      ),
      interactionWidth: (
        /*$$props*/
        ctx[3].interactionWidth
      ),
      style: (
        /*$$props*/
        ctx[3].style
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      4)
        baseedge_changes.path = /*path*/
        ctx2[2];
      if (dirty & /*labelX*/
      2)
        baseedge_changes.labelX = /*labelX*/
        ctx2[1];
      if (dirty & /*labelY*/
      1)
        baseedge_changes.labelY = /*labelY*/
        ctx2[0];
      if (dirty & /*$$props*/
      8)
        baseedge_changes.id = /*$$props*/
        ctx2[3].id;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.label = /*$$props*/
        ctx2[3].label;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.labelStyle = /*$$props*/
        ctx2[3].labelStyle;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerStart = /*$$props*/
        ctx2[3].markerStart;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerEnd = /*$$props*/
        ctx2[3].markerEnd;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.interactionWidth = /*$$props*/
        ctx2[3].interactionWidth;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.style = /*$$props*/
        ctx2[3].style;
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StraightEdge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    getStraightPath,
    BaseEdge: BaseEdge_default,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("labelY" in $$props)
      $$invalidate(0, labelY = $$new_props.labelY);
    if ("labelX" in $$props)
      $$invalidate(1, labelX = $$new_props.labelX);
    if ("path" in $$props)
      $$invalidate(2, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(
        2,
        [path, labelX, labelY] = getStraightPath({
          sourceX: $$props.sourceX,
          sourceY: $$props.sourceY,
          targetX: $$props.targetX,
          targetY: $$props.targetY
        }),
        path,
        ($$invalidate(1, labelX), $$invalidate(3, $$props)),
        ($$invalidate(0, labelY), $$invalidate(3, $$props))
      );
  };
  $$props = exclude_internal_props($$props);
  return [labelY, labelX, path, $$props];
}
var StraightEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StraightEdge",
      options,
      id: create_fragment9.name
    });
  }
};
var StraightEdge_default = StraightEdge;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte
function create_fragment10(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[2]
      ),
      labelX: (
        /*labelX*/
        ctx[1]
      ),
      labelY: (
        /*labelY*/
        ctx[0]
      ),
      id: (
        /*$$props*/
        ctx[3].id
      ),
      label: (
        /*$$props*/
        ctx[3].label
      ),
      labelStyle: (
        /*$$props*/
        ctx[3].labelStyle
      ),
      markerStart: (
        /*$$props*/
        ctx[3].markerStart
      ),
      markerEnd: (
        /*$$props*/
        ctx[3].markerEnd
      ),
      interactionWidth: (
        /*$$props*/
        ctx[3].interactionWidth
      ),
      style: (
        /*$$props*/
        ctx[3].style
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      4)
        baseedge_changes.path = /*path*/
        ctx2[2];
      if (dirty & /*labelX*/
      2)
        baseedge_changes.labelX = /*labelX*/
        ctx2[1];
      if (dirty & /*labelY*/
      1)
        baseedge_changes.labelY = /*labelY*/
        ctx2[0];
      if (dirty & /*$$props*/
      8)
        baseedge_changes.id = /*$$props*/
        ctx2[3].id;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.label = /*$$props*/
        ctx2[3].label;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.labelStyle = /*$$props*/
        ctx2[3].labelStyle;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerStart = /*$$props*/
        ctx2[3].markerStart;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerEnd = /*$$props*/
        ctx2[3].markerEnd;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.interactionWidth = /*$$props*/
        ctx2[3].interactionWidth;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.style = /*$$props*/
        ctx2[3].style;
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmoothStepEdge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("labelY" in $$props)
      $$invalidate(0, labelY = $$new_props.labelY);
    if ("labelX" in $$props)
      $$invalidate(1, labelX = $$new_props.labelX);
    if ("path" in $$props)
      $$invalidate(2, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(
        2,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX: $$props.sourceX,
          sourceY: $$props.sourceY,
          targetX: $$props.targetX,
          targetY: $$props.targetY,
          sourcePosition: $$props.sourcePosition,
          targetPosition: $$props.targetPosition
        }),
        path,
        ($$invalidate(1, labelX), $$invalidate(3, $$props)),
        ($$invalidate(0, labelY), $$invalidate(3, $$props))
      );
  };
  $$props = exclude_internal_props($$props);
  return [labelY, labelX, path, $$props];
}
var SmoothStepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmoothStepEdge",
      options,
      id: create_fragment10.name
    });
  }
};
var SmoothStepEdge_default = SmoothStepEdge;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte
function create_fragment11(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[2]
      ),
      labelX: (
        /*labelX*/
        ctx[1]
      ),
      labelY: (
        /*labelY*/
        ctx[0]
      ),
      id: (
        /*$$props*/
        ctx[3].id
      ),
      label: (
        /*$$props*/
        ctx[3].label
      ),
      labelStyle: (
        /*$$props*/
        ctx[3].labelStyle
      ),
      markerStart: (
        /*$$props*/
        ctx[3].markerStart
      ),
      markerEnd: (
        /*$$props*/
        ctx[3].markerEnd
      ),
      interactionWidth: (
        /*$$props*/
        ctx[3].interactionWidth
      ),
      style: (
        /*$$props*/
        ctx[3].style
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      4)
        baseedge_changes.path = /*path*/
        ctx2[2];
      if (dirty & /*labelX*/
      2)
        baseedge_changes.labelX = /*labelX*/
        ctx2[1];
      if (dirty & /*labelY*/
      1)
        baseedge_changes.labelY = /*labelY*/
        ctx2[0];
      if (dirty & /*$$props*/
      8)
        baseedge_changes.id = /*$$props*/
        ctx2[3].id;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.label = /*$$props*/
        ctx2[3].label;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.labelStyle = /*$$props*/
        ctx2[3].labelStyle;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerStart = /*$$props*/
        ctx2[3].markerStart;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.markerEnd = /*$$props*/
        ctx2[3].markerEnd;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.interactionWidth = /*$$props*/
        ctx2[3].interactionWidth;
      if (dirty & /*$$props*/
      8)
        baseedge_changes.style = /*$$props*/
        ctx2[3].style;
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StepEdge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("labelY" in $$props)
      $$invalidate(0, labelY = $$new_props.labelY);
    if ("labelX" in $$props)
      $$invalidate(1, labelX = $$new_props.labelX);
    if ("path" in $$props)
      $$invalidate(2, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(
        2,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX: $$props.sourceX,
          sourceY: $$props.sourceY,
          targetX: $$props.targetX,
          targetY: $$props.targetY,
          sourcePosition: $$props.sourcePosition,
          targetPosition: $$props.targetPosition,
          borderRadius: 0
        }),
        path,
        ($$invalidate(1, labelX), $$invalidate(3, $$props)),
        ($$invalidate(0, labelY), $$invalidate(3, $$props))
      );
  };
  $$props = exclude_internal_props($$props);
  return [labelY, labelX, path, $$props];
}
var StepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StepEdge",
      options,
      id: create_fragment11.name
    });
  }
};
var StepEdge_default = StepEdge;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/store/utils.js
function syncNodeStores(nodesStore, userNodesStore) {
  const nodesStoreSetter = nodesStore.set;
  const userNodesStoreSetter = userNodesStore.set;
  const currentNodesStore = get_store_value(nodesStore);
  const currentUserNodesStore = get_store_value(userNodesStore);
  const initWithUserNodes = currentNodesStore.length === 0 && currentUserNodesStore.length > 0;
  let val = initWithUserNodes ? currentUserNodesStore : currentNodesStore;
  nodesStore.set(val);
  const _set = (nds) => {
    const updatedNodes = nodesStoreSetter(nds);
    val = updatedNodes;
    userNodesStoreSetter(val);
    return updatedNodes;
  };
  nodesStore.set = userNodesStore.set = _set;
  nodesStore.update = userNodesStore.update = (fn) => _set(fn(val));
}
function syncEdgeStores(edgesStore, userEdgesStore) {
  const nodesStoreSetter = edgesStore.set;
  const userEdgesStoreSetter = userEdgesStore.set;
  let val = get_store_value(userEdgesStore);
  edgesStore.set(val);
  const _set = (eds) => {
    nodesStoreSetter(eds);
    userEdgesStoreSetter(eds);
    val = eds;
  };
  edgesStore.set = userEdgesStore.set = _set;
  edgesStore.update = userEdgesStore.update = (fn) => _set(fn(val));
}
var syncViewportStores = (panZoomStore, viewportStore, userViewportStore) => {
  if (!userViewportStore) {
    return;
  }
  const panZoom = get_store_value(panZoomStore);
  const viewportStoreSetter = viewportStore.set;
  const userViewportStoreSetter = userViewportStore.set;
  let val = userViewportStore ? get_store_value(userViewportStore) : { x: 0, y: 0, zoom: 1 };
  viewportStore.set(val);
  viewportStore.set = (vp) => {
    viewportStoreSetter(vp);
    userViewportStoreSetter(vp);
    val = vp;
    return vp;
  };
  userViewportStore.set = (vp) => {
    panZoom == null ? void 0 : panZoom.syncViewport(vp);
    viewportStoreSetter(vp);
    userViewportStoreSetter(vp);
    val = vp;
    return vp;
  };
  viewportStore.update = (fn) => {
    viewportStore.set(fn(val));
  };
  userViewportStore.update = (fn) => {
    userViewportStore.set(fn(val));
  };
};
var createNodesStore = (nodes, nodeLookup) => {
  const { subscribe: subscribe2, set: set3, update } = writable([]);
  let value = nodes;
  let defaults = {};
  let elevateNodesOnSelect = true;
  const _set = (nds) => {
    const nextNodes = updateNodes(nds, nodeLookup, {
      elevateNodesOnSelect,
      defaults
    });
    value = nextNodes;
    set3(value);
    return value;
  };
  const _update = (fn) => _set(fn(value));
  const setDefaultOptions = (options) => {
    defaults = options;
  };
  const setOptions = (options) => {
    elevateNodesOnSelect = options.elevateNodesOnSelect ?? elevateNodesOnSelect;
  };
  _set(value);
  return {
    subscribe: subscribe2,
    set: _set,
    update: _update,
    setDefaultOptions,
    setOptions
  };
};
var createEdgesStore = (edges, defaultOptions) => {
  const { subscribe: subscribe2, set: set3, update } = writable([]);
  let value = edges;
  let defaults = defaultOptions || {};
  const _set = (eds) => {
    const nextEdges = defaults ? eds.map((edge) => ({ ...defaults, ...edge })) : eds;
    value = nextEdges;
    set3(value);
  };
  const _update = (fn) => _set(fn(value));
  const setDefaultOptions = (options) => {
    defaults = options;
  };
  _set(value);
  return {
    subscribe: subscribe2,
    set: _set,
    update: _update,
    setDefaultOptions
  };
};

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/store/derived-connection-props.js
var initConnectionProps = {
  path: null,
  sourceX: null,
  sourceY: null,
  sourcePosition: null,
  targetX: null,
  targetY: null,
  targetPosition: null,
  pointerPosition: null,
  startHandle: null,
  endHandle: null,
  status: null
};
var oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function getDerivedConnectionProps(store, currentConnection) {
  return derived([
    currentConnection,
    store.connectionLineType,
    store.connectionMode,
    store.nodeLookup,
    store.viewport
  ], ([connection, connectionLineType, connectionMode, nodeLookup, viewport]) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    if (!((_a = connection.connectionStartHandle) == null ? void 0 : _a.nodeId)) {
      return initConnectionProps;
    }
    const fromNode = nodeLookup.get((_b = connection.connectionStartHandle) == null ? void 0 : _b.nodeId);
    const fromHandleBounds = (_c = fromNode == null ? void 0 : fromNode[internalsSymbol]) == null ? void 0 : _c.handleBounds;
    const handleBoundsStrict = (fromHandleBounds == null ? void 0 : fromHandleBounds[connection.connectionStartHandle.type || "source"]) || [];
    const handleBoundsLoose = handleBoundsStrict ? handleBoundsStrict : fromHandleBounds == null ? void 0 : fromHandleBounds[((_d = connection == null ? void 0 : connection.connectionStartHandle) == null ? void 0 : _d.type) === "source" ? "target" : "source"];
    const handleBounds = connectionMode === ConnectionMode.Strict ? handleBoundsStrict : handleBoundsLoose;
    const fromHandle = ((_e = connection.connectionStartHandle) == null ? void 0 : _e.handleId) ? handleBounds.find((d) => {
      var _a2;
      return d.id === ((_a2 = connection.connectionStartHandle) == null ? void 0 : _a2.handleId);
    }) : handleBounds[0];
    const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (((_f = fromNode == null ? void 0 : fromNode.computed) == null ? void 0 : _f.width) ?? 0) / 2;
    const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : ((_g = fromNode == null ? void 0 : fromNode.computed) == null ? void 0 : _g.height) ?? 0;
    const fromX = (((_i = (_h = fromNode == null ? void 0 : fromNode.computed) == null ? void 0 : _h.positionAbsolute) == null ? void 0 : _i.x) ?? 0) + fromHandleX;
    const fromY = (((_k = (_j = fromNode == null ? void 0 : fromNode.computed) == null ? void 0 : _j.positionAbsolute) == null ? void 0 : _k.y) ?? 0) + fromHandleY;
    const fromPosition = fromHandle == null ? void 0 : fromHandle.position;
    const toPosition = fromPosition ? oppositePosition[fromPosition] : void 0;
    const pathParams = {
      sourceX: fromX,
      sourceY: fromY,
      sourcePosition: fromPosition,
      targetX: ((((_l = connection.connectionPosition) == null ? void 0 : _l.x) ?? 0) - viewport.x) / viewport.zoom,
      targetY: ((((_m = connection.connectionPosition) == null ? void 0 : _m.y) ?? 0) - viewport.y) / viewport.zoom,
      targetPosition: toPosition
    };
    let path = "";
    if (connectionLineType === ConnectionLineType.Bezier) {
      [path] = getBezierPath(pathParams);
    } else if (connectionLineType === ConnectionLineType.Step) {
      [path] = getSmoothStepPath({
        ...pathParams,
        borderRadius: 0
      });
    } else if (connectionLineType === ConnectionLineType.SmoothStep) {
      [path] = getSmoothStepPath(pathParams);
    } else {
      [path] = getStraightPath(pathParams);
    }
    return {
      path,
      ...pathParams,
      pointerPosition: connection.connectionPosition,
      startHandle: connection.connectionStartHandle,
      endHandle: connection.connectionEndHandle,
      status: connection.connectionStatus
    };
  });
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/store/initial-store.js
var initialNodeTypes = {
  input: InputNode_default,
  output: OutputNode_default,
  default: DefaultNode_default,
  group: GroupNode_default
};
var initialEdgeTypes = {
  straight: StraightEdge_default,
  smoothstep: SmoothStepEdge_default,
  default: BezierEdge_default,
  step: StepEdge_default
};
var getInitialStore = ({ nodes = [], edges = [], width, height, fitView: fitView2 }) => {
  const nodeLookup = /* @__PURE__ */ new Map();
  const nextNodes = updateNodes(nodes, nodeLookup, {
    nodeOrigin: [0, 0],
    elevateNodesOnSelect: false
  });
  let viewport = { x: 0, y: 0, zoom: 1 };
  if (fitView2 && width && height) {
    const nodesWithDimensions = nextNodes.filter((node) => node.width && node.height);
    const bounds = getNodesBounds(nodesWithDimensions, [0, 0]);
    viewport = getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
  }
  return {
    flowId: writable(null),
    nodes: createNodesStore(nextNodes, nodeLookup),
    nodeLookup: readable(nodeLookup),
    visibleNodes: readable([]),
    edges: createEdgesStore(edges),
    edgeTree: readable([]),
    height: writable(500),
    width: writable(500),
    minZoom: writable(0.5),
    maxZoom: writable(2),
    nodeOrigin: writable([0, 0]),
    nodeDragThreshold: writable(0),
    nodeExtent: writable(infiniteExtent),
    translateExtent: writable(infiniteExtent),
    autoPanOnNodeDrag: writable(true),
    autoPanOnConnect: writable(true),
    fitViewOnInit: writable(false),
    fitViewOnInitDone: writable(false),
    fitViewOptions: writable(void 0),
    panZoom: writable(null),
    snapGrid: writable(null),
    dragging: writable(false),
    selectionRect: writable(null),
    selectionKeyPressed: writable(false),
    multiselectionKeyPressed: writable(false),
    deleteKeyPressed: writable(false),
    panActivationKeyPressed: writable(false),
    zoomActivationKeyPressed: writable(false),
    selectionRectMode: writable(null),
    selectionMode: writable(SelectionMode.Partial),
    nodeTypes: writable(initialNodeTypes),
    edgeTypes: writable(initialEdgeTypes),
    viewport: writable(viewport),
    connectionMode: writable(ConnectionMode.Strict),
    domNode: writable(null),
    connection: readable(initConnectionProps),
    connectionLineType: writable(ConnectionLineType.Bezier),
    connectionRadius: writable(20),
    isValidConnection: writable(() => true),
    nodesDraggable: writable(true),
    nodesConnectable: writable(true),
    elementsSelectable: writable(true),
    selectNodesOnDrag: writable(true),
    markers: readable([]),
    defaultMarkerColor: writable("#b1b1b7"),
    lib: readable("svelte"),
    onlyRenderVisibleElements: writable(false),
    onerror: writable(devWarn),
    ondelete: writable(void 0)
  };
};

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/store/edge-tree.js
function getEdgeTree(store) {
  const visibleEdges = derived([
    store.edges,
    store.nodes,
    store.nodeLookup,
    store.onlyRenderVisibleElements,
    store.viewport,
    store.width,
    store.height
  ], ([edges, , nodeLookup, onlyRenderVisibleElements, viewport, width, height]) => {
    const visibleEdges2 = onlyRenderVisibleElements && width && height ? edges.filter((edge) => {
      const sourceNode = nodeLookup.get(edge.source);
      const targetNode = nodeLookup.get(edge.target);
      return sourceNode && targetNode && isEdgeVisible({
        sourceNode,
        targetNode,
        width,
        height,
        transform: [viewport.x, viewport.y, viewport.zoom]
      });
    }) : edges;
    return visibleEdges2;
  });
  return derived([visibleEdges, store.nodes, store.nodeLookup, store.connectionMode, store.onerror], ([visibleEdges2, , nodeLookup, connectionMode, onerror]) => {
    const layoutedEdges = visibleEdges2.reduce((res, edge) => {
      const sourceNode = nodeLookup.get(edge.source);
      const targetNode = nodeLookup.get(edge.target);
      if (!sourceNode || !targetNode) {
        return res;
      }
      const edgePosition = getEdgePosition({
        id: edge.id,
        sourceNode,
        targetNode,
        sourceHandle: edge.sourceHandle || null,
        targetHandle: edge.targetHandle || null,
        connectionMode,
        onError: onerror
      });
      if (edgePosition) {
        res.push({
          ...edge,
          ...edgePosition
        });
      }
      return res;
    }, []);
    const groupedEdges = groupEdgesByZLevel(layoutedEdges, nodeLookup, false);
    return groupedEdges;
  });
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/store/visible-nodes.js
function getVisibleNodes(store) {
  return derived([store.nodes, store.onlyRenderVisibleElements, store.width, store.height, store.viewport], ([nodes, onlyRenderVisibleElements, width, height, viewport]) => {
    const transform2 = [viewport.x, viewport.y, viewport.zoom];
    return onlyRenderVisibleElements ? getNodesInside(nodes, { x: 0, y: 0, width, height }, transform2, true) : nodes;
  });
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/store/index.js
var key = Symbol();
function createStore({ nodes, edges, width, height, fitView: fitViewOnCreate }) {
  const store = getInitialStore({ nodes, edges, width, height, fitView: fitViewOnCreate });
  function setNodeTypes(nodeTypes) {
    store.nodeTypes.set({
      ...initialNodeTypes,
      ...nodeTypes
    });
  }
  function setEdgeTypes(edgeTypes) {
    store.edgeTypes.set({
      ...initialEdgeTypes,
      ...edgeTypes
    });
  }
  function addEdge2(edgeParams) {
    const edges2 = get_store_value(store.edges);
    store.edges.set(addEdge(edgeParams, edges2));
  }
  const updateNodePositions = (nodeDragItems, dragging = false) => {
    store.nodes.update((nds) => {
      return nds.map((node) => {
        var _a;
        const nodeDragItem = nodeDragItems.find((ndi) => ndi.id === node.id);
        if (nodeDragItem) {
          return {
            ...node,
            dragging,
            position: nodeDragItem.position,
            computed: {
              ...node.computed,
              positionAbsolute: (_a = nodeDragItem.computed) == null ? void 0 : _a.positionAbsolute
            },
            [internalsSymbol]: node[internalsSymbol]
          };
        }
        return node;
      });
    });
  };
  function updateNodeDimensions2(updates) {
    const nextNodes = updateNodeDimensions(updates, get_store_value(store.nodes), get_store_value(store.nodeLookup), get_store_value(store.domNode), get_store_value(store.nodeOrigin));
    if (!nextNodes) {
      return;
    }
    if (!get_store_value(store.fitViewOnInitDone) && get_store_value(store.fitViewOnInit)) {
      const fitViewOptions = get_store_value(store.fitViewOptions);
      const fitViewOnInitDone = fitView2(nextNodes, {
        ...fitViewOptions,
        nodes: (fitViewOptions == null ? void 0 : fitViewOptions.nodes) || nextNodes
      });
      store.fitViewOnInitDone.set(fitViewOnInitDone);
    }
    store.nodes.set(nextNodes);
  }
  function fitView2(nodes2, options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return false;
    }
    return fitView({
      nodes: nodes2,
      width: get_store_value(store.width),
      height: get_store_value(store.height),
      minZoom: get_store_value(store.minZoom),
      maxZoom: get_store_value(store.maxZoom),
      panZoom,
      nodeOrigin: get_store_value(store.nodeOrigin)
    }, options);
  }
  function zoomBy(factor, options) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.scaleBy(factor, options);
    }
  }
  function zoomIn(options) {
    zoomBy(1.2, options);
  }
  function zoomOut(options) {
    zoomBy(1 / 1.2, options);
  }
  function setMinZoom(minZoom) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setScaleExtent([minZoom, get_store_value(store.maxZoom)]);
      store.minZoom.set(minZoom);
    }
  }
  function setMaxZoom(maxZoom) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setScaleExtent([get_store_value(store.minZoom), maxZoom]);
      store.maxZoom.set(maxZoom);
    }
  }
  function setTranslateExtent(extent) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setTranslateExtent(extent);
      store.translateExtent.set(extent);
    }
  }
  function resetSelectedItem(ids) {
    return (item) => {
      if (item.selected && ids.includes(item.id)) {
        return {
          ...item,
          selected: false
        };
      }
      return item;
    };
  }
  function unselectNodesAndEdges(params) {
    const nodeIdsToUnselect = ((params == null ? void 0 : params.nodes) ? params.nodes : get_store_value(store.nodes)).map((item) => item.id);
    const edgeIdsToUnselect = ((params == null ? void 0 : params.edges) ? params.edges : get_store_value(store.edges)).map((item) => item.id);
    store.nodes.update((ns) => ns.map(resetSelectedItem(nodeIdsToUnselect)));
    store.edges.update((es) => es.map(resetSelectedItem(edgeIdsToUnselect)));
  }
  store.deleteKeyPressed.subscribe((deleteKeyPressed) => {
    var _a;
    if (deleteKeyPressed) {
      const nodes2 = get_store_value(store.nodes);
      const edges2 = get_store_value(store.edges);
      const selectedNodes = nodes2.filter((node) => node.selected);
      const selectedEdges = edges2.filter((edge) => edge.selected);
      const { matchingNodes, matchingEdges } = getElementsToRemove({
        nodesToRemove: selectedNodes,
        edgesToRemove: selectedEdges,
        nodes: nodes2,
        edges: edges2
      });
      if (matchingNodes.length || matchingEdges.length) {
        store.nodes.update((nds) => nds.filter((node) => !matchingNodes.some((mN) => mN.id === node.id)));
        store.edges.update((eds) => eds.filter((edge) => !matchingEdges.some((mE) => mE.id === edge.id)));
        (_a = get_store_value(store.ondelete)) == null ? void 0 : _a({
          nodes: matchingNodes,
          edges: matchingEdges
        });
      }
    }
  });
  function addSelectedNodes(ids) {
    const isMultiSelection = get_store_value(store.multiselectionKeyPressed);
    store.nodes.update((ns) => ns.map((node) => {
      const nodeWillBeSelected = ids.includes(node.id);
      const selected = isMultiSelection ? node.selected || nodeWillBeSelected : nodeWillBeSelected;
      node.selected = selected;
      return node;
    }));
    if (!isMultiSelection) {
      store.edges.update((es) => es.map((edge) => {
        edge.selected = false;
        return edge;
      }));
    }
  }
  function addSelectedEdges(ids) {
    const isMultiSelection = get_store_value(store.multiselectionKeyPressed);
    store.edges.update((edges2) => edges2.map((edge) => {
      const edgeWillBeSelected = ids.includes(edge.id);
      const selected = isMultiSelection ? edge.selected || edgeWillBeSelected : edgeWillBeSelected;
      edge.selected = selected;
      return edge;
    }));
    if (!isMultiSelection) {
      store.nodes.update((ns) => ns.map((node) => {
        node.selected = false;
        return node;
      }));
    }
  }
  function handleNodeSelection(id2) {
    var _a;
    const node = (_a = get_store_value(store.nodes)) == null ? void 0 : _a.find((n) => n.id === id2);
    if (!node) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    store.selectionRect.set(null);
    store.selectionRectMode.set(null);
    if (!node.selected) {
      addSelectedNodes([id2]);
    } else if (node.selected && get_store_value(store.multiselectionKeyPressed)) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
    }
  }
  function panBy2(delta) {
    const viewport = get_store_value(store.viewport);
    return panBy({
      delta,
      panZoom: get_store_value(store.panZoom),
      transform: [viewport.x, viewport.y, viewport.zoom],
      translateExtent: get_store_value(store.translateExtent),
      width: get_store_value(store.width),
      height: get_store_value(store.height)
    });
  }
  const initConnectionUpdateData = {
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionPosition: null,
    connectionStatus: null
  };
  const currentConnection = writable(initConnectionUpdateData);
  const updateConnection = (newConnection) => {
    currentConnection.set(newConnection);
  };
  function cancelConnection() {
    updateConnection(initConnectionUpdateData);
  }
  function reset() {
    store.fitViewOnInitDone.set(false);
    store.selectionRect.set(null);
    store.selectionRectMode.set(null);
    store.snapGrid.set(null);
    store.isValidConnection.set(() => true);
    store.nodes.set([]);
    store.edges.set([]);
    unselectNodesAndEdges();
    cancelConnection();
  }
  return {
    // state
    ...store,
    // derived state
    edgeTree: getEdgeTree(store),
    connection: getDerivedConnectionProps(store, currentConnection),
    visibleNodes: getVisibleNodes(store),
    markers: derived([store.edges, store.defaultMarkerColor, store.flowId], ([edges2, defaultColor, id2]) => createMarkerIds(edges2, { defaultColor, id: id2 })),
    // actions
    syncNodeStores: (nodes2) => syncNodeStores(store.nodes, nodes2),
    syncEdgeStores: (edges2) => syncEdgeStores(store.edges, edges2),
    syncViewport: (viewport) => syncViewportStores(store.panZoom, store.viewport, viewport),
    setNodeTypes,
    setEdgeTypes,
    addEdge: addEdge2,
    updateNodePositions,
    updateNodeDimensions: updateNodeDimensions2,
    zoomIn,
    zoomOut,
    fitView: (options) => fitView2(get_store_value(store.nodes), options),
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    unselectNodesAndEdges,
    addSelectedNodes,
    addSelectedEdges,
    handleNodeSelection,
    panBy: panBy2,
    updateConnection,
    cancelConnection,
    reset
  };
}
function useStore() {
  const store = getContext(key);
  if (!store) {
    throw new Error("In order to use useStore you need to wrap your component in a <SvelteFlowProvider />");
  }
  return store.getStore();
}
function createStoreContext({ nodes, edges, width, height, fitView: fitView2 }) {
  const store = createStore({ nodes, edges, width, height, fitView: fitView2 });
  setContext(key, {
    getStore: () => store
  });
  return store;
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/actions/zoom/index.js
function zoom(domNode, params) {
  const { panZoom, minZoom, maxZoom, initialViewport, viewport, dragging, translateExtent } = params;
  const panZoomInstance = XYPanZoom({
    domNode,
    minZoom,
    maxZoom,
    translateExtent,
    viewport: initialViewport,
    onTransformChange: (transform2) => viewport.set({ x: transform2[0], y: transform2[1], zoom: transform2[2] }),
    onDraggingChange: dragging.set
  });
  const currentViewport = panZoomInstance.getViewport();
  viewport.set(currentViewport);
  panZoom.set(panZoomInstance);
  panZoomInstance.update(params);
  return {
    update(params2) {
      panZoomInstance.update(params2);
    }
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte
var file4 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte";
function add_css(target) {
  append_styles(target, "svelte-4xkw84", ".svelte-flow__zoom.svelte-4xkw84{width:100%;height:100%;position:absolute;top:0;left:0;z-index:4}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWm9vbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdUVFLGdDQUFtQixDQUNqQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLE9BQU8sQ0FBRSxDQUNYIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJab29tLnN2ZWx0ZSJdfQ== */");
}
function create_fragment12(ctx) {
  let div;
  let zoom_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[32].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "svelte-flow__zoom svelte-4xkw84");
      add_location(div, file4, 39, 0, 822);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(zoom_action = zoom.call(null, div, {
          viewport: (
            /*viewport*/
            ctx[17]
          ),
          minZoom: (
            /*$minZoom*/
            ctx[11]
          ),
          maxZoom: (
            /*$maxZoom*/
            ctx[12]
          ),
          initialViewport: (
            /*viewPort*/
            ctx[10]
          ),
          dragging: (
            /*dragging*/
            ctx[22]
          ),
          panZoom: (
            /*panZoom*/
            ctx[18]
          ),
          onPanZoomStart: (
            /*onMoveStart*/
            ctx[0]
          ),
          onPanZoom: (
            /*onMove*/
            ctx[1]
          ),
          onPanZoomEnd: (
            /*onMoveEnd*/
            ctx[2]
          ),
          zoomOnScroll: (
            /*zoomOnScroll*/
            ctx[5]
          ),
          zoomOnDoubleClick: (
            /*zoomOnDoubleClick*/
            ctx[6]
          ),
          zoomOnPinch: (
            /*zoomOnPinch*/
            ctx[7]
          ),
          panOnScroll: (
            /*_panOnScroll*/
            ctx[8]
          ),
          panOnDrag: (
            /*_panOnDrag*/
            ctx[9]
          ),
          panOnScrollSpeed: 0.5,
          panOnScrollMode: (
            /*panOnScrollMode*/
            ctx[3] || PanOnScrollMode.Free
          ),
          zoomActivationKeyPressed: (
            /*$zoomActivationKeyPressed*/
            ctx[13]
          ),
          preventScrolling: typeof /*preventScrolling*/
          ctx[4] === "boolean" ? (
            /*preventScrolling*/
            ctx[4]
          ) : true,
          noPanClassName: "nopan",
          noWheelClassName: "nowheel",
          userSelectionActive: (
            /*$selectionKeyPressed*/
            ctx[14]
          ),
          translateExtent: (
            /*$translateExtent*/
            ctx[15]
          ),
          lib: (
            /*$lib*/
            ctx[16]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (zoom_action && is_function(zoom_action.update) && dirty[0] & /*$minZoom, $maxZoom, viewPort, onMoveStart, onMove, onMoveEnd, zoomOnScroll, zoomOnDoubleClick, zoomOnPinch, _panOnScroll, _panOnDrag, panOnScrollMode, $zoomActivationKeyPressed, preventScrolling, $selectionKeyPressed, $translateExtent, $lib*/
      131071)
        zoom_action.update.call(null, {
          viewport: (
            /*viewport*/
            ctx2[17]
          ),
          minZoom: (
            /*$minZoom*/
            ctx2[11]
          ),
          maxZoom: (
            /*$maxZoom*/
            ctx2[12]
          ),
          initialViewport: (
            /*viewPort*/
            ctx2[10]
          ),
          dragging: (
            /*dragging*/
            ctx2[22]
          ),
          panZoom: (
            /*panZoom*/
            ctx2[18]
          ),
          onPanZoomStart: (
            /*onMoveStart*/
            ctx2[0]
          ),
          onPanZoom: (
            /*onMove*/
            ctx2[1]
          ),
          onPanZoomEnd: (
            /*onMoveEnd*/
            ctx2[2]
          ),
          zoomOnScroll: (
            /*zoomOnScroll*/
            ctx2[5]
          ),
          zoomOnDoubleClick: (
            /*zoomOnDoubleClick*/
            ctx2[6]
          ),
          zoomOnPinch: (
            /*zoomOnPinch*/
            ctx2[7]
          ),
          panOnScroll: (
            /*_panOnScroll*/
            ctx2[8]
          ),
          panOnDrag: (
            /*_panOnDrag*/
            ctx2[9]
          ),
          panOnScrollSpeed: 0.5,
          panOnScrollMode: (
            /*panOnScrollMode*/
            ctx2[3] || PanOnScrollMode.Free
          ),
          zoomActivationKeyPressed: (
            /*$zoomActivationKeyPressed*/
            ctx2[13]
          ),
          preventScrolling: typeof /*preventScrolling*/
          ctx2[4] === "boolean" ? (
            /*preventScrolling*/
            ctx2[4]
          ) : true,
          noPanClassName: "nopan",
          noWheelClassName: "nowheel",
          userSelectionActive: (
            /*$selectionKeyPressed*/
            ctx2[14]
          ),
          translateExtent: (
            /*$translateExtent*/
            ctx2[15]
          ),
          lib: (
            /*$lib*/
            ctx2[16]
          )
        });
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let viewPort;
  let _panOnDrag;
  let _panOnScroll;
  let $panActivationKeyPressed;
  let $minZoom;
  let $maxZoom;
  let $zoomActivationKeyPressed;
  let $selectionKeyPressed;
  let $translateExtent;
  let $lib;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Zoom", slots, ["default"]);
  let { initialViewport } = $$props;
  let { onMoveStart = void 0 } = $$props;
  let { onMove = void 0 } = $$props;
  let { onMoveEnd = void 0 } = $$props;
  let { panOnScrollMode } = $$props;
  let { preventScrolling } = $$props;
  let { zoomOnScroll } = $$props;
  let { zoomOnDoubleClick } = $$props;
  let { zoomOnPinch } = $$props;
  let { panOnDrag } = $$props;
  let { panOnScroll } = $$props;
  const { viewport, panZoom, selectionKeyPressed, minZoom, maxZoom, dragging, translateExtent, lib, panActivationKeyPressed, zoomActivationKeyPressed } = useStore();
  validate_store(selectionKeyPressed, "selectionKeyPressed");
  component_subscribe($$self, selectionKeyPressed, (value) => $$invalidate(14, $selectionKeyPressed = value));
  validate_store(minZoom, "minZoom");
  component_subscribe($$self, minZoom, (value) => $$invalidate(11, $minZoom = value));
  validate_store(maxZoom, "maxZoom");
  component_subscribe($$self, maxZoom, (value) => $$invalidate(12, $maxZoom = value));
  validate_store(translateExtent, "translateExtent");
  component_subscribe($$self, translateExtent, (value) => $$invalidate(15, $translateExtent = value));
  validate_store(lib, "lib");
  component_subscribe($$self, lib, (value) => $$invalidate(16, $lib = value));
  validate_store(panActivationKeyPressed, "panActivationKeyPressed");
  component_subscribe($$self, panActivationKeyPressed, (value) => $$invalidate(30, $panActivationKeyPressed = value));
  validate_store(zoomActivationKeyPressed, "zoomActivationKeyPressed");
  component_subscribe($$self, zoomActivationKeyPressed, (value) => $$invalidate(13, $zoomActivationKeyPressed = value));
  $$self.$$.on_mount.push(function() {
    if (initialViewport === void 0 && !("initialViewport" in $$props || $$self.$$.bound[$$self.$$.props["initialViewport"]])) {
      console.warn("<Zoom> was created without expected prop 'initialViewport'");
    }
    if (panOnScrollMode === void 0 && !("panOnScrollMode" in $$props || $$self.$$.bound[$$self.$$.props["panOnScrollMode"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnScrollMode'");
    }
    if (preventScrolling === void 0 && !("preventScrolling" in $$props || $$self.$$.bound[$$self.$$.props["preventScrolling"]])) {
      console.warn("<Zoom> was created without expected prop 'preventScrolling'");
    }
    if (zoomOnScroll === void 0 && !("zoomOnScroll" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnScroll"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnScroll'");
    }
    if (zoomOnDoubleClick === void 0 && !("zoomOnDoubleClick" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnDoubleClick"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnDoubleClick'");
    }
    if (zoomOnPinch === void 0 && !("zoomOnPinch" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnPinch"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnPinch'");
    }
    if (panOnDrag === void 0 && !("panOnDrag" in $$props || $$self.$$.bound[$$self.$$.props["panOnDrag"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnDrag'");
    }
    if (panOnScroll === void 0 && !("panOnScroll" in $$props || $$self.$$.bound[$$self.$$.props["panOnScroll"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnScroll'");
    }
  });
  const writable_props = [
    "initialViewport",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnDrag",
    "panOnScroll"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Zoom> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("initialViewport" in $$props2)
      $$invalidate(27, initialViewport = $$props2.initialViewport);
    if ("onMoveStart" in $$props2)
      $$invalidate(0, onMoveStart = $$props2.onMoveStart);
    if ("onMove" in $$props2)
      $$invalidate(1, onMove = $$props2.onMove);
    if ("onMoveEnd" in $$props2)
      $$invalidate(2, onMoveEnd = $$props2.onMoveEnd);
    if ("panOnScrollMode" in $$props2)
      $$invalidate(3, panOnScrollMode = $$props2.panOnScrollMode);
    if ("preventScrolling" in $$props2)
      $$invalidate(4, preventScrolling = $$props2.preventScrolling);
    if ("zoomOnScroll" in $$props2)
      $$invalidate(5, zoomOnScroll = $$props2.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props2)
      $$invalidate(6, zoomOnDoubleClick = $$props2.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props2)
      $$invalidate(7, zoomOnPinch = $$props2.zoomOnPinch);
    if ("panOnDrag" in $$props2)
      $$invalidate(28, panOnDrag = $$props2.panOnDrag);
    if ("panOnScroll" in $$props2)
      $$invalidate(29, panOnScroll = $$props2.panOnScroll);
    if ("$$scope" in $$props2)
      $$invalidate(31, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    PanOnScrollMode,
    useStore,
    zoom,
    initialViewport,
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnDrag,
    panOnScroll,
    viewport,
    panZoom,
    selectionKeyPressed,
    minZoom,
    maxZoom,
    dragging,
    translateExtent,
    lib,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    _panOnScroll,
    _panOnDrag,
    viewPort,
    $panActivationKeyPressed,
    $minZoom,
    $maxZoom,
    $zoomActivationKeyPressed,
    $selectionKeyPressed,
    $translateExtent,
    $lib
  });
  $$self.$inject_state = ($$props2) => {
    if ("initialViewport" in $$props2)
      $$invalidate(27, initialViewport = $$props2.initialViewport);
    if ("onMoveStart" in $$props2)
      $$invalidate(0, onMoveStart = $$props2.onMoveStart);
    if ("onMove" in $$props2)
      $$invalidate(1, onMove = $$props2.onMove);
    if ("onMoveEnd" in $$props2)
      $$invalidate(2, onMoveEnd = $$props2.onMoveEnd);
    if ("panOnScrollMode" in $$props2)
      $$invalidate(3, panOnScrollMode = $$props2.panOnScrollMode);
    if ("preventScrolling" in $$props2)
      $$invalidate(4, preventScrolling = $$props2.preventScrolling);
    if ("zoomOnScroll" in $$props2)
      $$invalidate(5, zoomOnScroll = $$props2.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props2)
      $$invalidate(6, zoomOnDoubleClick = $$props2.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props2)
      $$invalidate(7, zoomOnPinch = $$props2.zoomOnPinch);
    if ("panOnDrag" in $$props2)
      $$invalidate(28, panOnDrag = $$props2.panOnDrag);
    if ("panOnScroll" in $$props2)
      $$invalidate(29, panOnScroll = $$props2.panOnScroll);
    if ("_panOnScroll" in $$props2)
      $$invalidate(8, _panOnScroll = $$props2._panOnScroll);
    if ("_panOnDrag" in $$props2)
      $$invalidate(9, _panOnDrag = $$props2._panOnDrag);
    if ("viewPort" in $$props2)
      $$invalidate(10, viewPort = $$props2.viewPort);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*initialViewport*/
    134217728) {
      $:
        $$invalidate(10, viewPort = initialViewport || { x: 0, y: 0, zoom: 1 });
    }
    if ($$self.$$.dirty[0] & /*$panActivationKeyPressed, panOnDrag*/
    1342177280) {
      $:
        $$invalidate(9, _panOnDrag = $panActivationKeyPressed || panOnDrag);
    }
    if ($$self.$$.dirty[0] & /*$panActivationKeyPressed, panOnScroll*/
    1610612736) {
      $:
        $$invalidate(8, _panOnScroll = $panActivationKeyPressed || panOnScroll);
    }
  };
  return [
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    _panOnScroll,
    _panOnDrag,
    viewPort,
    $minZoom,
    $maxZoom,
    $zoomActivationKeyPressed,
    $selectionKeyPressed,
    $translateExtent,
    $lib,
    viewport,
    panZoom,
    selectionKeyPressed,
    minZoom,
    maxZoom,
    dragging,
    translateExtent,
    lib,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    initialViewport,
    panOnDrag,
    panOnScroll,
    $panActivationKeyPressed,
    $$scope,
    slots
  ];
}
var Zoom = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        initialViewport: 27,
        onMoveStart: 0,
        onMove: 1,
        onMoveEnd: 2,
        panOnScrollMode: 3,
        preventScrolling: 4,
        zoomOnScroll: 5,
        zoomOnDoubleClick: 6,
        zoomOnPinch: 7,
        panOnDrag: 28,
        panOnScroll: 29
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Zoom",
      options,
      id: create_fragment12.name
    });
  }
  get initialViewport() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialViewport(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveStart() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveStart(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMove() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMove(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveEnd() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveEnd(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScrollMode() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScrollMode(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScrolling() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScrolling(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnScroll() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnScroll(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnDoubleClick() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnDoubleClick(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnPinch() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnPinch(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnDrag() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScroll() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScroll(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Zoom_default = Zoom;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte
var file5 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1esy7hx", ".svelte-flow__pane.svelte-1esy7hx{position:absolute;top:0;left:0;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFuZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb05FLGlDQUFtQixDQUNqQixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFDViIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiUGFuZS5zdmVsdGUiXX0= */");
}
function create_fragment13(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "svelte-flow__pane svelte-1esy7hx");
      toggle_class(
        div,
        "dragging",
        /*$dragging*/
        ctx[3]
      );
      toggle_class(
        div,
        "selection",
        /*isSelecting*/
        ctx[0]
      );
      add_location(div, file5, 196, 0, 4091);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[29](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[2] ? void 0 : wrapHandler(
                  /*onClick*/
                  ctx[14],
                  /*container*/
                  ctx[1]
                )
              ))
                /*hasActiveSelection*/
                (ctx[2] ? void 0 : wrapHandler(
                  /*onClick*/
                  ctx[14],
                  /*container*/
                  ctx[1]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousedown",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[2] ? (
                  /*onMouseDown*/
                  ctx[15]
                ) : void 0
              ))
                /*hasActiveSelection*/
                (ctx[2] ? (
                  /*onMouseDown*/
                  ctx[15]
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousemove",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[2] ? (
                  /*onMouseMove*/
                  ctx[16]
                ) : void 0
              ))
                /*hasActiveSelection*/
                (ctx[2] ? (
                  /*onMouseMove*/
                  ctx[16]
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseup",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[2] ? (
                  /*onMouseUp*/
                  ctx[17]
                ) : void 0
              ))
                /*hasActiveSelection*/
                (ctx[2] ? (
                  /*onMouseUp*/
                  ctx[17]
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[2] ? (
                  /*onMouseLeave*/
                  ctx[18]
                ) : void 0
              ))
                /*hasActiveSelection*/
                (ctx[2] ? (
                  /*onMouseLeave*/
                  ctx[18]
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            function() {
              if (is_function(wrapHandler(
                /*onContextMenu*/
                ctx[19],
                /*container*/
                ctx[1]
              )))
                wrapHandler(
                  /*onContextMenu*/
                  ctx[19],
                  /*container*/
                  ctx[1]
                ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*$dragging*/
      8) {
        toggle_class(
          div,
          "dragging",
          /*$dragging*/
          ctx[3]
        );
      }
      if (!current || dirty[0] & /*isSelecting*/
      1) {
        toggle_class(
          div,
          "selection",
          /*isSelecting*/
          ctx[0]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function wrapHandler(handler, container) {
  return (event) => {
    if (event.target !== container) {
      return;
    }
    handler == null ? void 0 : handler(event);
  };
}
function toggleSelected(ids) {
  return (item) => {
    const isSelected = ids.includes(item.id);
    if (item.selected !== isSelected) {
      return { ...item, selected: isSelected };
    }
    return item;
  };
}
function instance13($$self, $$props, $$invalidate) {
  let _panOnDrag;
  let isSelecting;
  let hasActiveSelection;
  let $selectionRectMode;
  let $edges;
  let $selectionMode;
  let $viewport;
  let $nodes;
  let $selectionRect;
  let $elementsSelectable;
  let $selectionKeyPressed;
  let $panActivationKeyPressed;
  let $dragging;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane", slots, ["default"]);
  let { panOnDrag = void 0 } = $$props;
  let { selectionOnDrag = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  const { nodes, edges, viewport, dragging, elementsSelectable, selectionRect, selectionRectMode, selectionKeyPressed, selectionMode, panActivationKeyPressed, unselectNodesAndEdges } = useStore();
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(35, $nodes = value));
  validate_store(edges, "edges");
  component_subscribe($$self, edges, (value) => $$invalidate(32, $edges = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(34, $viewport = value));
  validate_store(dragging, "dragging");
  component_subscribe($$self, dragging, (value) => $$invalidate(3, $dragging = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(24, $elementsSelectable = value));
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(36, $selectionRect = value));
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(23, $selectionRectMode = value));
  validate_store(selectionKeyPressed, "selectionKeyPressed");
  component_subscribe($$self, selectionKeyPressed, (value) => $$invalidate(25, $selectionKeyPressed = value));
  validate_store(selectionMode, "selectionMode");
  component_subscribe($$self, selectionMode, (value) => $$invalidate(33, $selectionMode = value));
  validate_store(panActivationKeyPressed, "panActivationKeyPressed");
  component_subscribe($$self, panActivationKeyPressed, (value) => $$invalidate(26, $panActivationKeyPressed = value));
  let container;
  let containerBounds = null;
  let selectedNodes = [];
  function onClick(event) {
    dispatch2("paneclick", { event });
    unselectNodesAndEdges();
    selectionRectMode.set(null);
  }
  function onMouseDown(event) {
    containerBounds = container.getBoundingClientRect();
    if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container || !containerBounds) {
      return;
    }
    const { x, y } = getEventPosition(event, containerBounds);
    unselectNodesAndEdges();
    selectionRect.set({
      width: 0,
      height: 0,
      startX: x,
      startY: y,
      x,
      y
    });
  }
  function onMouseMove(event) {
    if (!isSelecting || !containerBounds || !$selectionRect) {
      return;
    }
    const mousePos = getEventPosition(event, containerBounds);
    const startX = $selectionRect.startX ?? 0;
    const startY = $selectionRect.startY ?? 0;
    const nextUserSelectRect = {
      ...$selectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const prevSelectedNodeIds = selectedNodes.map((n) => n.id);
    const prevSelectedEdgeIds = getConnectedEdges(selectedNodes, $edges).map((e) => e.id);
    selectedNodes = getNodesInside($nodes, nextUserSelectRect, [$viewport.x, $viewport.y, $viewport.zoom], $selectionMode === SelectionMode.Partial, true);
    const selectedEdgeIds = getConnectedEdges(selectedNodes, $edges).map((e) => e.id);
    const selectedNodeIds = selectedNodes.map((n) => n.id);
    if (prevSelectedNodeIds.length !== selectedNodeIds.length || selectedNodeIds.some((id2) => !prevSelectedNodeIds.includes(id2))) {
      nodes.update((nodes2) => nodes2.map(toggleSelected(selectedNodeIds)));
    }
    if (prevSelectedEdgeIds.length !== selectedEdgeIds.length || selectedEdgeIds.some((id2) => !prevSelectedEdgeIds.includes(id2))) {
      edges.update((edges2) => edges2.map(toggleSelected(selectedEdgeIds)));
    }
    selectionRectMode.set("user");
    selectionRect.set(nextUserSelectRect);
  }
  function onMouseUp(event) {
    if (event.button !== 0) {
      return;
    }
    if (!isSelecting && $selectionRectMode === "user" && event.target === container) {
      onClick == null ? void 0 : onClick(event);
    }
    selectionRect.set(null);
    if (selectedNodes.length > 0) {
      selectionRectMode.set("nodes");
    }
  }
  const onMouseLeave = (event) => {
    if ($selectionRectMode === "user") {
      selectionRectMode.set(selectedNodes.length > 0 ? "nodes" : null);
    }
    selectionRect.set(null);
  };
  const onContextMenu = (event) => {
    if (Array.isArray(_panOnDrag) && (_panOnDrag == null ? void 0 : _panOnDrag.includes(2))) {
      event.preventDefault();
      return;
    }
    dispatch2("panecontextmenu", { event });
  };
  const writable_props = ["panOnDrag", "selectionOnDrag"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Pane> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(1, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("panOnDrag" in $$props2)
      $$invalidate(20, panOnDrag = $$props2.panOnDrag);
    if ("selectionOnDrag" in $$props2)
      $$invalidate(21, selectionOnDrag = $$props2.selectionOnDrag);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    wrapHandler,
    toggleSelected,
    createEventDispatcher,
    SelectionMode,
    getEventPosition,
    getNodesInside,
    useStore,
    getConnectedEdges,
    panOnDrag,
    selectionOnDrag,
    dispatch: dispatch2,
    nodes,
    edges,
    viewport,
    dragging,
    elementsSelectable,
    selectionRect,
    selectionRectMode,
    selectionKeyPressed,
    selectionMode,
    panActivationKeyPressed,
    unselectNodesAndEdges,
    container,
    containerBounds,
    selectedNodes,
    onClick,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onMouseLeave,
    onContextMenu,
    _panOnDrag,
    isSelecting,
    hasActiveSelection,
    $selectionRectMode,
    $edges,
    $selectionMode,
    $viewport,
    $nodes,
    $selectionRect,
    $elementsSelectable,
    $selectionKeyPressed,
    $panActivationKeyPressed,
    $dragging
  });
  $$self.$inject_state = ($$props2) => {
    if ("panOnDrag" in $$props2)
      $$invalidate(20, panOnDrag = $$props2.panOnDrag);
    if ("selectionOnDrag" in $$props2)
      $$invalidate(21, selectionOnDrag = $$props2.selectionOnDrag);
    if ("container" in $$props2)
      $$invalidate(1, container = $$props2.container);
    if ("containerBounds" in $$props2)
      containerBounds = $$props2.containerBounds;
    if ("selectedNodes" in $$props2)
      selectedNodes = $$props2.selectedNodes;
    if ("_panOnDrag" in $$props2)
      $$invalidate(22, _panOnDrag = $$props2._panOnDrag);
    if ("isSelecting" in $$props2)
      $$invalidate(0, isSelecting = $$props2.isSelecting);
    if ("hasActiveSelection" in $$props2)
      $$invalidate(2, hasActiveSelection = $$props2.hasActiveSelection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$panActivationKeyPressed, panOnDrag*/
    68157440) {
      $:
        $$invalidate(22, _panOnDrag = $panActivationKeyPressed || panOnDrag);
    }
    if ($$self.$$.dirty[0] & /*$selectionKeyPressed, selectionOnDrag, _panOnDrag*/
    39845888) {
      $:
        $$invalidate(0, isSelecting = $selectionKeyPressed || selectionOnDrag && _panOnDrag !== true);
    }
    if ($$self.$$.dirty[0] & /*$elementsSelectable, isSelecting, $selectionRectMode*/
    25165825) {
      $:
        $$invalidate(2, hasActiveSelection = $elementsSelectable && (isSelecting || $selectionRectMode === "user"));
    }
  };
  return [
    isSelecting,
    container,
    hasActiveSelection,
    $dragging,
    nodes,
    edges,
    viewport,
    dragging,
    elementsSelectable,
    selectionRect,
    selectionRectMode,
    selectionKeyPressed,
    selectionMode,
    panActivationKeyPressed,
    onClick,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onMouseLeave,
    onContextMenu,
    panOnDrag,
    selectionOnDrag,
    _panOnDrag,
    $selectionRectMode,
    $elementsSelectable,
    $selectionKeyPressed,
    $panActivationKeyPressed,
    $$scope,
    slots,
    div_binding
  ];
}
var Pane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { panOnDrag: 20, selectionOnDrag: 21 }, add_css2, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane",
      options,
      id: create_fragment13.name
    });
  }
  get panOnDrag() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionOnDrag() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionOnDrag(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pane_default = Pane;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte
var file6 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1floaup", ".svelte-flow__viewport.svelte-1floaup{width:100%;height:100%;position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlld3BvcnQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWNFLHFDQUF1QixDQUNyQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FDUiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiVmlld3BvcnQuc3ZlbHRlIl19 */");
}
function create_fragment14(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "svelte-flow__viewport xyflow__viewport svelte-1floaup");
      set_style(div, "transform", "translate(" + /*$viewport*/
      ctx[0].x + "px, " + /*$viewport*/
      ctx[0].y + "px) scale(" + /*$viewport*/
      ctx[0].zoom + ")");
      add_location(div, file6, 6, 0, 102);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$viewport*/
      1) {
        set_style(div, "transform", "translate(" + /*$viewport*/
        ctx2[0].x + "px, " + /*$viewport*/
        ctx2[0].y + "px) scale(" + /*$viewport*/
        ctx2[0].zoom + ")");
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $viewport;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Viewport", slots, ["default"]);
  const { viewport } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(0, $viewport = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Viewport> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ useStore, viewport, $viewport });
  return [$viewport, viewport, $$scope, slots];
}
var Viewport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Viewport",
      options,
      id: create_fragment14.name
    });
  }
};
var Viewport_default = Viewport;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/actions/drag/index.js
function drag(domNode, params) {
  const { store, onDrag, onDragStart, onDragStop, onNodeMouseDown } = params;
  const dragInstance = XYDrag({
    domNode,
    onDrag,
    onDragStart,
    onDragStop,
    onNodeMouseDown,
    getStoreItems: () => {
      const snapGrid = get_store_value(store.snapGrid);
      const vp = get_store_value(store.viewport);
      return {
        nodes: get_store_value(store.nodes),
        nodeLookup: get_store_value(store.nodeLookup),
        edges: get_store_value(store.edges),
        nodeExtent: get_store_value(store.nodeExtent),
        snapGrid: snapGrid ? snapGrid : [0, 0],
        snapToGrid: !!snapGrid,
        nodeOrigin: [0, 0],
        multiSelectionActive: get_store_value(store.multiselectionKeyPressed),
        domNode: get_store_value(store.domNode),
        transform: [vp.x, vp.y, vp.zoom],
        autoPanOnNodeDrag: get_store_value(store.autoPanOnNodeDrag),
        nodesDraggable: get_store_value(store.nodesDraggable),
        selectNodesOnDrag: get_store_value(store.selectNodesOnDrag),
        nodeDragThreshold: get_store_value(store.nodeDragThreshold),
        unselectNodesAndEdges: store.unselectNodesAndEdges,
        updateNodePositions: store.updateNodePositions,
        panBy: store.panBy
      };
    }
  });
  function updateDrag(domNode2, params2) {
    if (params2.disabled) {
      dragInstance.destroy();
      return;
    }
    dragInstance.update({
      domNode: domNode2,
      noDragClassName: params2.noDragClass,
      handleSelector: params2.handleSelector,
      nodeId: params2.nodeId,
      isSelectable: params2.isSelectable
    });
  }
  updateDrag(domNode, params);
  return {
    update(params2) {
      updateDrag(domNode, params2);
    },
    destroy() {
      dragInstance.destroy();
    }
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte
var { console: console_1 } = globals;
var file7 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte";
function create_if_block2(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let div_style_value;
  let drag_action;
  let style_transform = `translate(${/*positionOriginX*/
  ctx[14]}px, ${/*positionOriginY*/
  ctx[15]}px)`;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*nodeComponent*/
    ctx[29]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        data: (
          /*data*/
          ctx2[2]
        ),
        id: (
          /*id*/
          ctx2[1]
        ),
        selected: (
          /*selected*/
          ctx2[3]
        ),
        sourcePosition: (
          /*sourcePosition*/
          ctx2[16]
        ),
        targetPosition: (
          /*targetPosition*/
          ctx2[17]
        ),
        type: (
          /*type*/
          ctx2[10]
        ),
        zIndex: (
          /*zIndex*/
          ctx2[18]
        ),
        dragging: (
          /*dragging*/
          ctx2[8]
        ),
        dragHandle: (
          /*dragHandle*/
          ctx2[21]
        ),
        isConnectable: (
          /*connectable*/
          ctx2[6]
        ),
        positionAbsolute: {
          x: (
            /*positionX*/
            ctx2[12]
          ),
          y: (
            /*positionY*/
            ctx2[13]
          )
        },
        width: (
          /*width*/
          ctx2[19]
        ),
        height: (
          /*height*/
          ctx2[20]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "connectstart",
      /*connectstart_handler*/
      ctx[37]
    );
    switch_instance.$on(
      "connect",
      /*connect_handler*/
      ctx[38]
    );
    switch_instance.$on(
      "connectend",
      /*connectend_handler*/
      ctx[39]
    );
  }
  const block = {
    c: function create2() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr_dev(
        div,
        "data-id",
        /*id*/
        ctx[1]
      );
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__node",
        `svelte-flow__node-${/*nodeType*/
        ctx[28]}`,
        /*className*/
        ctx[23]
      ]));
      attr_dev(div, "style", div_style_value = /*style*/
      (ctx[9] ?? "") + "; " + (!/*width*/
      ctx[19] ? "" : `width:${/*width*/
      ctx[19]}px;`) + " " + (!/*height*/
      ctx[20] ? "" : `height:${/*height*/
      ctx[20]}px;`));
      toggle_class(
        div,
        "dragging",
        /*dragging*/
        ctx[8]
      );
      toggle_class(
        div,
        "selected",
        /*selected*/
        ctx[3]
      );
      toggle_class(
        div,
        "draggable",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        div,
        "connectable",
        /*connectable*/
        ctx[6]
      );
      toggle_class(
        div,
        "selectable",
        /*selectable*/
        ctx[5]
      );
      toggle_class(
        div,
        "nopan",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        div,
        "parent",
        /*isParent*/
        ctx[11]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[18]
      );
      set_style(div, "transform", style_transform);
      set_style(
        div,
        "visibility",
        /*initialized*/
        ctx[22] ? "visible" : "hidden"
      );
      add_location(div, file7, 140, 2, 2927);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      ctx[43](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = drag.call(null, div, {
            nodeId: (
              /*id*/
              ctx[1]
            ),
            isSelectable: (
              /*selectable*/
              ctx[5]
            ),
            disabled: false,
            handleSelector: (
              /*dragHandle*/
              ctx[21]
            ),
            noDragClass: "nodrag",
            onNodeMouseDown: (
              /*handleNodeSelection*/
              ctx[27]
            ),
            onDrag: (
              /*drag_function*/
              ctx[40]
            ),
            onDragStart: (
              /*drag_function_1*/
              ctx[41]
            ),
            onDragStop: (
              /*drag_function_2*/
              ctx[42]
            ),
            store: (
              /*store*/
              ctx[25]
            )
          })),
          listen_dev(
            div,
            "click",
            /*onSelectNodeHandler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousemove",
            /*mousemove_handler*/
            ctx[46],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[47],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = /*nodeComponent*/
      ctx2[29])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          switch_instance.$on(
            "connectstart",
            /*connectstart_handler*/
            ctx2[37]
          );
          switch_instance.$on(
            "connect",
            /*connect_handler*/
            ctx2[38]
          );
          switch_instance.$on(
            "connectend",
            /*connectend_handler*/
            ctx2[39]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*data*/
        4)
          switch_instance_changes.data = /*data*/
          ctx2[2];
        if (dirty[0] & /*id*/
        2)
          switch_instance_changes.id = /*id*/
          ctx2[1];
        if (dirty[0] & /*selected*/
        8)
          switch_instance_changes.selected = /*selected*/
          ctx2[3];
        if (dirty[0] & /*sourcePosition*/
        65536)
          switch_instance_changes.sourcePosition = /*sourcePosition*/
          ctx2[16];
        if (dirty[0] & /*targetPosition*/
        131072)
          switch_instance_changes.targetPosition = /*targetPosition*/
          ctx2[17];
        if (dirty[0] & /*type*/
        1024)
          switch_instance_changes.type = /*type*/
          ctx2[10];
        if (dirty[0] & /*zIndex*/
        262144)
          switch_instance_changes.zIndex = /*zIndex*/
          ctx2[18];
        if (dirty[0] & /*dragging*/
        256)
          switch_instance_changes.dragging = /*dragging*/
          ctx2[8];
        if (dirty[0] & /*dragHandle*/
        2097152)
          switch_instance_changes.dragHandle = /*dragHandle*/
          ctx2[21];
        if (dirty[0] & /*connectable*/
        64)
          switch_instance_changes.isConnectable = /*connectable*/
          ctx2[6];
        if (dirty[0] & /*positionX, positionY*/
        12288)
          switch_instance_changes.positionAbsolute = {
            x: (
              /*positionX*/
              ctx2[12]
            ),
            y: (
              /*positionY*/
              ctx2[13]
            )
          };
        if (dirty[0] & /*width*/
        524288)
          switch_instance_changes.width = /*width*/
          ctx2[19];
        if (dirty[0] & /*height*/
        1048576)
          switch_instance_changes.height = /*height*/
          ctx2[20];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*id*/
      2) {
        attr_dev(
          div,
          "data-id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*className*/
      8388608 && div_class_value !== (div_class_value = cc([
        "svelte-flow__node",
        `svelte-flow__node-${/*nodeType*/
        ctx2[28]}`,
        /*className*/
        ctx2[23]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style, width, height*/
      1573376 && div_style_value !== (div_style_value = /*style*/
      (ctx2[9] ?? "") + "; " + (!/*width*/
      ctx2[19] ? "" : `width:${/*width*/
      ctx2[19]}px;`) + " " + (!/*height*/
      ctx2[20] ? "" : `height:${/*height*/
      ctx2[20]}px;`))) {
        attr_dev(div, "style", div_style_value);
      }
      if (drag_action && is_function(drag_action.update) && dirty[0] & /*id, selectable, dragHandle*/
      2097186)
        drag_action.update.call(null, {
          nodeId: (
            /*id*/
            ctx2[1]
          ),
          isSelectable: (
            /*selectable*/
            ctx2[5]
          ),
          disabled: false,
          handleSelector: (
            /*dragHandle*/
            ctx2[21]
          ),
          noDragClass: "nodrag",
          onNodeMouseDown: (
            /*handleNodeSelection*/
            ctx2[27]
          ),
          onDrag: (
            /*drag_function*/
            ctx2[40]
          ),
          onDragStart: (
            /*drag_function_1*/
            ctx2[41]
          ),
          onDragStop: (
            /*drag_function_2*/
            ctx2[42]
          ),
          store: (
            /*store*/
            ctx2[25]
          )
        });
      if (!current || dirty[0] & /*className, dragging*/
      8388864) {
        toggle_class(
          div,
          "dragging",
          /*dragging*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*className, selected*/
      8388616) {
        toggle_class(
          div,
          "selected",
          /*selected*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*className, draggable*/
      8388624) {
        toggle_class(
          div,
          "draggable",
          /*draggable*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*className, connectable*/
      8388672) {
        toggle_class(
          div,
          "connectable",
          /*connectable*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*className, selectable*/
      8388640) {
        toggle_class(
          div,
          "selectable",
          /*selectable*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className, draggable*/
      8388624) {
        toggle_class(
          div,
          "nopan",
          /*draggable*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*className, isParent*/
      8390656) {
        toggle_class(
          div,
          "parent",
          /*isParent*/
          ctx2[11]
        );
      }
      const style_changed = dirty[0] & /*style, width, height*/
      1573376;
      if (dirty[0] & /*zIndex, style, width, height*/
      1835520 || style_changed) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*positionOriginX, positionOriginY, style, width, height*/
      1622528 && style_transform !== (style_transform = `translate(${/*positionOriginX*/
      ctx2[14]}px, ${/*positionOriginY*/
      ctx2[15]}px)`) || style_changed) {
        set_style(div, "transform", style_transform);
      }
      if (dirty[0] & /*initialized, style, width, height*/
      5767680 || style_changed) {
        set_style(
          div,
          "visibility",
          /*initialized*/
          ctx2[22] ? "visible" : "hidden"
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[43](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(102:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[7] && create_if_block2(ctx);
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*hidden*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hidden*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let $nodeTypes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeWrapper", slots, []);
  let { node } = $$props;
  let { id: id2 } = $$props;
  let { data = {} } = $$props;
  let { selected = false } = $$props;
  let { draggable = void 0 } = $$props;
  let { selectable = void 0 } = $$props;
  let { connectable = true } = $$props;
  let { hidden = false } = $$props;
  let { dragging = false } = $$props;
  let { resizeObserver = null } = $$props;
  let { style = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { isParent = false } = $$props;
  let { positionX } = $$props;
  let { positionY } = $$props;
  let { positionOriginX } = $$props;
  let { positionOriginY } = $$props;
  let { sourcePosition = void 0 } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { zIndex } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { initialized = false } = $$props;
  let { class: className = "" } = $$props;
  const store = useStore();
  const { nodeTypes, nodeDragThreshold, selectNodesOnDrag, handleNodeSelection, updateNodeDimensions: updateNodeDimensions2 } = store;
  validate_store(nodeTypes, "nodeTypes");
  component_subscribe($$self, nodeTypes, (value) => $$invalidate(48, $nodeTypes = value));
  const nodeType = type || "default";
  let nodeRef;
  let prevNodeRef;
  const nodeTypeValid = !!$nodeTypes[nodeType];
  if (!nodeTypeValid) {
    console.warn("003", errorMessages["error003"](type));
  }
  const nodeComponent = $nodeTypes[nodeType] || DefaultNode_default;
  const dispatch2 = createEventDispatcher();
  const connectableStore = writable(connectable);
  let prevType = void 0;
  let prevSourcePosition = void 0;
  let prevTargetPosition = void 0;
  setContext("svelteflow__node_id", id2);
  setContext("svelteflow__node_connectable", connectableStore);
  function onSelectNodeHandler(event) {
    if (selectable && (!get_store_value(selectNodesOnDrag) || !draggable || get_store_value(nodeDragThreshold) > 0)) {
      handleNodeSelection(id2);
    }
    dispatch2("nodeclick", { node, event });
  }
  $$self.$$.on_mount.push(function() {
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'node'");
    }
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'id'");
    }
    if (positionX === void 0 && !("positionX" in $$props || $$self.$$.bound[$$self.$$.props["positionX"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionX'");
    }
    if (positionY === void 0 && !("positionY" in $$props || $$self.$$.bound[$$self.$$.props["positionY"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionY'");
    }
    if (positionOriginX === void 0 && !("positionOriginX" in $$props || $$self.$$.bound[$$self.$$.props["positionOriginX"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionOriginX'");
    }
    if (positionOriginY === void 0 && !("positionOriginY" in $$props || $$self.$$.bound[$$self.$$.props["positionOriginY"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionOriginY'");
    }
    if (zIndex === void 0 && !("zIndex" in $$props || $$self.$$.bound[$$self.$$.props["zIndex"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'zIndex'");
    }
  });
  const writable_props = [
    "node",
    "id",
    "data",
    "selected",
    "draggable",
    "selectable",
    "connectable",
    "hidden",
    "dragging",
    "resizeObserver",
    "style",
    "type",
    "isParent",
    "positionX",
    "positionY",
    "positionOriginX",
    "positionOriginY",
    "sourcePosition",
    "targetPosition",
    "zIndex",
    "width",
    "height",
    "dragHandle",
    "initialized",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_1.warn(`<NodeWrapper> was created with unknown prop '${key2}'`);
  });
  function connectstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler(event) {
    bubble.call(this, $$self, event);
  }
  const drag_function = (event, _, node2, nodes) => {
    dispatch2("nodedrag", { event, node: node2, nodes });
  };
  const drag_function_1 = (event, _, node2, nodes) => {
    dispatch2("nodedragstart", { event, node: node2, nodes });
  };
  const drag_function_2 = (event, _, node2, nodes) => {
    dispatch2("nodedragstop", { event, node: node2, nodes });
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nodeRef = $$value;
      $$invalidate(24, nodeRef);
    });
  }
  const mouseenter_handler = (event) => dispatch2("nodemouseenter", { node, event });
  const mouseleave_handler = (event) => dispatch2("nodemouseleave", { node, event });
  const mousemove_handler = (event) => dispatch2("nodemousemove", { node, event });
  const contextmenu_handler = (event) => dispatch2("nodecontextmenu", { node, event });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("id" in $$props2)
      $$invalidate(1, id2 = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(2, data = $$props2.data);
    if ("selected" in $$props2)
      $$invalidate(3, selected = $$props2.selected);
    if ("draggable" in $$props2)
      $$invalidate(4, draggable = $$props2.draggable);
    if ("selectable" in $$props2)
      $$invalidate(5, selectable = $$props2.selectable);
    if ("connectable" in $$props2)
      $$invalidate(6, connectable = $$props2.connectable);
    if ("hidden" in $$props2)
      $$invalidate(7, hidden = $$props2.hidden);
    if ("dragging" in $$props2)
      $$invalidate(8, dragging = $$props2.dragging);
    if ("resizeObserver" in $$props2)
      $$invalidate(32, resizeObserver = $$props2.resizeObserver);
    if ("style" in $$props2)
      $$invalidate(9, style = $$props2.style);
    if ("type" in $$props2)
      $$invalidate(10, type = $$props2.type);
    if ("isParent" in $$props2)
      $$invalidate(11, isParent = $$props2.isParent);
    if ("positionX" in $$props2)
      $$invalidate(12, positionX = $$props2.positionX);
    if ("positionY" in $$props2)
      $$invalidate(13, positionY = $$props2.positionY);
    if ("positionOriginX" in $$props2)
      $$invalidate(14, positionOriginX = $$props2.positionOriginX);
    if ("positionOriginY" in $$props2)
      $$invalidate(15, positionOriginY = $$props2.positionOriginY);
    if ("sourcePosition" in $$props2)
      $$invalidate(16, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2)
      $$invalidate(17, targetPosition = $$props2.targetPosition);
    if ("zIndex" in $$props2)
      $$invalidate(18, zIndex = $$props2.zIndex);
    if ("width" in $$props2)
      $$invalidate(19, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(20, height = $$props2.height);
    if ("dragHandle" in $$props2)
      $$invalidate(21, dragHandle = $$props2.dragHandle);
    if ("initialized" in $$props2)
      $$invalidate(22, initialized = $$props2.initialized);
    if ("class" in $$props2)
      $$invalidate(23, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    SvelteComponent: SvelteComponentDev,
    get: get_store_value,
    writable,
    cc,
    errorMessages,
    Position,
    drag,
    useStore,
    DefaultNode: DefaultNode_default,
    node,
    id: id2,
    data,
    selected,
    draggable,
    selectable,
    connectable,
    hidden,
    dragging,
    resizeObserver,
    style,
    type,
    isParent,
    positionX,
    positionY,
    positionOriginX,
    positionOriginY,
    sourcePosition,
    targetPosition,
    zIndex,
    width,
    height,
    dragHandle,
    initialized,
    className,
    store,
    nodeTypes,
    nodeDragThreshold,
    selectNodesOnDrag,
    handleNodeSelection,
    updateNodeDimensions: updateNodeDimensions2,
    nodeType,
    nodeRef,
    prevNodeRef,
    nodeTypeValid,
    nodeComponent,
    dispatch: dispatch2,
    connectableStore,
    prevType,
    prevSourcePosition,
    prevTargetPosition,
    onSelectNodeHandler,
    $nodeTypes
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("id" in $$props2)
      $$invalidate(1, id2 = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(2, data = $$props2.data);
    if ("selected" in $$props2)
      $$invalidate(3, selected = $$props2.selected);
    if ("draggable" in $$props2)
      $$invalidate(4, draggable = $$props2.draggable);
    if ("selectable" in $$props2)
      $$invalidate(5, selectable = $$props2.selectable);
    if ("connectable" in $$props2)
      $$invalidate(6, connectable = $$props2.connectable);
    if ("hidden" in $$props2)
      $$invalidate(7, hidden = $$props2.hidden);
    if ("dragging" in $$props2)
      $$invalidate(8, dragging = $$props2.dragging);
    if ("resizeObserver" in $$props2)
      $$invalidate(32, resizeObserver = $$props2.resizeObserver);
    if ("style" in $$props2)
      $$invalidate(9, style = $$props2.style);
    if ("type" in $$props2)
      $$invalidate(10, type = $$props2.type);
    if ("isParent" in $$props2)
      $$invalidate(11, isParent = $$props2.isParent);
    if ("positionX" in $$props2)
      $$invalidate(12, positionX = $$props2.positionX);
    if ("positionY" in $$props2)
      $$invalidate(13, positionY = $$props2.positionY);
    if ("positionOriginX" in $$props2)
      $$invalidate(14, positionOriginX = $$props2.positionOriginX);
    if ("positionOriginY" in $$props2)
      $$invalidate(15, positionOriginY = $$props2.positionOriginY);
    if ("sourcePosition" in $$props2)
      $$invalidate(16, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2)
      $$invalidate(17, targetPosition = $$props2.targetPosition);
    if ("zIndex" in $$props2)
      $$invalidate(18, zIndex = $$props2.zIndex);
    if ("width" in $$props2)
      $$invalidate(19, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(20, height = $$props2.height);
    if ("dragHandle" in $$props2)
      $$invalidate(21, dragHandle = $$props2.dragHandle);
    if ("initialized" in $$props2)
      $$invalidate(22, initialized = $$props2.initialized);
    if ("className" in $$props2)
      $$invalidate(23, className = $$props2.className);
    if ("nodeRef" in $$props2)
      $$invalidate(24, nodeRef = $$props2.nodeRef);
    if ("prevNodeRef" in $$props2)
      $$invalidate(33, prevNodeRef = $$props2.prevNodeRef);
    if ("prevType" in $$props2)
      $$invalidate(34, prevType = $$props2.prevType);
    if ("prevSourcePosition" in $$props2)
      $$invalidate(35, prevSourcePosition = $$props2.prevSourcePosition);
    if ("prevTargetPosition" in $$props2)
      $$invalidate(36, prevTargetPosition = $$props2.prevTargetPosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*connectable*/
    64) {
      $: {
        connectableStore.set(!!connectable);
      }
    }
    if ($$self.$$.dirty[0] & /*sourcePosition, targetPosition, id, nodeRef*/
    16973826 | $$self.$$.dirty[1] & /*prevType, prevSourcePosition, prevTargetPosition*/
    56) {
      $: {
        const doUpdate = prevType && nodeType !== prevType || prevSourcePosition && sourcePosition !== prevSourcePosition || prevTargetPosition && targetPosition !== prevTargetPosition;
        if (doUpdate) {
          requestAnimationFrame(() => updateNodeDimensions2(/* @__PURE__ */ new Map([
            [
              id2,
              {
                id: id2,
                nodeElement: nodeRef,
                forceUpdate: true
              }
            ]
          ])));
        }
        $$invalidate(34, prevType = nodeType);
        $$invalidate(35, prevSourcePosition = sourcePosition);
        $$invalidate(36, prevTargetPosition = targetPosition);
      }
    }
    if ($$self.$$.dirty[0] & /*nodeRef*/
    16777216 | $$self.$$.dirty[1] & /*resizeObserver, prevNodeRef*/
    6) {
      $: {
        if (nodeRef) {
          resizeObserver == null ? void 0 : resizeObserver.observe(nodeRef);
          $$invalidate(33, prevNodeRef = nodeRef);
        } else if (prevNodeRef) {
          resizeObserver == null ? void 0 : resizeObserver.unobserve(prevNodeRef);
        }
      }
    }
  };
  return [
    node,
    id2,
    data,
    selected,
    draggable,
    selectable,
    connectable,
    hidden,
    dragging,
    style,
    type,
    isParent,
    positionX,
    positionY,
    positionOriginX,
    positionOriginY,
    sourcePosition,
    targetPosition,
    zIndex,
    width,
    height,
    dragHandle,
    initialized,
    className,
    nodeRef,
    store,
    nodeTypes,
    handleNodeSelection,
    nodeType,
    nodeComponent,
    dispatch2,
    onSelectNodeHandler,
    resizeObserver,
    prevNodeRef,
    prevType,
    prevSourcePosition,
    prevTargetPosition,
    connectstart_handler,
    connect_handler,
    connectend_handler,
    drag_function,
    drag_function_1,
    drag_function_2,
    div_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousemove_handler,
    contextmenu_handler
  ];
}
var NodeWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      not_equal,
      {
        node: 0,
        id: 1,
        data: 2,
        selected: 3,
        draggable: 4,
        selectable: 5,
        connectable: 6,
        hidden: 7,
        dragging: 8,
        resizeObserver: 32,
        style: 9,
        type: 10,
        isParent: 11,
        positionX: 12,
        positionY: 13,
        positionOriginX: 14,
        positionOriginY: 15,
        sourcePosition: 16,
        targetPosition: 17,
        zIndex: 18,
        width: 19,
        height: 20,
        dragHandle: 21,
        initialized: 22,
        class: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeWrapper",
      options,
      id: create_fragment15.name
    });
  }
  get node() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get draggable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draggable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizeObserver() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizeObserver(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isParent() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isParent(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionX() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionX(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionY() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionY(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionOriginX() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionOriginX(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionOriginY() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionOriginY(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialized() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialized(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeWrapper_default = NodeWrapper;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte
var { Map: Map_1 } = globals;
var file8 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte";
function add_css4(target) {
  append_styles(target, "svelte-tf4uy4", ".svelte-flow__nodes.svelte-tf4uy4{width:100%;height:100%;position:absolute;left:0;top:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVJlbmRlcmVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpR0UsaUNBQW9CLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsQ0FBQyxDQUNQLEdBQUcsQ0FBRSxDQUNQIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJOb2RlUmVuZGVyZXIuc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  var _a, _b, _c, _d, _e, _f;
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  const constants_0 = getPositionWithOrigin({
    x: (
      /*node*/
      ((_b = (_a = child_ctx[21].computed) == null ? void 0 : _a.positionAbsolute) == null ? void 0 : _b.x) ?? 0
    ),
    y: (
      /*node*/
      ((_d = (_c = child_ctx[21].computed) == null ? void 0 : _c.positionAbsolute) == null ? void 0 : _d.y) ?? 0
    ),
    width: (
      /*node*/
      ((_e = child_ctx[21].computed) == null ? void 0 : _e.width) ?? /*node*/
      child_ctx[21].width ?? 0
    ),
    height: (
      /*node*/
      ((_f = child_ctx[21].computed) == null ? void 0 : _f.height) ?? /*node*/
      child_ctx[21].height ?? 0
    ),
    origin: (
      /*node*/
      child_ctx[21].origin
    )
  });
  child_ctx[22] = constants_0;
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let first;
  let nodewrapper;
  let current;
  nodewrapper = new NodeWrapper_default({
    props: {
      node: (
        /*node*/
        ctx[21]
      ),
      id: (
        /*node*/
        ctx[21].id
      ),
      data: (
        /*node*/
        ctx[21].data
      ),
      selected: !!/*node*/
      ctx[21].selected,
      hidden: !!/*node*/
      ctx[21].hidden,
      draggable: !!/*node*/
      (ctx[21].draggable || /*$nodesDraggable*/
      ctx[1] && typeof /*node*/
      ctx[21].draggable === "undefined"),
      selectable: !!/*node*/
      (ctx[21].selectable || /*$elementsSelectable*/
      ctx[2] && typeof /*node*/
      ctx[21].selectable === "undefined"),
      connectable: !!/*node*/
      (ctx[21].connectable || /*$nodesConnectable*/
      ctx[3] && typeof /*node*/
      ctx[21].connectable === "undefined"),
      positionX: (
        /*node*/
        ((_b = (_a = ctx[21].computed) == null ? void 0 : _a.positionAbsolute) == null ? void 0 : _b.x) ?? 0
      ),
      positionY: (
        /*node*/
        ((_d = (_c = ctx[21].computed) == null ? void 0 : _c.positionAbsolute) == null ? void 0 : _d.y) ?? 0
      ),
      positionOriginX: (
        /*posOrigin*/
        ctx[22].x ?? 0
      ),
      positionOriginY: (
        /*posOrigin*/
        ctx[22].y ?? 0
      ),
      isParent: !!/*node*/
      ((_e = ctx[21][internalsSymbol]) == null ? void 0 : _e.isParent),
      style: (
        /*node*/
        ctx[21].style
      ),
      class: (
        /*node*/
        ctx[21].class
      ),
      type: (
        /*node*/
        ctx[21].type ?? "default"
      ),
      sourcePosition: (
        /*node*/
        ctx[21].sourcePosition
      ),
      targetPosition: (
        /*node*/
        ctx[21].targetPosition
      ),
      dragging: (
        /*node*/
        ctx[21].dragging
      ),
      zIndex: (
        /*node*/
        ((_f = ctx[21][internalsSymbol]) == null ? void 0 : _f.z) ?? 0
      ),
      dragHandle: (
        /*node*/
        ctx[21].dragHandle
      ),
      width: (
        /*node*/
        ctx[21].width ?? void 0
      ),
      height: (
        /*node*/
        ctx[21].height ?? void 0
      ),
      initialized: !!/*node*/
      ((_g = ctx[21].computed) == null ? void 0 : _g.width) && !!/*node*/
      ((_h = ctx[21].computed) == null ? void 0 : _h.height) || !!/*node*/
      ctx[21].width && !!/*node*/
      ctx[21].height,
      resizeObserver: (
        /*resizeObserver*/
        ctx[8]
      )
    },
    $$inline: true
  });
  nodewrapper.$on(
    "nodeclick",
    /*nodeclick_handler*/
    ctx[9]
  );
  nodewrapper.$on(
    "nodemouseenter",
    /*nodemouseenter_handler*/
    ctx[10]
  );
  nodewrapper.$on(
    "nodemousemove",
    /*nodemousemove_handler*/
    ctx[11]
  );
  nodewrapper.$on(
    "nodemouseleave",
    /*nodemouseleave_handler*/
    ctx[12]
  );
  nodewrapper.$on(
    "connectstart",
    /*connectstart_handler*/
    ctx[13]
  );
  nodewrapper.$on(
    "connect",
    /*connect_handler*/
    ctx[14]
  );
  nodewrapper.$on(
    "connectend",
    /*connectend_handler*/
    ctx[15]
  );
  nodewrapper.$on(
    "nodedrag",
    /*nodedrag_handler*/
    ctx[16]
  );
  nodewrapper.$on(
    "nodedragstart",
    /*nodedragstart_handler*/
    ctx[17]
  );
  nodewrapper.$on(
    "nodedragstop",
    /*nodedragstop_handler*/
    ctx[18]
  );
  nodewrapper.$on(
    "nodecontextmenu",
    /*nodecontextmenu_handler*/
    ctx[19]
  );
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(nodewrapper.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(nodewrapper, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      ctx = new_ctx;
      const nodewrapper_changes = {};
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.node = /*node*/
        ctx[21];
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.id = /*node*/
        ctx[21].id;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.data = /*node*/
        ctx[21].data;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.selected = !!/*node*/
        ctx[21].selected;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.hidden = !!/*node*/
        ctx[21].hidden;
      if (dirty & /*$visibleNodes, $nodesDraggable*/
      3)
        nodewrapper_changes.draggable = !!/*node*/
        (ctx[21].draggable || /*$nodesDraggable*/
        ctx[1] && typeof /*node*/
        ctx[21].draggable === "undefined");
      if (dirty & /*$visibleNodes, $elementsSelectable*/
      5)
        nodewrapper_changes.selectable = !!/*node*/
        (ctx[21].selectable || /*$elementsSelectable*/
        ctx[2] && typeof /*node*/
        ctx[21].selectable === "undefined");
      if (dirty & /*$visibleNodes, $nodesConnectable*/
      9)
        nodewrapper_changes.connectable = !!/*node*/
        (ctx[21].connectable || /*$nodesConnectable*/
        ctx[3] && typeof /*node*/
        ctx[21].connectable === "undefined");
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.positionX = /*node*/
        ((_b2 = (_a2 = ctx[21].computed) == null ? void 0 : _a2.positionAbsolute) == null ? void 0 : _b2.x) ?? 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.positionY = /*node*/
        ((_d2 = (_c2 = ctx[21].computed) == null ? void 0 : _c2.positionAbsolute) == null ? void 0 : _d2.y) ?? 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.positionOriginX = /*posOrigin*/
        ctx[22].x ?? 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.positionOriginY = /*posOrigin*/
        ctx[22].y ?? 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.isParent = !!/*node*/
        ((_e2 = ctx[21][internalsSymbol]) == null ? void 0 : _e2.isParent);
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.style = /*node*/
        ctx[21].style;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.class = /*node*/
        ctx[21].class;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.type = /*node*/
        ctx[21].type ?? "default";
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.sourcePosition = /*node*/
        ctx[21].sourcePosition;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.targetPosition = /*node*/
        ctx[21].targetPosition;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.dragging = /*node*/
        ctx[21].dragging;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.zIndex = /*node*/
        ((_f2 = ctx[21][internalsSymbol]) == null ? void 0 : _f2.z) ?? 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.dragHandle = /*node*/
        ctx[21].dragHandle;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.width = /*node*/
        ctx[21].width ?? void 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.height = /*node*/
        ctx[21].height ?? void 0;
      if (dirty & /*$visibleNodes*/
      1)
        nodewrapper_changes.initialized = !!/*node*/
        ((_g2 = ctx[21].computed) == null ? void 0 : _g2.width) && !!/*node*/
        ((_h2 = ctx[21].computed) == null ? void 0 : _h2.height) || !!/*node*/
        ctx[21].width && !!/*node*/
        ctx[21].height;
      nodewrapper.$set(nodewrapper_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(nodewrapper.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(nodewrapper.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(nodewrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(30:2) {#each $visibleNodes as node (node.id)}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let current;
  let each_value = ensure_array_like_dev(
    /*$visibleNodes*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[21].id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-flow__nodes svelte-tf4uy4");
      add_location(div, file8, 39, 0, 788);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$visibleNodes, $nodesDraggable, $elementsSelectable, $nodesConnectable, undefined, resizeObserver*/
      271) {
        each_value = ensure_array_like_dev(
          /*$visibleNodes*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let $visibleNodes;
  let $nodesDraggable;
  let $elementsSelectable;
  let $nodesConnectable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeRenderer", slots, []);
  const { visibleNodes, nodesDraggable, nodesConnectable, elementsSelectable, updateNodeDimensions: updateNodeDimensions2 } = useStore();
  validate_store(visibleNodes, "visibleNodes");
  component_subscribe($$self, visibleNodes, (value) => $$invalidate(0, $visibleNodes = value));
  validate_store(nodesDraggable, "nodesDraggable");
  component_subscribe($$self, nodesDraggable, (value) => $$invalidate(1, $nodesDraggable = value));
  validate_store(nodesConnectable, "nodesConnectable");
  component_subscribe($$self, nodesConnectable, (value) => $$invalidate(3, $nodesConnectable = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(2, $elementsSelectable = value));
  const resizeObserver = typeof ResizeObserver === "undefined" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, {
        id: id2,
        nodeElement: entry.target,
        forceUpdate: true
      });
    });
    updateNodeDimensions2(updates);
  });
  onDestroy(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
  });
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<NodeRenderer> was created with unknown prop '${key2}'`);
  });
  function nodeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$capture_state = () => ({
    onDestroy,
    internalsSymbol,
    getPositionWithOrigin,
    NodeWrapper: NodeWrapper_default,
    useStore,
    visibleNodes,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    updateNodeDimensions: updateNodeDimensions2,
    resizeObserver,
    $visibleNodes,
    $nodesDraggable,
    $elementsSelectable,
    $nodesConnectable
  });
  return [
    $visibleNodes,
    $nodesDraggable,
    $elementsSelectable,
    $nodesConnectable,
    visibleNodes,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    resizeObserver,
    nodeclick_handler,
    nodemouseenter_handler,
    nodemousemove_handler,
    nodemouseleave_handler,
    connectstart_handler,
    connect_handler,
    connectend_handler,
    nodedrag_handler,
    nodedragstart_handler,
    nodedragstop_handler,
    nodecontextmenu_handler
  ];
}
var NodeRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {}, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeRenderer",
      options,
      id: create_fragment16.name
    });
  }
};
var NodeRenderer_default = NodeRenderer;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte
var { console: console_12 } = globals;
var file9 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte";
function create_if_block3(ctx) {
  let g;
  let switch_instance;
  let g_class_value;
  let g_aria_label_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*edgeComponent*/
    ctx[23]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        id: (
          /*id*/
          ctx2[0]
        ),
        source: (
          /*source*/
          ctx2[1]
        ),
        target: (
          /*target*/
          ctx2[2]
        ),
        sourceX: (
          /*sourceX*/
          ctx2[12]
        ),
        sourceY: (
          /*sourceY*/
          ctx2[13]
        ),
        targetX: (
          /*targetX*/
          ctx2[14]
        ),
        targetY: (
          /*targetY*/
          ctx2[15]
        ),
        sourcePosition: (
          /*sourcePosition*/
          ctx2[16]
        ),
        targetPosition: (
          /*targetPosition*/
          ctx2[17]
        ),
        animated: (
          /*animated*/
          ctx2[5]
        ),
        selected: (
          /*selected*/
          ctx2[6]
        ),
        label: (
          /*label*/
          ctx2[8]
        ),
        labelStyle: (
          /*labelStyle*/
          ctx2[9]
        ),
        data: (
          /*data*/
          ctx2[3]
        ),
        style: (
          /*style*/
          ctx2[4]
        ),
        interactionWidth: (
          /*interactionWidth*/
          ctx2[19]
        ),
        sourceHandleId: (
          /*sourceHandle*/
          ctx2[10]
        ),
        targetHandleId: (
          /*targetHandle*/
          ctx2[11]
        ),
        markerStart: (
          /*markerStartUrl*/
          ctx2[22]
        ),
        markerEnd: (
          /*markerEndUrl*/
          ctx2[21]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create2() {
      g = svg_element("g");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr_dev(g, "class", g_class_value = cc([
        "svelte-flow__edge",
        /*className*/
        ctx[20]
      ]));
      attr_dev(
        g,
        "data-id",
        /*id*/
        ctx[0]
      );
      attr_dev(g, "aria-label", g_aria_label_value = /*ariaLabel*/
      ctx[18] === null ? void 0 : (
        /*ariaLabel*/
        ctx[18] ? (
          /*ariaLabel*/
          ctx[18]
        ) : `Edge from ${/*source*/
        ctx[1]} to ${/*target*/
        ctx[2]}`
      ));
      attr_dev(g, "role", "img");
      toggle_class(
        g,
        "animated",
        /*animated*/
        ctx[5]
      );
      toggle_class(
        g,
        "selected",
        /*selected*/
        ctx[6]
      );
      add_location(g, file9, 97, 2, 2229);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      if (switch_instance)
        mount_component(switch_instance, g, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            g,
            "click",
            /*onClick*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "contextmenu",
            /*onContextMenu*/
            ctx[28],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*edgeComponent*/
      8388608 && switch_value !== (switch_value = /*edgeComponent*/
      ctx2[23])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, g, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*id*/
        1)
          switch_instance_changes.id = /*id*/
          ctx2[0];
        if (dirty[0] & /*source*/
        2)
          switch_instance_changes.source = /*source*/
          ctx2[1];
        if (dirty[0] & /*target*/
        4)
          switch_instance_changes.target = /*target*/
          ctx2[2];
        if (dirty[0] & /*sourceX*/
        4096)
          switch_instance_changes.sourceX = /*sourceX*/
          ctx2[12];
        if (dirty[0] & /*sourceY*/
        8192)
          switch_instance_changes.sourceY = /*sourceY*/
          ctx2[13];
        if (dirty[0] & /*targetX*/
        16384)
          switch_instance_changes.targetX = /*targetX*/
          ctx2[14];
        if (dirty[0] & /*targetY*/
        32768)
          switch_instance_changes.targetY = /*targetY*/
          ctx2[15];
        if (dirty[0] & /*sourcePosition*/
        65536)
          switch_instance_changes.sourcePosition = /*sourcePosition*/
          ctx2[16];
        if (dirty[0] & /*targetPosition*/
        131072)
          switch_instance_changes.targetPosition = /*targetPosition*/
          ctx2[17];
        if (dirty[0] & /*animated*/
        32)
          switch_instance_changes.animated = /*animated*/
          ctx2[5];
        if (dirty[0] & /*selected*/
        64)
          switch_instance_changes.selected = /*selected*/
          ctx2[6];
        if (dirty[0] & /*label*/
        256)
          switch_instance_changes.label = /*label*/
          ctx2[8];
        if (dirty[0] & /*labelStyle*/
        512)
          switch_instance_changes.labelStyle = /*labelStyle*/
          ctx2[9];
        if (dirty[0] & /*data*/
        8)
          switch_instance_changes.data = /*data*/
          ctx2[3];
        if (dirty[0] & /*style*/
        16)
          switch_instance_changes.style = /*style*/
          ctx2[4];
        if (dirty[0] & /*interactionWidth*/
        524288)
          switch_instance_changes.interactionWidth = /*interactionWidth*/
          ctx2[19];
        if (dirty[0] & /*sourceHandle*/
        1024)
          switch_instance_changes.sourceHandleId = /*sourceHandle*/
          ctx2[10];
        if (dirty[0] & /*targetHandle*/
        2048)
          switch_instance_changes.targetHandleId = /*targetHandle*/
          ctx2[11];
        if (dirty[0] & /*markerStartUrl*/
        4194304)
          switch_instance_changes.markerStart = /*markerStartUrl*/
          ctx2[22];
        if (dirty[0] & /*markerEndUrl*/
        2097152)
          switch_instance_changes.markerEnd = /*markerEndUrl*/
          ctx2[21];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*className*/
      1048576 && g_class_value !== (g_class_value = cc([
        "svelte-flow__edge",
        /*className*/
        ctx2[20]
      ]))) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          g,
          "data-id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*ariaLabel, source, target*/
      262150 && g_aria_label_value !== (g_aria_label_value = /*ariaLabel*/
      ctx2[18] === null ? void 0 : (
        /*ariaLabel*/
        ctx2[18] ? (
          /*ariaLabel*/
          ctx2[18]
        ) : `Edge from ${/*source*/
        ctx2[1]} to ${/*target*/
        ctx2[2]}`
      ))) {
        attr_dev(g, "aria-label", g_aria_label_value);
      }
      if (!current || dirty[0] & /*className, animated*/
      1048608) {
        toggle_class(
          g,
          "animated",
          /*animated*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className, selected*/
      1048640) {
        toggle_class(
          g,
          "selected",
          /*selected*/
          ctx2[6]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(g);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(79:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[7] && create_if_block3(ctx);
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*hidden*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hidden*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let edgeComponent;
  let markerStartUrl;
  let markerEndUrl;
  let $edges;
  let $flowId;
  let $edgeTypes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeWrapper", slots, []);
  let { id: id2 } = $$props;
  let { type = "default" } = $$props;
  let { source = "" } = $$props;
  let { target = "" } = $$props;
  let { data = {} } = $$props;
  let { style = void 0 } = $$props;
  let { animated = false } = $$props;
  let { selected = false } = $$props;
  let { selectable = true } = $$props;
  let { hidden = false } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { sourceHandle = void 0 } = $$props;
  let { targetHandle = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { sourcePosition } = $$props;
  let { targetPosition } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const { edges, edgeTypes, flowId, selectionRect, selectionRectMode, multiselectionKeyPressed, addSelectedEdges, unselectNodesAndEdges } = useStore();
  validate_store(edges, "edges");
  component_subscribe($$self, edges, (value) => $$invalidate(35, $edges = value));
  validate_store(edgeTypes, "edgeTypes");
  component_subscribe($$self, edgeTypes, (value) => $$invalidate(34, $edgeTypes = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(33, $flowId = value));
  const dispatch2 = createEventDispatcher();
  function onClick(event) {
    const edge = $edges.find((e) => e.id === id2);
    if (!edge) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    if (selectable) {
      selectionRect.set(null);
      selectionRectMode.set(null);
      if (!edge.selected) {
        addSelectedEdges([id2]);
      } else if (edge.selected && get_store_value(multiselectionKeyPressed)) {
        unselectNodesAndEdges({ nodes: [], edges: [edge] });
      }
    }
    dispatch2("edgeclick", { event, edge });
  }
  function onContextMenu(event) {
    const edge = $edges.find((e) => e.id === id2);
    if (edge) {
      dispatch2("edgecontextmenu", { event, edge });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'id'");
    }
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'targetY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'sourcePosition'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console_12.warn("<EdgeWrapper> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "type",
    "source",
    "target",
    "data",
    "style",
    "animated",
    "selected",
    "selectable",
    "hidden",
    "label",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "sourceHandle",
    "targetHandle",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY",
    "sourcePosition",
    "targetPosition",
    "ariaLabel",
    "interactionWidth",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console_12.warn(`<EdgeWrapper> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(29, type = $$props2.type);
    if ("source" in $$props2)
      $$invalidate(1, source = $$props2.source);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("style" in $$props2)
      $$invalidate(4, style = $$props2.style);
    if ("animated" in $$props2)
      $$invalidate(5, animated = $$props2.animated);
    if ("selected" in $$props2)
      $$invalidate(6, selected = $$props2.selected);
    if ("selectable" in $$props2)
      $$invalidate(30, selectable = $$props2.selectable);
    if ("hidden" in $$props2)
      $$invalidate(7, hidden = $$props2.hidden);
    if ("label" in $$props2)
      $$invalidate(8, label = $$props2.label);
    if ("labelStyle" in $$props2)
      $$invalidate(9, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2)
      $$invalidate(31, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2)
      $$invalidate(32, markerEnd = $$props2.markerEnd);
    if ("sourceHandle" in $$props2)
      $$invalidate(10, sourceHandle = $$props2.sourceHandle);
    if ("targetHandle" in $$props2)
      $$invalidate(11, targetHandle = $$props2.targetHandle);
    if ("sourceX" in $$props2)
      $$invalidate(12, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2)
      $$invalidate(13, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2)
      $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2)
      $$invalidate(15, targetY = $$props2.targetY);
    if ("sourcePosition" in $$props2)
      $$invalidate(16, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2)
      $$invalidate(17, targetPosition = $$props2.targetPosition);
    if ("ariaLabel" in $$props2)
      $$invalidate(18, ariaLabel = $$props2.ariaLabel);
    if ("interactionWidth" in $$props2)
      $$invalidate(19, interactionWidth = $$props2.interactionWidth);
    if ("class" in $$props2)
      $$invalidate(20, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    createEventDispatcher,
    errorMessages,
    getMarkerId,
    useStore,
    BezierEdge: BezierEdge_default,
    get: get_store_value,
    id: id2,
    type,
    source,
    target,
    data,
    style,
    animated,
    selected,
    selectable,
    hidden,
    label,
    labelStyle,
    markerStart,
    markerEnd,
    sourceHandle,
    targetHandle,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    ariaLabel,
    interactionWidth,
    className,
    edges,
    edgeTypes,
    flowId,
    selectionRect,
    selectionRectMode,
    multiselectionKeyPressed,
    addSelectedEdges,
    unselectNodesAndEdges,
    dispatch: dispatch2,
    onClick,
    onContextMenu,
    markerEndUrl,
    markerStartUrl,
    edgeComponent,
    $edges,
    $flowId,
    $edgeTypes
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(29, type = $$props2.type);
    if ("source" in $$props2)
      $$invalidate(1, source = $$props2.source);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("style" in $$props2)
      $$invalidate(4, style = $$props2.style);
    if ("animated" in $$props2)
      $$invalidate(5, animated = $$props2.animated);
    if ("selected" in $$props2)
      $$invalidate(6, selected = $$props2.selected);
    if ("selectable" in $$props2)
      $$invalidate(30, selectable = $$props2.selectable);
    if ("hidden" in $$props2)
      $$invalidate(7, hidden = $$props2.hidden);
    if ("label" in $$props2)
      $$invalidate(8, label = $$props2.label);
    if ("labelStyle" in $$props2)
      $$invalidate(9, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2)
      $$invalidate(31, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2)
      $$invalidate(32, markerEnd = $$props2.markerEnd);
    if ("sourceHandle" in $$props2)
      $$invalidate(10, sourceHandle = $$props2.sourceHandle);
    if ("targetHandle" in $$props2)
      $$invalidate(11, targetHandle = $$props2.targetHandle);
    if ("sourceX" in $$props2)
      $$invalidate(12, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2)
      $$invalidate(13, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2)
      $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2)
      $$invalidate(15, targetY = $$props2.targetY);
    if ("sourcePosition" in $$props2)
      $$invalidate(16, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2)
      $$invalidate(17, targetPosition = $$props2.targetPosition);
    if ("ariaLabel" in $$props2)
      $$invalidate(18, ariaLabel = $$props2.ariaLabel);
    if ("interactionWidth" in $$props2)
      $$invalidate(19, interactionWidth = $$props2.interactionWidth);
    if ("className" in $$props2)
      $$invalidate(20, className = $$props2.className);
    if ("markerEndUrl" in $$props2)
      $$invalidate(21, markerEndUrl = $$props2.markerEndUrl);
    if ("markerStartUrl" in $$props2)
      $$invalidate(22, markerStartUrl = $$props2.markerStartUrl);
    if ("edgeComponent" in $$props2)
      $$invalidate(23, edgeComponent = $$props2.edgeComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*type*/
    536870912 | $$self.$$.dirty[1] & /*$edgeTypes*/
    8) {
      $:
        $$invalidate(23, edgeComponent = $edgeTypes[type] || BezierEdge_default);
    }
    if ($$self.$$.dirty[1] & /*markerStart, $flowId*/
    5) {
      $:
        $$invalidate(22, markerStartUrl = markerStart ? `url(#${getMarkerId(markerStart, $flowId)})` : void 0);
    }
    if ($$self.$$.dirty[1] & /*markerEnd, $flowId*/
    6) {
      $:
        $$invalidate(21, markerEndUrl = markerEnd ? `url(#${getMarkerId(markerEnd, $flowId)})` : void 0);
    }
  };
  return [
    id2,
    source,
    target,
    data,
    style,
    animated,
    selected,
    hidden,
    label,
    labelStyle,
    sourceHandle,
    targetHandle,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    ariaLabel,
    interactionWidth,
    className,
    markerEndUrl,
    markerStartUrl,
    edgeComponent,
    edges,
    edgeTypes,
    flowId,
    onClick,
    onContextMenu,
    type,
    selectable,
    markerStart,
    markerEnd,
    $flowId,
    $edgeTypes
  ];
}
var EdgeWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      not_equal,
      {
        id: 0,
        type: 29,
        source: 1,
        target: 2,
        data: 3,
        style: 4,
        animated: 5,
        selected: 6,
        selectable: 30,
        hidden: 7,
        label: 8,
        labelStyle: 9,
        markerStart: 31,
        markerEnd: 32,
        sourceHandle: 10,
        targetHandle: 11,
        sourceX: 12,
        sourceY: 13,
        targetX: 14,
        targetY: 15,
        sourcePosition: 16,
        targetPosition: 17,
        ariaLabel: 18,
        interactionWidth: 19,
        class: 20
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeWrapper",
      options,
      id: create_fragment17.name
    });
  }
  get id() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceHandle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceHandle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetHandle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetHandle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeWrapper_default = EdgeWrapper;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte
var file10 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let marker_1;
  let current;
  const marker_1_spread_levels = [
    /*marker*/
    ctx[2]
  ];
  let marker_1_props = {};
  for (let i = 0; i < marker_1_spread_levels.length; i += 1) {
    marker_1_props = assign(marker_1_props, marker_1_spread_levels[i]);
  }
  marker_1 = new Marker_default({ props: marker_1_props, $$inline: true });
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(marker_1.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(marker_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const marker_1_changes = dirty & /*$markers*/
      1 ? get_spread_update(marker_1_spread_levels, [get_spread_object(
        /*marker*/
        ctx[2]
      )]) : {};
      marker_1.$set(marker_1_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(marker_1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(marker_1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(marker_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(7:2) {#each $markers as marker (marker.id)}",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let defs;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like_dev(
    /*$markers*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*marker*/
    ctx2[2].id
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block2(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      defs = svg_element("defs");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(defs, file10, 7, 0, 133);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, defs, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(defs, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$markers*/
      1) {
        each_value = ensure_array_like_dev(
          /*$markers*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, defs, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(defs);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let $markers;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MarkerDefinition", slots, []);
  const { markers } = useStore();
  validate_store(markers, "markers");
  component_subscribe($$self, markers, (value) => $$invalidate(0, $markers = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<MarkerDefinition> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({ useStore, Marker: Marker_default, markers, $markers });
  return [$markers, markers];
}
var MarkerDefinition = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MarkerDefinition",
      options,
      id: create_fragment18.name
    });
  }
};
var MarkerDefinition_default = MarkerDefinition;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte
var file11 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte";
function create_if_block_12(ctx) {
  let polyline;
  const block = {
    c: function create2() {
      polyline = svg_element("polyline");
      attr_dev(
        polyline,
        "stroke",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "stroke-linecap", "round");
      attr_dev(polyline, "stroke-linejoin", "round");
      attr_dev(
        polyline,
        "stroke-width",
        /*strokeWidth*/
        ctx[7]
      );
      attr_dev(
        polyline,
        "fill",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "points", "-5,-4 0,0 -5,4 -5,-4");
      add_location(polyline, file11, 36, 4, 745);
    },
    m: function mount(target, anchor) {
      insert_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "stroke",
          /*color*/
          ctx2[6]
        );
      }
      if (dirty & /*strokeWidth*/
      128) {
        attr_dev(
          polyline,
          "stroke-width",
          /*strokeWidth*/
          ctx2[7]
        );
      }
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "fill",
          /*color*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polyline);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(32:44) ",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let polyline;
  const block = {
    c: function create2() {
      polyline = svg_element("polyline");
      attr_dev(
        polyline,
        "stroke",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "stroke-linecap", "round");
      attr_dev(polyline, "stroke-linejoin", "round");
      attr_dev(
        polyline,
        "stroke-width",
        /*strokeWidth*/
        ctx[7]
      );
      attr_dev(polyline, "fill", "none");
      attr_dev(polyline, "points", "-5,-4 0,0 -5,4");
      add_location(polyline, file11, 27, 4, 518);
    },
    m: function mount(target, anchor) {
      insert_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "stroke",
          /*color*/
          ctx2[6]
        );
      }
      if (dirty & /*strokeWidth*/
      128) {
        attr_dev(
          polyline,
          "stroke-width",
          /*strokeWidth*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polyline);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(23:2) {#if type === MarkerType.Arrow}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let marker;
  let marker_markerWidth_value;
  let marker_markerHeight_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === MarkerType.Arrow
    )
      return create_if_block4;
    if (
      /*type*/
      ctx2[1] === MarkerType.ArrowClosed
    )
      return create_if_block_12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create2() {
      marker = svg_element("marker");
      if (if_block)
        if_block.c();
      attr_dev(marker, "class", "svelte-flow__arrowhead");
      attr_dev(
        marker,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(marker, "markerWidth", marker_markerWidth_value = `${/*width*/
      ctx[2]}`);
      attr_dev(marker, "markerHeight", marker_markerHeight_value = `${/*height*/
      ctx[3]}`);
      attr_dev(marker, "viewBox", "-10 -10 20 20");
      attr_dev(
        marker,
        "markerUnits",
        /*markerUnits*/
        ctx[4]
      );
      attr_dev(
        marker,
        "orient",
        /*orient*/
        ctx[5]
      );
      attr_dev(marker, "refX", "0");
      attr_dev(marker, "refY", "0");
      add_location(marker, file11, 15, 0, 299);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, marker, anchor);
      if (if_block)
        if_block.m(marker, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(marker, null);
        }
      }
      if (dirty & /*id*/
      1) {
        attr_dev(
          marker,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      4 && marker_markerWidth_value !== (marker_markerWidth_value = `${/*width*/
      ctx2[2]}`)) {
        attr_dev(marker, "markerWidth", marker_markerWidth_value);
      }
      if (dirty & /*height*/
      8 && marker_markerHeight_value !== (marker_markerHeight_value = `${/*height*/
      ctx2[3]}`)) {
        attr_dev(marker, "markerHeight", marker_markerHeight_value);
      }
      if (dirty & /*markerUnits*/
      16) {
        attr_dev(
          marker,
          "markerUnits",
          /*markerUnits*/
          ctx2[4]
        );
      }
      if (dirty & /*orient*/
      32) {
        attr_dev(
          marker,
          "orient",
          /*orient*/
          ctx2[5]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(marker);
      }
      if (if_block) {
        if_block.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Marker", slots, []);
  let { id: id2 } = $$props;
  let { type } = $$props;
  let { width = 12.5 } = $$props;
  let { height = 12.5 } = $$props;
  let { markerUnits = "strokeWidth" } = $$props;
  let { orient = "auto-start-reverse" } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Marker> was created without expected prop 'id'");
    }
    if (type === void 0 && !("type" in $$props || $$self.$$.bound[$$self.$$.props["type"]])) {
      console.warn("<Marker> was created without expected prop 'type'");
    }
  });
  const writable_props = [
    "id",
    "type",
    "width",
    "height",
    "markerUnits",
    "orient",
    "color",
    "strokeWidth"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Marker> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("markerUnits" in $$props2)
      $$invalidate(4, markerUnits = $$props2.markerUnits);
    if ("orient" in $$props2)
      $$invalidate(5, orient = $$props2.orient);
    if ("color" in $$props2)
      $$invalidate(6, color2 = $$props2.color);
    if ("strokeWidth" in $$props2)
      $$invalidate(7, strokeWidth = $$props2.strokeWidth);
  };
  $$self.$capture_state = () => ({
    MarkerType,
    id: id2,
    type,
    width,
    height,
    markerUnits,
    orient,
    color: color2,
    strokeWidth
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("markerUnits" in $$props2)
      $$invalidate(4, markerUnits = $$props2.markerUnits);
    if ("orient" in $$props2)
      $$invalidate(5, orient = $$props2.orient);
    if ("color" in $$props2)
      $$invalidate(6, color2 = $$props2.color);
    if ("strokeWidth" in $$props2)
      $$invalidate(7, strokeWidth = $$props2.strokeWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id2, type, width, height, markerUnits, orient, color2, strokeWidth];
}
var Marker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      id: 0,
      type: 1,
      width: 2,
      height: 3,
      markerUnits: 4,
      orient: 5,
      color: 6,
      strokeWidth: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Marker",
      options,
      id: create_fragment19.name
    });
  }
  get id() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerUnits() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerUnits(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orient() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orient(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Marker_default = Marker;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte
var file12 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1cxe957", ".svelte-flow__edges.svelte-1cxe957{width:100%;height:100%;position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRnZVJlbmRlcmVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrRUUsa0NBQW9CLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUNSIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJFZGdlUmVuZGVyZXIuc3ZlbHRlIl19 */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  const constants_0 = (
    /*edge*/
    child_ctx[11].type || "default"
  );
  child_ctx[12] = constants_0;
  const constants_1 = !!/*edge*/
  (child_ctx[11].selectable || /*$elementsSelectable*/
  child_ctx[1] && typeof /*edge*/
  child_ctx[11].selectable === "undefined");
  child_ctx[13] = constants_1;
  return child_ctx;
}
function create_if_block5(ctx) {
  let markerdefinition;
  let current;
  markerdefinition = new MarkerDefinition_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(markerdefinition.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(markerdefinition, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(markerdefinition.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(markerdefinition.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(markerdefinition, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(19:4) {#if group.isMaxLevel}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let edgewrapper;
  let current;
  edgewrapper = new EdgeWrapper_default({
    props: {
      id: (
        /*edge*/
        ctx[11].id
      ),
      source: (
        /*edge*/
        ctx[11].source
      ),
      target: (
        /*edge*/
        ctx[11].target
      ),
      data: (
        /*edge*/
        ctx[11].data
      ),
      style: (
        /*edge*/
        ctx[11].style
      ),
      animated: (
        /*edge*/
        ctx[11].animated
      ),
      selected: (
        /*edge*/
        ctx[11].selected
      ),
      hidden: (
        /*edge*/
        ctx[11].hidden
      ),
      label: (
        /*edge*/
        ctx[11].label
      ),
      labelStyle: (
        /*edge*/
        ctx[11].labelStyle
      ),
      markerStart: (
        /*edge*/
        ctx[11].markerStart
      ),
      markerEnd: (
        /*edge*/
        ctx[11].markerEnd
      ),
      sourceHandle: (
        /*edge*/
        ctx[11].sourceHandle
      ),
      targetHandle: (
        /*edge*/
        ctx[11].targetHandle
      ),
      sourceX: (
        /*edge*/
        ctx[11].sourceX
      ),
      sourceY: (
        /*edge*/
        ctx[11].sourceY
      ),
      targetX: (
        /*edge*/
        ctx[11].targetX
      ),
      targetY: (
        /*edge*/
        ctx[11].targetY
      ),
      sourcePosition: (
        /*edge*/
        ctx[11].sourcePosition
      ),
      targetPosition: (
        /*edge*/
        ctx[11].targetPosition
      ),
      ariaLabel: (
        /*edge*/
        ctx[11].ariaLabel
      ),
      interactionWidth: (
        /*edge*/
        ctx[11].interactionWidth
      ),
      class: (
        /*edge*/
        ctx[11].class
      ),
      type: (
        /*edgeType*/
        ctx[12]
      ),
      selectable: (
        /*selectable*/
        ctx[13]
      )
    },
    $$inline: true
  });
  edgewrapper.$on(
    "edgeclick",
    /*edgeclick_handler*/
    ctx[5]
  );
  edgewrapper.$on(
    "edgecontextmenu",
    /*edgecontextmenu_handler*/
    ctx[6]
  );
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(edgewrapper.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(edgewrapper, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const edgewrapper_changes = {};
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.id = /*edge*/
        ctx[11].id;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.source = /*edge*/
        ctx[11].source;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.target = /*edge*/
        ctx[11].target;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.data = /*edge*/
        ctx[11].data;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.style = /*edge*/
        ctx[11].style;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.animated = /*edge*/
        ctx[11].animated;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.selected = /*edge*/
        ctx[11].selected;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.hidden = /*edge*/
        ctx[11].hidden;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.label = /*edge*/
        ctx[11].label;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.labelStyle = /*edge*/
        ctx[11].labelStyle;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.markerStart = /*edge*/
        ctx[11].markerStart;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.markerEnd = /*edge*/
        ctx[11].markerEnd;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.sourceHandle = /*edge*/
        ctx[11].sourceHandle;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.targetHandle = /*edge*/
        ctx[11].targetHandle;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.sourceX = /*edge*/
        ctx[11].sourceX;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.sourceY = /*edge*/
        ctx[11].sourceY;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.targetX = /*edge*/
        ctx[11].targetX;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.targetY = /*edge*/
        ctx[11].targetY;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.sourcePosition = /*edge*/
        ctx[11].sourcePosition;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.targetPosition = /*edge*/
        ctx[11].targetPosition;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.ariaLabel = /*edge*/
        ctx[11].ariaLabel;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.interactionWidth = /*edge*/
        ctx[11].interactionWidth;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.class = /*edge*/
        ctx[11].class;
      if (dirty & /*$edgeTree*/
      1)
        edgewrapper_changes.type = /*edgeType*/
        ctx[12];
      if (dirty & /*$edgeTree, $elementsSelectable*/
      3)
        edgewrapper_changes.selectable = /*selectable*/
        ctx[13];
      edgewrapper.$set(edgewrapper_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(edgewrapper.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgewrapper.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(edgewrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(21:6) {#each group.edges as edge (edge.id)}",
    ctx
  });
  return block;
}
function create_each_block3(key_1, ctx) {
  let svg;
  let g;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let if_block = (
    /*group*/
    ctx[8].isMaxLevel && create_if_block5(ctx)
  );
  let each_value_1 = ensure_array_like_dev(
    /*group*/
    ctx[8].edges
  );
  const get_key = (ctx2) => (
    /*edge*/
    ctx2[11].id
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block_1(key2, child_ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(g, file12, 23, 4, 591);
      set_style(
        svg,
        "z-index",
        /*group*/
        ctx[8].level
      );
      attr_dev(svg, "class", "svelte-flow__edges svelte-1cxe957");
      add_location(svg, file12, 21, 2, 470);
      this.first = svg;
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, g);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(g, null);
        }
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*group*/
        ctx[8].isMaxLevel
      ) {
        if (if_block) {
          if (dirty & /*$edgeTree*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(svg, g);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*$edgeTree, $elementsSelectable*/
      3) {
        each_value_1 = ensure_array_like_dev(
          /*group*/
          ctx[8].edges
        );
        group_outros();
        validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, g, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        check_outros();
      }
      if (!current || dirty & /*$edgeTree*/
      1) {
        set_style(
          svg,
          "z-index",
          /*group*/
          ctx[8].level
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(17:0) {#each $edgeTree as group (group.level)}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$edgeTree*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*group*/
    ctx2[8].level
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block3(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$edgeTree, $elementsSelectable*/
      3) {
        each_value = ensure_array_like_dev(
          /*$edgeTree*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block3, each_1_anchor, get_each_context3);
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let $edgeTree;
  let $elementsSelectable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeRenderer", slots, []);
  let { defaultEdgeOptions } = $$props;
  const { elementsSelectable, edgeTree, edges: { setDefaultOptions } } = useStore();
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(1, $elementsSelectable = value));
  validate_store(edgeTree, "edgeTree");
  component_subscribe($$self, edgeTree, (value) => $$invalidate(0, $edgeTree = value));
  onMount(() => {
    if (defaultEdgeOptions)
      setDefaultOptions(defaultEdgeOptions);
  });
  $$self.$$.on_mount.push(function() {
    if (defaultEdgeOptions === void 0 && !("defaultEdgeOptions" in $$props || $$self.$$.bound[$$self.$$.props["defaultEdgeOptions"]])) {
      console.warn("<EdgeRenderer> was created without expected prop 'defaultEdgeOptions'");
    }
  });
  const writable_props = ["defaultEdgeOptions"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<EdgeRenderer> was created with unknown prop '${key2}'`);
  });
  function edgeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("defaultEdgeOptions" in $$props2)
      $$invalidate(4, defaultEdgeOptions = $$props2.defaultEdgeOptions);
  };
  $$self.$capture_state = () => ({
    onMount,
    EdgeWrapper: EdgeWrapper_default,
    MarkerDefinition: MarkerDefinition_default,
    useStore,
    defaultEdgeOptions,
    elementsSelectable,
    edgeTree,
    setDefaultOptions,
    $edgeTree,
    $elementsSelectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("defaultEdgeOptions" in $$props2)
      $$invalidate(4, defaultEdgeOptions = $$props2.defaultEdgeOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $edgeTree,
    $elementsSelectable,
    elementsSelectable,
    edgeTree,
    defaultEdgeOptions,
    edgeclick_handler,
    edgecontextmenu_handler
  ];
}
var EdgeRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { defaultEdgeOptions: 4 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeRenderer",
      options,
      id: create_fragment20.name
    });
  }
  get defaultEdgeOptions() {
    throw new Error("<EdgeRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultEdgeOptions(value) {
    throw new Error("<EdgeRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeRenderer_default = EdgeRenderer;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte
var file13 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte";
function add_css6(target) {
  append_styles(target, "svelte-1iugwpu", ".svelte-flow__selection.svelte-1iugwpu{position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQkUsc0NBQXdCLENBQ3RCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQ1IiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlNlbGVjdGlvbi5zdmVsdGUiXX0= */");
}
function create_if_block6(ctx) {
  let div;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", "svelte-flow__selection svelte-1iugwpu");
      set_style(div, "width", typeof /*width*/
      ctx[2] === "string" ? (
        /*width*/
        ctx[2]
      ) : `${/*width*/
      ctx[2]}px`);
      set_style(div, "height", typeof /*height*/
      ctx[3] === "string" ? (
        /*height*/
        ctx[3]
      ) : `${/*height*/
      ctx[3]}px`);
      set_style(div, "transform", `translate(${/*x*/
      ctx[0]}px, ${/*y*/
      ctx[1]}px)`);
      add_location(div, file13, 9, 2, 157);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      4) {
        set_style(div, "width", typeof /*width*/
        ctx2[2] === "string" ? (
          /*width*/
          ctx2[2]
        ) : `${/*width*/
        ctx2[2]}px`);
      }
      if (dirty & /*height*/
      8) {
        set_style(div, "height", typeof /*height*/
        ctx2[3] === "string" ? (
          /*height*/
          ctx2[3]
        ) : `${/*height*/
        ctx2[3]}px`);
      }
      if (dirty & /*x, y*/
      3) {
        set_style(div, "transform", `translate(${/*x*/
        ctx2[0]}px, ${/*y*/
        ctx2[1]}px)`);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(8:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isVisible*/
    ctx[4] && create_if_block6(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Selection", slots, []);
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { width = 0 } = $$props;
  let { height = 0 } = $$props;
  let { isVisible = true } = $$props;
  const writable_props = ["x", "y", "width", "height", "isVisible"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Selection> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("isVisible" in $$props2)
      $$invalidate(4, isVisible = $$props2.isVisible);
  };
  $$self.$capture_state = () => ({ x, y, width, height, isVisible });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("isVisible" in $$props2)
      $$invalidate(4, isVisible = $$props2.isVisible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [x, y, width, height, isVisible];
}
var Selection3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance21,
      create_fragment21,
      safe_not_equal,
      {
        x: 0,
        y: 1,
        width: 2,
        height: 3,
        isVisible: 4
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Selection",
      options,
      id: create_fragment21.name
    });
  }
  get x() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Selection_default = Selection3;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/UserSelection/UserSelection.svelte
function create_fragment22(ctx) {
  var _a, _b, _c, _d;
  let selection2;
  let current;
  selection2 = new Selection_default({
    props: {
      isVisible: !!/*$selectionRect*/
      (ctx[0] && /*$selectionRectMode*/
      ctx[1] === "user"),
      width: (
        /*$selectionRect*/
        (_a = ctx[0]) == null ? void 0 : _a.width
      ),
      height: (
        /*$selectionRect*/
        (_b = ctx[0]) == null ? void 0 : _b.height
      ),
      x: (
        /*$selectionRect*/
        (_c = ctx[0]) == null ? void 0 : _c.x
      ),
      y: (
        /*$selectionRect*/
        (_d = ctx[0]) == null ? void 0 : _d.y
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(selection2.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(selection2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      const selection_changes = {};
      if (dirty & /*$selectionRect, $selectionRectMode*/
      3)
        selection_changes.isVisible = !!/*$selectionRect*/
        (ctx2[0] && /*$selectionRectMode*/
        ctx2[1] === "user");
      if (dirty & /*$selectionRect*/
      1)
        selection_changes.width = /*$selectionRect*/
        (_a2 = ctx2[0]) == null ? void 0 : _a2.width;
      if (dirty & /*$selectionRect*/
      1)
        selection_changes.height = /*$selectionRect*/
        (_b2 = ctx2[0]) == null ? void 0 : _b2.height;
      if (dirty & /*$selectionRect*/
      1)
        selection_changes.x = /*$selectionRect*/
        (_c2 = ctx2[0]) == null ? void 0 : _c2.x;
      if (dirty & /*$selectionRect*/
      1)
        selection_changes.y = /*$selectionRect*/
        (_d2 = ctx2[0]) == null ? void 0 : _d2.y;
      selection2.$set(selection_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(selection2.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(selection2.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(selection2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let $selectionRect;
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserSelection", slots, []);
  const { selectionRect, selectionRectMode } = useStore();
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(0, $selectionRect = value));
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(1, $selectionRectMode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<UserSelection> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({
    useStore,
    Selection: Selection_default,
    selectionRect,
    selectionRectMode,
    $selectionRect,
    $selectionRectMode
  });
  return [$selectionRect, $selectionRectMode, selectionRect, selectionRectMode];
}
var UserSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserSelection",
      options,
      id: create_fragment22.name
    });
  }
};
var UserSelection_default = UserSelection;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte
var file14 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte";
function add_css7(target) {
  append_styles(target, "svelte-5pxri", ".selection-wrapper.svelte-5pxri{position:absolute;top:0;left:0;z-index:7;pointer-events:all}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVNlbGVjdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMENFLCtCQUFtQixDQUNqQixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsT0FBTyxDQUFFLENBQUMsQ0FDVixjQUFjLENBQUUsR0FDbEIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIk5vZGVTZWxlY3Rpb24uc3ZlbHRlIl19 */");
}
function create_if_block7(ctx) {
  let div;
  let selection2;
  let drag_action;
  let current;
  let mounted;
  let dispose;
  selection2 = new Selection_default({
    props: {
      width: "100%",
      height: "100%",
      x: 0,
      y: 0
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div = element("div");
      create_component(selection2.$$.fragment);
      attr_dev(div, "class", "selection-wrapper nopan svelte-5pxri");
      set_style(
        div,
        "width",
        /*bounds*/
        ctx[1].width + "px"
      );
      set_style(
        div,
        "height",
        /*bounds*/
        ctx[1].height + "px"
      );
      set_style(div, "transform", "translate(" + /*bounds*/
      ctx[1].x + "px, " + /*bounds*/
      ctx[1].y + "px)");
      add_location(div, file14, 30, 2, 709);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(selection2, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = drag.call(null, div, { disabled: false, store: (
            /*store*/
            ctx[3]
          ) })),
          listen_dev(
            div,
            "contextmenu",
            /*onContextMenu*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*bounds*/
      2) {
        set_style(
          div,
          "width",
          /*bounds*/
          ctx2[1].width + "px"
        );
      }
      if (!current || dirty & /*bounds*/
      2) {
        set_style(
          div,
          "height",
          /*bounds*/
          ctx2[1].height + "px"
        );
      }
      if (!current || dirty & /*bounds*/
      2) {
        set_style(div, "transform", "translate(" + /*bounds*/
        ctx2[1].x + "px, " + /*bounds*/
        ctx2[1].y + "px)");
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(selection2.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(selection2.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(selection2);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(21:0) {#if selectedNodes && $selectionRectMode === 'nodes'}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*selectedNodes*/
    ctx[0] && /*$selectionRectMode*/
    ctx[2] === "nodes" && create_if_block7(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*selectedNodes*/
        ctx2[0] && /*$selectionRectMode*/
        ctx2[2] === "nodes"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*selectedNodes, $selectionRectMode*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let selectedNodes;
  let bounds;
  let $nodes;
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeSelection", slots, []);
  const store = useStore();
  const { selectionRectMode, nodes } = store;
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(2, $selectionRectMode = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(8, $nodes = value));
  const dispatch2 = createEventDispatcher();
  function onContextMenu(event) {
    dispatch2("selectioncontextmenu", { nodes: selectedNodes, event });
  }
  function onClick(event) {
    dispatch2("selectionclick", { nodes: selectedNodes, event });
  }
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<NodeSelection> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({
    getNodesBounds,
    createEventDispatcher,
    useStore,
    Selection: Selection_default,
    drag,
    store,
    selectionRectMode,
    nodes,
    dispatch: dispatch2,
    onContextMenu,
    onClick,
    selectedNodes,
    bounds,
    $nodes,
    $selectionRectMode
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectedNodes" in $$props2)
      $$invalidate(0, selectedNodes = $$props2.selectedNodes);
    if ("bounds" in $$props2)
      $$invalidate(1, bounds = $$props2.bounds);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$nodes*/
    256) {
      $:
        $$invalidate(0, selectedNodes = $nodes.filter((n) => n.selected));
    }
    if ($$self.$$.dirty & /*selectedNodes*/
    1) {
      $:
        $$invalidate(1, bounds = getNodesBounds(selectedNodes));
    }
  };
  return [
    selectedNodes,
    bounds,
    $selectionRectMode,
    store,
    selectionRectMode,
    nodes,
    onContextMenu,
    onClick,
    $nodes
  ];
}
var NodeSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {}, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeSelection",
      options,
      id: create_fragment23.name
    });
  }
};
var NodeSelection_default = NodeSelection;

// node_modules/.pnpm/@svelte-put+shortcut@3.1.1_svelte@4.2.17/node_modules/@svelte-put/shortcut/src/shortcut.js
function shortcut(node, param) {
  let { enabled = true, trigger, type = "keydown" } = param;
  function handler(event) {
    const normalizedTriggers = Array.isArray(trigger) ? trigger : [trigger];
    const modifiedMap = {
      alt: event.altKey,
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      meta: event.metaKey
    };
    for (const trigger2 of normalizedTriggers) {
      const mergedTrigger = {
        modifier: [],
        preventDefault: false,
        enabled: true,
        ...trigger2
      };
      const { modifier, key: key2, callback, preventDefault, enabled: triggerEnabled } = mergedTrigger;
      if (triggerEnabled) {
        if (modifier.length) {
          const modifierDefs = (Array.isArray(modifier) ? modifier : [modifier]).map(
            (def) => typeof def === "string" ? [def] : def
          );
          const modified = modifierDefs.some(
            (def) => def.every((modifier2) => modifiedMap[modifier2])
          );
          if (!modified)
            continue;
        }
        if (event.key === key2) {
          if (preventDefault)
            event.preventDefault();
          const detail = {
            node,
            trigger: mergedTrigger,
            originalEvent: event
          };
          node.dispatchEvent(new CustomEvent("shortcut", { detail }));
          callback == null ? void 0 : callback(detail);
        }
      }
    }
  }
  if (enabled)
    node.addEventListener(type, handler);
  return {
    update: (update) => {
      const { enabled: newEnabled = true, type: newType = "keydown" } = update;
      if (enabled && (!newEnabled || type !== newType)) {
        node.removeEventListener(type, handler);
      } else if (!enabled && newEnabled) {
        node.addEventListener(newType, handler);
      }
      enabled = newEnabled;
      type = newType;
      trigger = update.trigger;
    },
    destroy: () => {
      node.removeEventListener(type, handler);
    }
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte
function create_fragment24(ctx) {
  let shortcut_action;
  let shortcut_action_1;
  let shortcut_action_2;
  let shortcut_action_3;
  let shortcut_action_4;
  let shortcut_action_5;
  let shortcut_action_6;
  let shortcut_action_7;
  let shortcut_action_8;
  let shortcut_action_9;
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          action_destroyer(shortcut_action = shortcut.call(null, window, {
            trigger: [
              {
                .../*selectionKeyDefinition*/
                ctx[4],
                callback: (
                  /*shortcut_function*/
                  ctx[15]
                )
              }
            ],
            type: "keydown"
          })),
          action_destroyer(shortcut_action_1 = shortcut.call(null, window, {
            trigger: [
              {
                .../*selectionKeyDefinition*/
                ctx[4],
                callback: (
                  /*shortcut_function_1*/
                  ctx[16]
                )
              }
            ],
            type: "keyup"
          })),
          action_destroyer(shortcut_action_2 = shortcut.call(null, window, {
            trigger: [
              {
                .../*multiSelectionKeyDefinition*/
                ctx[3],
                callback: (
                  /*shortcut_function_2*/
                  ctx[17]
                )
              }
            ],
            type: "keydown"
          })),
          action_destroyer(shortcut_action_3 = shortcut.call(null, window, {
            trigger: [
              {
                .../*multiSelectionKeyDefinition*/
                ctx[3],
                callback: (
                  /*shortcut_function_3*/
                  ctx[18]
                )
              }
            ],
            type: "keyup"
          })),
          action_destroyer(shortcut_action_4 = shortcut.call(null, window, {
            trigger: [
              {
                .../*deleteKeyDefinition*/
                ctx[2],
                callback: (
                  /*shortcut_function_4*/
                  ctx[19]
                )
              }
            ],
            type: "keydown"
          })),
          action_destroyer(shortcut_action_5 = shortcut.call(null, window, {
            trigger: [
              {
                .../*deleteKeyDefinition*/
                ctx[2],
                callback: (
                  /*shortcut_function_5*/
                  ctx[20]
                )
              }
            ],
            type: "keyup"
          })),
          action_destroyer(shortcut_action_6 = shortcut.call(null, window, {
            trigger: [
              {
                .../*panActivationKeyDefinition*/
                ctx[1],
                callback: (
                  /*shortcut_function_6*/
                  ctx[21]
                )
              }
            ],
            type: "keydown"
          })),
          action_destroyer(shortcut_action_7 = shortcut.call(null, window, {
            trigger: [
              {
                .../*panActivationKeyDefinition*/
                ctx[1],
                callback: (
                  /*shortcut_function_7*/
                  ctx[22]
                )
              }
            ],
            type: "keyup"
          })),
          action_destroyer(shortcut_action_8 = shortcut.call(null, window, {
            trigger: [
              {
                .../*zoomActivationKeyDefinition*/
                ctx[0],
                callback: (
                  /*shortcut_function_8*/
                  ctx[23]
                )
              }
            ],
            type: "keydown"
          })),
          action_destroyer(shortcut_action_9 = shortcut.call(null, window, {
            trigger: [
              {
                .../*zoomActivationKeyDefinition*/
                ctx[0],
                callback: (
                  /*shortcut_function_9*/
                  ctx[24]
                )
              }
            ],
            type: "keyup"
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (shortcut_action && is_function(shortcut_action.update) && dirty & /*selectionKeyDefinition*/
      16)
        shortcut_action.update.call(null, {
          trigger: [
            {
              .../*selectionKeyDefinition*/
              ctx2[4],
              callback: (
                /*shortcut_function*/
                ctx2[15]
              )
            }
          ],
          type: "keydown"
        });
      if (shortcut_action_1 && is_function(shortcut_action_1.update) && dirty & /*selectionKeyDefinition*/
      16)
        shortcut_action_1.update.call(null, {
          trigger: [
            {
              .../*selectionKeyDefinition*/
              ctx2[4],
              callback: (
                /*shortcut_function_1*/
                ctx2[16]
              )
            }
          ],
          type: "keyup"
        });
      if (shortcut_action_2 && is_function(shortcut_action_2.update) && dirty & /*multiSelectionKeyDefinition*/
      8)
        shortcut_action_2.update.call(null, {
          trigger: [
            {
              .../*multiSelectionKeyDefinition*/
              ctx2[3],
              callback: (
                /*shortcut_function_2*/
                ctx2[17]
              )
            }
          ],
          type: "keydown"
        });
      if (shortcut_action_3 && is_function(shortcut_action_3.update) && dirty & /*multiSelectionKeyDefinition*/
      8)
        shortcut_action_3.update.call(null, {
          trigger: [
            {
              .../*multiSelectionKeyDefinition*/
              ctx2[3],
              callback: (
                /*shortcut_function_3*/
                ctx2[18]
              )
            }
          ],
          type: "keyup"
        });
      if (shortcut_action_4 && is_function(shortcut_action_4.update) && dirty & /*deleteKeyDefinition*/
      4)
        shortcut_action_4.update.call(null, {
          trigger: [
            {
              .../*deleteKeyDefinition*/
              ctx2[2],
              callback: (
                /*shortcut_function_4*/
                ctx2[19]
              )
            }
          ],
          type: "keydown"
        });
      if (shortcut_action_5 && is_function(shortcut_action_5.update) && dirty & /*deleteKeyDefinition*/
      4)
        shortcut_action_5.update.call(null, {
          trigger: [
            {
              .../*deleteKeyDefinition*/
              ctx2[2],
              callback: (
                /*shortcut_function_5*/
                ctx2[20]
              )
            }
          ],
          type: "keyup"
        });
      if (shortcut_action_6 && is_function(shortcut_action_6.update) && dirty & /*panActivationKeyDefinition*/
      2)
        shortcut_action_6.update.call(null, {
          trigger: [
            {
              .../*panActivationKeyDefinition*/
              ctx2[1],
              callback: (
                /*shortcut_function_6*/
                ctx2[21]
              )
            }
          ],
          type: "keydown"
        });
      if (shortcut_action_7 && is_function(shortcut_action_7.update) && dirty & /*panActivationKeyDefinition*/
      2)
        shortcut_action_7.update.call(null, {
          trigger: [
            {
              .../*panActivationKeyDefinition*/
              ctx2[1],
              callback: (
                /*shortcut_function_7*/
                ctx2[22]
              )
            }
          ],
          type: "keyup"
        });
      if (shortcut_action_8 && is_function(shortcut_action_8.update) && dirty & /*zoomActivationKeyDefinition*/
      1)
        shortcut_action_8.update.call(null, {
          trigger: [
            {
              .../*zoomActivationKeyDefinition*/
              ctx2[0],
              callback: (
                /*shortcut_function_8*/
                ctx2[23]
              )
            }
          ],
          type: "keydown"
        });
      if (shortcut_action_9 && is_function(shortcut_action_9.update) && dirty & /*zoomActivationKeyDefinition*/
      1)
        shortcut_action_9.update.call(null, {
          trigger: [
            {
              .../*zoomActivationKeyDefinition*/
              ctx2[0],
              callback: (
                /*shortcut_function_9*/
                ctx2[24]
              )
            }
          ],
          type: "keyup"
        });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function isKeyObject(key2) {
  return typeof key2 === "object";
}
function getModifier(key2) {
  return isKeyObject(key2) ? key2.modifier || [] : [];
}
function getKeyString(key2) {
  if (key2 === null || key2 === void 0) {
    return "";
  }
  return isKeyObject(key2) ? key2.key : key2;
}
function instance24($$self, $$props, $$invalidate) {
  let selectionKeyDefinition;
  let multiSelectionKeyDefinition;
  let deleteKeyDefinition;
  let panActivationKeyDefinition;
  let zoomActivationKeyDefinition;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("KeyHandler", slots, []);
  let { selectionKey = "Shift" } = $$props;
  let { multiSelectionKey = isMacOs() ? "Meta" : "Control" } = $$props;
  let { deleteKey = "Backspace" } = $$props;
  let { panActivationKey = " " } = $$props;
  let { zoomActivationKey = isMacOs() ? "Meta" : "Control" } = $$props;
  const { selectionKeyPressed, multiselectionKeyPressed, deleteKeyPressed, panActivationKeyPressed, zoomActivationKeyPressed } = useStore();
  const writable_props = [
    "selectionKey",
    "multiSelectionKey",
    "deleteKey",
    "panActivationKey",
    "zoomActivationKey"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<KeyHandler> was created with unknown prop '${key2}'`);
  });
  const shortcut_function = () => selectionKeyDefinition.key && selectionKeyPressed.set(true);
  const shortcut_function_1 = () => selectionKeyDefinition.key && selectionKeyPressed.set(false);
  const shortcut_function_2 = () => multiSelectionKeyDefinition.key && multiselectionKeyPressed.set(true);
  const shortcut_function_3 = () => multiSelectionKeyDefinition.key && multiselectionKeyPressed.set(false);
  const shortcut_function_4 = () => deleteKeyDefinition.key && deleteKeyPressed.set(true);
  const shortcut_function_5 = () => deleteKeyDefinition.key && deleteKeyPressed.set(false);
  const shortcut_function_6 = () => panActivationKeyDefinition.key && panActivationKeyPressed.set(true);
  const shortcut_function_7 = () => panActivationKeyDefinition.key && panActivationKeyPressed.set(false);
  const shortcut_function_8 = () => zoomActivationKeyDefinition.key && zoomActivationKeyPressed.set(true);
  const shortcut_function_9 = () => zoomActivationKeyDefinition.key && zoomActivationKeyPressed.set(false);
  $$self.$$set = ($$props2) => {
    if ("selectionKey" in $$props2)
      $$invalidate(10, selectionKey = $$props2.selectionKey);
    if ("multiSelectionKey" in $$props2)
      $$invalidate(11, multiSelectionKey = $$props2.multiSelectionKey);
    if ("deleteKey" in $$props2)
      $$invalidate(12, deleteKey = $$props2.deleteKey);
    if ("panActivationKey" in $$props2)
      $$invalidate(13, panActivationKey = $$props2.panActivationKey);
    if ("zoomActivationKey" in $$props2)
      $$invalidate(14, zoomActivationKey = $$props2.zoomActivationKey);
  };
  $$self.$capture_state = () => ({
    shortcut,
    useStore,
    isMacOs,
    selectionKey,
    multiSelectionKey,
    deleteKey,
    panActivationKey,
    zoomActivationKey,
    selectionKeyPressed,
    multiselectionKeyPressed,
    deleteKeyPressed,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    isKeyObject,
    getModifier,
    getKeyString,
    zoomActivationKeyDefinition,
    panActivationKeyDefinition,
    deleteKeyDefinition,
    multiSelectionKeyDefinition,
    selectionKeyDefinition
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectionKey" in $$props2)
      $$invalidate(10, selectionKey = $$props2.selectionKey);
    if ("multiSelectionKey" in $$props2)
      $$invalidate(11, multiSelectionKey = $$props2.multiSelectionKey);
    if ("deleteKey" in $$props2)
      $$invalidate(12, deleteKey = $$props2.deleteKey);
    if ("panActivationKey" in $$props2)
      $$invalidate(13, panActivationKey = $$props2.panActivationKey);
    if ("zoomActivationKey" in $$props2)
      $$invalidate(14, zoomActivationKey = $$props2.zoomActivationKey);
    if ("zoomActivationKeyDefinition" in $$props2)
      $$invalidate(0, zoomActivationKeyDefinition = $$props2.zoomActivationKeyDefinition);
    if ("panActivationKeyDefinition" in $$props2)
      $$invalidate(1, panActivationKeyDefinition = $$props2.panActivationKeyDefinition);
    if ("deleteKeyDefinition" in $$props2)
      $$invalidate(2, deleteKeyDefinition = $$props2.deleteKeyDefinition);
    if ("multiSelectionKeyDefinition" in $$props2)
      $$invalidate(3, multiSelectionKeyDefinition = $$props2.multiSelectionKeyDefinition);
    if ("selectionKeyDefinition" in $$props2)
      $$invalidate(4, selectionKeyDefinition = $$props2.selectionKeyDefinition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectionKey*/
    1024) {
      $:
        $$invalidate(4, selectionKeyDefinition = {
          key: getKeyString(selectionKey),
          modifier: getModifier(selectionKey)
        });
    }
    if ($$self.$$.dirty & /*multiSelectionKey*/
    2048) {
      $:
        $$invalidate(3, multiSelectionKeyDefinition = {
          key: getKeyString(multiSelectionKey),
          modifier: getModifier(multiSelectionKey)
        });
    }
    if ($$self.$$.dirty & /*deleteKey*/
    4096) {
      $:
        $$invalidate(2, deleteKeyDefinition = {
          key: getKeyString(deleteKey),
          modifier: getModifier(deleteKey)
        });
    }
    if ($$self.$$.dirty & /*panActivationKey*/
    8192) {
      $:
        $$invalidate(1, panActivationKeyDefinition = {
          key: getKeyString(panActivationKey),
          modifier: getModifier(panActivationKey)
        });
    }
    if ($$self.$$.dirty & /*zoomActivationKey*/
    16384) {
      $:
        $$invalidate(0, zoomActivationKeyDefinition = {
          key: getKeyString(zoomActivationKey),
          modifier: getModifier(zoomActivationKey)
        });
    }
  };
  return [
    zoomActivationKeyDefinition,
    panActivationKeyDefinition,
    deleteKeyDefinition,
    multiSelectionKeyDefinition,
    selectionKeyDefinition,
    selectionKeyPressed,
    multiselectionKeyPressed,
    deleteKeyPressed,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    selectionKey,
    multiSelectionKey,
    deleteKey,
    panActivationKey,
    zoomActivationKey,
    shortcut_function,
    shortcut_function_1,
    shortcut_function_2,
    shortcut_function_3,
    shortcut_function_4,
    shortcut_function_5,
    shortcut_function_6,
    shortcut_function_7,
    shortcut_function_8,
    shortcut_function_9
  ];
}
var KeyHandler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      selectionKey: 10,
      multiSelectionKey: 11,
      deleteKey: 12,
      panActivationKey: 13,
      zoomActivationKey: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "KeyHandler",
      options,
      id: create_fragment24.name
    });
  }
  get selectionKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectionKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectionKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panActivationKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panActivationKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomActivationKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomActivationKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var KeyHandler_default = KeyHandler;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte
var file15 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte";
var get_connectionLine_slot_changes = (dirty) => ({});
var get_connectionLine_slot_context = (ctx) => ({});
function create_if_block8(ctx) {
  let svg;
  let g;
  let g_class_value;
  let current;
  const connectionLine_slot_template = (
    /*#slots*/
    ctx[10].connectionLine
  );
  const connectionLine_slot = create_slot(
    connectionLine_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_connectionLine_slot_context
  );
  let if_block = !/*isCustomComponent*/
  ctx[2] && create_if_block_13(ctx);
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      g = svg_element("g");
      if (connectionLine_slot)
        connectionLine_slot.c();
      if (if_block)
        if_block.c();
      attr_dev(g, "class", g_class_value = cc([
        "svelte-flow__connection",
        /*$connection*/
        ctx[3].status
      ]));
      add_location(g, file15, 14, 4, 365);
      attr_dev(
        svg,
        "width",
        /*$width*/
        ctx[4]
      );
      attr_dev(
        svg,
        "height",
        /*$height*/
        ctx[5]
      );
      attr_dev(svg, "class", "svelte-flow__connectionline");
      attr_dev(
        svg,
        "style",
        /*containerStyle*/
        ctx[0]
      );
      add_location(svg, file15, 13, 2, 264);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, g);
      if (connectionLine_slot) {
        connectionLine_slot.m(g, null);
      }
      if (if_block)
        if_block.m(g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (connectionLine_slot) {
        if (connectionLine_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            connectionLine_slot,
            connectionLine_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              connectionLine_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_connectionLine_slot_changes
            ),
            get_connectionLine_slot_context
          );
        }
      }
      if (!/*isCustomComponent*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          if_block.m(g, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*$connection*/
      8 && g_class_value !== (g_class_value = cc([
        "svelte-flow__connection",
        /*$connection*/
        ctx2[3].status
      ]))) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & /*$width*/
      16) {
        attr_dev(
          svg,
          "width",
          /*$width*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$height*/
      32) {
        attr_dev(
          svg,
          "height",
          /*$height*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*containerStyle*/
      1) {
        attr_dev(
          svg,
          "style",
          /*containerStyle*/
          ctx2[0]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(connectionLine_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(connectionLine_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (connectionLine_slot)
        connectionLine_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(9:0) {#if $connection.path}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let path;
  let path_d_value;
  const block = {
    c: function create2() {
      path = svg_element("path");
      attr_dev(path, "d", path_d_value = /*$connection*/
      ctx[3].path);
      attr_dev(
        path,
        "style",
        /*style*/
        ctx[1]
      );
      attr_dev(path, "fill", "none");
      attr_dev(path, "class", "svelte-flow__connection-path");
      add_location(path, file15, 18, 8, 580);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$connection*/
      8 && path_d_value !== (path_d_value = /*$connection*/
      ctx2[3].path)) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*style*/
      2) {
        attr_dev(
          path,
          "style",
          /*style*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(14:6) {#if !isCustomComponent}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$connection*/
    ctx[3].path && create_if_block8(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$connection*/
        ctx2[3].path
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$connection*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let $connection;
  let $width;
  let $height;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConnectionLine", slots, ["connectionLine"]);
  let { containerStyle = "" } = $$props;
  let { style = "" } = $$props;
  let { isCustomComponent = false } = $$props;
  const { width, height, connection } = useStore();
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(4, $width = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(5, $height = value));
  validate_store(connection, "connection");
  component_subscribe($$self, connection, (value) => $$invalidate(3, $connection = value));
  const writable_props = ["containerStyle", "style", "isCustomComponent"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<ConnectionLine> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("containerStyle" in $$props2)
      $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("isCustomComponent" in $$props2)
      $$invalidate(2, isCustomComponent = $$props2.isCustomComponent);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    useStore,
    containerStyle,
    style,
    isCustomComponent,
    width,
    height,
    connection,
    $connection,
    $width,
    $height
  });
  $$self.$inject_state = ($$props2) => {
    if ("containerStyle" in $$props2)
      $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("isCustomComponent" in $$props2)
      $$invalidate(2, isCustomComponent = $$props2.isCustomComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    containerStyle,
    style,
    isCustomComponent,
    $connection,
    $width,
    $height,
    width,
    height,
    connection,
    $$scope,
    slots
  ];
}
var ConnectionLine = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      containerStyle: 0,
      style: 1,
      isCustomComponent: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConnectionLine",
      options,
      id: create_fragment25.name
    });
  }
  get containerStyle() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyle(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustomComponent() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustomComponent(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConnectionLine_default = ConnectionLine;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte
var file16 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte";
function create_fragment26(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    {
      class: div_class_value = cc([
        "svelte-flow__panel",
        /*className*/
        ctx[1],
        .../*positionClasses*/
        ctx[2]
      ])
    },
    { style: (
      /*style*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file16, 15, 0, 222);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className, positionClasses*/
        6 && div_class_value !== (div_class_value = cc([
          "svelte-flow__panel",
          /*className*/
          ctx2[1],
          .../*positionClasses*/
          ctx2[2]
        ]))) && { class: div_class_value },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let positionClasses;
  const omit_props_names = ["position", "style", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Panel", slots, ["default"]);
  let { position = "top-right" } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("position" in $$new_props)
      $$invalidate(4, position = $$new_props.position);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    position,
    style,
    className,
    positionClasses
  });
  $$self.$inject_state = ($$new_props) => {
    if ("position" in $$props)
      $$invalidate(4, position = $$new_props.position);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("positionClasses" in $$props)
      $$invalidate(2, positionClasses = $$new_props.positionClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*position*/
    16) {
      $:
        $$invalidate(2, positionClasses = `${position}`.split("-"));
    }
  };
  return [style, className, positionClasses, $$restProps, position, $$scope, slots];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { position: 4, style: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment26.name
    });
  }
  get position() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Panel_default = Panel;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte
var file17 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte";
function create_if_block9(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      position: (
        /*position*/
        ctx[1]
      ),
      class: "svelte-flow__attribution",
      "data-message": "Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us",
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(panel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty & /*position*/
      2)
        panel_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*$$scope*/
      4) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(panel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(panel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(6:0) {#if !proOptions?.hideAttribution}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let a;
  const block = {
    c: function create2() {
      a = element("a");
      a.textContent = "Svelte Flow";
      attr_dev(a, "href", "https://svelteflow.dev");
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noopener noreferrer");
      attr_dev(a, "aria-label", "Svelte Flow attribution");
      add_location(a, file17, 16, 4, 378);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(7:2) <Panel     {position}     class=\\"svelte-flow__attribution\\"     data-message=\\"Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us\\"   >',
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = !/*proOptions*/
  ((_a = ctx[0]) == null ? void 0 : _a.hideAttribution) && create_if_block9(ctx);
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if (!/*proOptions*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.hideAttribution)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*proOptions*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Attribution", slots, []);
  let { proOptions = void 0 } = $$props;
  let { position = "bottom-right" } = $$props;
  const writable_props = ["proOptions", "position"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Attribution> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("proOptions" in $$props2)
      $$invalidate(0, proOptions = $$props2.proOptions);
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
  };
  $$self.$capture_state = () => ({ Panel: Panel_default, proOptions, position });
  $$self.$inject_state = ($$props2) => {
    if ("proOptions" in $$props2)
      $$invalidate(0, proOptions = $$props2.proOptions);
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [proOptions, position];
}
var Attribution = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { proOptions: 0, position: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Attribution",
      options,
      id: create_fragment27.name
    });
  }
  get proOptions() {
    throw new Error("<Attribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set proOptions(value) {
    throw new Error("<Attribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Attribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Attribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Attribution_default = Attribution;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/utils.js
function updateStore(store, { nodeTypes, edgeTypes, minZoom, maxZoom, translateExtent }) {
  if (nodeTypes !== void 0) {
    store.setNodeTypes(nodeTypes);
  }
  if (edgeTypes !== void 0) {
    store.setEdgeTypes(edgeTypes);
  }
  if (minZoom !== void 0) {
    store.setMinZoom(minZoom);
  }
  if (maxZoom !== void 0) {
    store.setMaxZoom(maxZoom);
  }
  if (translateExtent !== void 0) {
    store.setTranslateExtent(translateExtent);
  }
}
var getKeys = (obj) => Object.keys(obj);
function updateStoreByKeys(store, keys) {
  getKeys(keys).forEach((prop) => {
    const update = keys[prop];
    if (update !== void 0) {
      store[prop].set(update);
    }
  });
}
function getColorModeClass(colorMode) {
  if (colorMode !== "system") {
    return colorMode;
  }
  if (!colorMode || typeof window === "undefined" || !window.matchMedia) {
    return "light";
  }
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/hooks/useColorModeClass.js
function getMediaQuery() {
  if (typeof window === "undefined" || !window.matchMedia) {
    return null;
  }
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode = "light") {
  const colorModeClass = readable("light", (set3) => {
    if (colorMode !== "system") {
      set3(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery();
    const updateColorModeClass = () => set3((mediaQuery == null ? void 0 : mediaQuery.matches) ? "dark" : "light");
    set3((mediaQuery == null ? void 0 : mediaQuery.matches) ? "dark" : "light");
    mediaQuery == null ? void 0 : mediaQuery.addEventListener("change", updateColorModeClass);
    return () => {
      mediaQuery == null ? void 0 : mediaQuery.removeEventListener("change", updateColorModeClass);
    };
  });
  return colorModeClass;
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte
var file18 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte";
function add_css8(target) {
  append_styles(target, "svelte-12wlba6", ".svelte-flow.svelte-12wlba6{width:100%;height:100%;overflow:hidden;position:relative;z-index:0;background-color:var(--background-color, var(--background-color-default))}:root{--background-color-default:#fff;--background-pattern-color-default:#ddd;--minimap-mask-color-default:rgb(240, 240, 240, 0.6);--minimap-mask-stroke-color-default:none;--minimap-mask-stroke-width-default:1;--controls-button-background-color-default:#fefefe;--controls-button-background-color-hover-default:#f4f4f4;--controls-button-color-default:inherit;--controls-button-color-hover-default:inherit;--controls-button-border-color-default:#eee}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlRmxvdy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMk9FLDJCQUFhLENBQ1gsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxDQUFDLENBRVYsZ0JBQWdCLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxnQ0FBZ0MsQ0FDM0UsQ0FFQSxLQUFNLENBQ0osMEJBQTBCLENBQUUsSUFBSSxDQUNoQyxrQ0FBa0MsQ0FBRSxJQUFJLENBRXhDLDRCQUE0QixDQUFFLHVCQUF1QixDQUNyRCxtQ0FBbUMsQ0FBRSxJQUFJLENBQ3pDLG1DQUFtQyxDQUFFLENBQUMsQ0FFdEMsMENBQTBDLENBQUUsT0FBTyxDQUNuRCxnREFBZ0QsQ0FBRSxPQUFPLENBQ3pELCtCQUErQixDQUFFLE9BQU8sQ0FDeEMscUNBQXFDLENBQUUsT0FBTyxDQUM5QyxzQ0FBc0MsQ0FBRSxJQUMxQyIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiU3ZlbHRlRmxvdy5zdmVsdGUiXX0= */");
}
var get_connectionLine_slot_changes2 = (dirty) => ({});
var get_connectionLine_slot_context2 = (ctx) => ({ slot: "connectionLine" });
function create_connectionLine_slot(ctx) {
  let current;
  const connectionLine_slot_template = (
    /*#slots*/
    ctx[61].connectionLine
  );
  const connectionLine_slot = create_slot(
    connectionLine_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_connectionLine_slot_context2
  );
  const block = {
    c: function create2() {
      if (connectionLine_slot)
        connectionLine_slot.c();
    },
    m: function mount(target, anchor) {
      if (connectionLine_slot) {
        connectionLine_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (connectionLine_slot) {
        if (connectionLine_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            connectionLine_slot,
            connectionLine_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              connectionLine_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_connectionLine_slot_changes2
            ),
            get_connectionLine_slot_context2
          );
        }
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(connectionLine_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(connectionLine_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (connectionLine_slot)
        connectionLine_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_connectionLine_slot.name,
    type: "slot",
    source: "(185:10) ",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let edgerenderer;
  let t02;
  let connectionline;
  let t12;
  let div;
  let t22;
  let noderenderer;
  let t32;
  let nodeselection;
  let current;
  edgerenderer = new EdgeRenderer_default({
    props: {
      defaultEdgeOptions: (
        /*defaultEdgeOptions*/
        ctx[21]
      )
    },
    $$inline: true
  });
  edgerenderer.$on(
    "edgeclick",
    /*edgeclick_handler*/
    ctx[64]
  );
  edgerenderer.$on(
    "edgecontextmenu",
    /*edgecontextmenu_handler*/
    ctx[65]
  );
  connectionline = new ConnectionLine_default({
    props: {
      containerStyle: (
        /*connectionLineContainerStyle*/
        ctx[7]
      ),
      style: (
        /*connectionLineStyle*/
        ctx[6]
      ),
      isCustomComponent: (
        /*$$slots*/
        ctx[30].connectionLine
      ),
      $$slots: {
        connectionLine: [create_connectionLine_slot]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  noderenderer = new NodeRenderer_default({ $$inline: true });
  noderenderer.$on(
    "nodeclick",
    /*nodeclick_handler*/
    ctx[66]
  );
  noderenderer.$on(
    "nodemouseenter",
    /*nodemouseenter_handler*/
    ctx[67]
  );
  noderenderer.$on(
    "nodemousemove",
    /*nodemousemove_handler*/
    ctx[68]
  );
  noderenderer.$on(
    "nodemouseleave",
    /*nodemouseleave_handler*/
    ctx[69]
  );
  noderenderer.$on(
    "connectstart",
    /*connectstart_handler*/
    ctx[70]
  );
  noderenderer.$on(
    "connect",
    /*connect_handler*/
    ctx[71]
  );
  noderenderer.$on(
    "connectend",
    /*connectend_handler*/
    ctx[72]
  );
  noderenderer.$on(
    "nodedragstart",
    /*nodedragstart_handler*/
    ctx[73]
  );
  noderenderer.$on(
    "nodedrag",
    /*nodedrag_handler*/
    ctx[74]
  );
  noderenderer.$on(
    "nodedragstop",
    /*nodedragstop_handler*/
    ctx[75]
  );
  noderenderer.$on(
    "nodecontextmenu",
    /*nodecontextmenu_handler*/
    ctx[76]
  );
  nodeselection = new NodeSelection_default({ $$inline: true });
  nodeselection.$on(
    "selectionclick",
    /*selectionclick_handler*/
    ctx[77]
  );
  nodeselection.$on(
    "selectioncontextmenu",
    /*selectioncontextmenu_handler*/
    ctx[78]
  );
  const block = {
    c: function create2() {
      create_component(edgerenderer.$$.fragment);
      t02 = space();
      create_component(connectionline.$$.fragment);
      t12 = space();
      div = element("div");
      t22 = space();
      create_component(noderenderer.$$.fragment);
      t32 = space();
      create_component(nodeselection.$$.fragment);
      attr_dev(div, "class", "svelte-flow__edgelabel-renderer");
      add_location(div, file18, 211, 8, 5697);
    },
    m: function mount(target, anchor) {
      mount_component(edgerenderer, target, anchor);
      insert_dev(target, t02, anchor);
      mount_component(connectionline, target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, div, anchor);
      insert_dev(target, t22, anchor);
      mount_component(noderenderer, target, anchor);
      insert_dev(target, t32, anchor);
      mount_component(nodeselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgerenderer_changes = {};
      if (dirty[0] & /*defaultEdgeOptions*/
      2097152)
        edgerenderer_changes.defaultEdgeOptions = /*defaultEdgeOptions*/
        ctx2[21];
      edgerenderer.$set(edgerenderer_changes);
      const connectionline_changes = {};
      if (dirty[0] & /*connectionLineContainerStyle*/
      128)
        connectionline_changes.containerStyle = /*connectionLineContainerStyle*/
        ctx2[7];
      if (dirty[0] & /*connectionLineStyle*/
      64)
        connectionline_changes.style = /*connectionLineStyle*/
        ctx2[6];
      if (dirty[0] & /*$$slots*/
      1073741824)
        connectionline_changes.isCustomComponent = /*$$slots*/
        ctx2[30].connectionLine;
      if (dirty[2] & /*$$scope*/
      1048576) {
        connectionline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      connectionline.$set(connectionline_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(edgerenderer.$$.fragment, local2);
      transition_in(connectionline.$$.fragment, local2);
      transition_in(noderenderer.$$.fragment, local2);
      transition_in(nodeselection.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgerenderer.$$.fragment, local2);
      transition_out(connectionline.$$.fragment, local2);
      transition_out(noderenderer.$$.fragment, local2);
      transition_out(nodeselection.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(div);
        detach_dev(t22);
        detach_dev(t32);
      }
      destroy_component(edgerenderer, detaching);
      destroy_component(connectionline, detaching);
      destroy_component(noderenderer, detaching);
      destroy_component(nodeselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(178:6) <ViewportComponent>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let viewportcomponent;
  let t;
  let userselection;
  let current;
  viewportcomponent = new Viewport_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  userselection = new UserSelection_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(viewportcomponent.$$.fragment);
      t = space();
      create_component(userselection.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(viewportcomponent, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(userselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const viewportcomponent_changes = {};
      if (dirty[0] & /*connectionLineContainerStyle, connectionLineStyle, $$slots, defaultEdgeOptions*/
      1075839168 | dirty[2] & /*$$scope*/
      1048576) {
        viewportcomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewportcomponent.$set(viewportcomponent_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(viewportcomponent.$$.fragment, local2);
      transition_in(userselection.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(viewportcomponent.$$.fragment, local2);
      transition_out(userselection.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(viewportcomponent, detaching);
      destroy_component(userselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(177:4) <Pane on:paneclick panOnDrag={panOnDrag === undefined ? true : panOnDrag} {selectionOnDrag}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let pane;
  let current;
  pane = new Pane_default({
    props: {
      panOnDrag: (
        /*panOnDrag*/
        ctx[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx[17]
        )
      ),
      selectionOnDrag: (
        /*selectionOnDrag*/
        ctx[18]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pane.$on(
    "paneclick",
    /*paneclick_handler*/
    ctx[79]
  );
  const block = {
    c: function create2() {
      create_component(pane.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(pane, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pane_changes = {};
      if (dirty[0] & /*panOnDrag*/
      131072)
        pane_changes.panOnDrag = /*panOnDrag*/
        ctx2[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx2[17]
        );
      if (dirty[0] & /*selectionOnDrag*/
      262144)
        pane_changes.selectionOnDrag = /*selectionOnDrag*/
        ctx2[18];
      if (dirty[0] & /*connectionLineContainerStyle, connectionLineStyle, $$slots, defaultEdgeOptions*/
      1075839168 | dirty[2] & /*$$scope*/
      1048576) {
        pane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane.$set(pane_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(pane.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(pane.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pane, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(164:2) <Zoom     {initialViewport}     {onMoveStart}     {onMove}     {onMoveEnd}     panOnScrollMode={panOnScrollMode === undefined ? PanOnScrollMode.Free : panOnScrollMode}     preventScrolling={preventScrolling === undefined ? true : preventScrolling}     zoomOnScroll={zoomOnScroll === undefined ? true : zoomOnScroll}     zoomOnDoubleClick={zoomOnDoubleClick === undefined ? true : zoomOnDoubleClick}     zoomOnPinch={zoomOnPinch === undefined ? true : zoomOnPinch}     panOnScroll={panOnScroll === undefined ? false : panOnScroll}     panOnDrag={panOnDrag === undefined ? true : panOnDrag}   >",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let div;
  let keyhandler;
  let t02;
  let zoom2;
  let t12;
  let attribution;
  let t22;
  let div_class_value;
  let div_resize_listener;
  let current;
  let mounted;
  let dispose;
  keyhandler = new KeyHandler_default({
    props: {
      selectionKey: (
        /*selectionKey*/
        ctx[1]
      ),
      deleteKey: (
        /*deleteKey*/
        ctx[5]
      ),
      panActivationKey: (
        /*panActivationKey*/
        ctx[2]
      ),
      multiSelectionKey: (
        /*multiSelectionKey*/
        ctx[3]
      ),
      zoomActivationKey: (
        /*zoomActivationKey*/
        ctx[4]
      )
    },
    $$inline: true
  });
  zoom2 = new Zoom_default({
    props: {
      initialViewport: (
        /*initialViewport*/
        ctx[0]
      ),
      onMoveStart: (
        /*onMoveStart*/
        ctx[8]
      ),
      onMove: (
        /*onMove*/
        ctx[9]
      ),
      onMoveEnd: (
        /*onMoveEnd*/
        ctx[10]
      ),
      panOnScrollMode: (
        /*panOnScrollMode*/
        ctx[11] === void 0 ? PanOnScrollMode.Free : (
          /*panOnScrollMode*/
          ctx[11]
        )
      ),
      preventScrolling: (
        /*preventScrolling*/
        ctx[12] === void 0 ? true : (
          /*preventScrolling*/
          ctx[12]
        )
      ),
      zoomOnScroll: (
        /*zoomOnScroll*/
        ctx[13] === void 0 ? true : (
          /*zoomOnScroll*/
          ctx[13]
        )
      ),
      zoomOnDoubleClick: (
        /*zoomOnDoubleClick*/
        ctx[14] === void 0 ? true : (
          /*zoomOnDoubleClick*/
          ctx[14]
        )
      ),
      zoomOnPinch: (
        /*zoomOnPinch*/
        ctx[15] === void 0 ? true : (
          /*zoomOnPinch*/
          ctx[15]
        )
      ),
      panOnScroll: (
        /*panOnScroll*/
        ctx[16] === void 0 ? false : (
          /*panOnScroll*/
          ctx[16]
        )
      ),
      panOnDrag: (
        /*panOnDrag*/
        ctx[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx[17]
        )
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  attribution = new Attribution_default({
    props: {
      proOptions: (
        /*proOptions*/
        ctx[20]
      ),
      position: (
        /*attributionPosition*/
        ctx[19]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[61].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    null
  );
  let div_levels = [
    { style: (
      /*style*/
      ctx[22]
    ) },
    {
      class: div_class_value = cc([
        "svelte-flow",
        /*className*/
        ctx[23],
        /*$colorModeClass*/
        ctx[28]
      ])
    },
    { "data-testid": "svelte-flow__wrapper" },
    /*$$restProps*/
    ctx[29],
    { role: "application" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create2() {
      div = element("div");
      create_component(keyhandler.$$.fragment);
      t02 = space();
      create_component(zoom2.$$.fragment);
      t12 = space();
      create_component(attribution.$$.fragment);
      t22 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[81].call(div)
      ));
      toggle_class(div, "svelte-12wlba6", true);
      add_location(div, file18, 169, 0, 4261);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(keyhandler, div, null);
      append_dev(div, t02);
      mount_component(zoom2, div, null);
      append_dev(div, t12);
      mount_component(attribution, div, null);
      append_dev(div, t22);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[80](div);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[81].bind(div)
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "dragover",
            /*dragover_handler*/
            ctx[62],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "drop",
            /*drop_handler*/
            ctx[63],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const keyhandler_changes = {};
      if (dirty[0] & /*selectionKey*/
      2)
        keyhandler_changes.selectionKey = /*selectionKey*/
        ctx2[1];
      if (dirty[0] & /*deleteKey*/
      32)
        keyhandler_changes.deleteKey = /*deleteKey*/
        ctx2[5];
      if (dirty[0] & /*panActivationKey*/
      4)
        keyhandler_changes.panActivationKey = /*panActivationKey*/
        ctx2[2];
      if (dirty[0] & /*multiSelectionKey*/
      8)
        keyhandler_changes.multiSelectionKey = /*multiSelectionKey*/
        ctx2[3];
      if (dirty[0] & /*zoomActivationKey*/
      16)
        keyhandler_changes.zoomActivationKey = /*zoomActivationKey*/
        ctx2[4];
      keyhandler.$set(keyhandler_changes);
      const zoom_changes = {};
      if (dirty[0] & /*initialViewport*/
      1)
        zoom_changes.initialViewport = /*initialViewport*/
        ctx2[0];
      if (dirty[0] & /*onMoveStart*/
      256)
        zoom_changes.onMoveStart = /*onMoveStart*/
        ctx2[8];
      if (dirty[0] & /*onMove*/
      512)
        zoom_changes.onMove = /*onMove*/
        ctx2[9];
      if (dirty[0] & /*onMoveEnd*/
      1024)
        zoom_changes.onMoveEnd = /*onMoveEnd*/
        ctx2[10];
      if (dirty[0] & /*panOnScrollMode*/
      2048)
        zoom_changes.panOnScrollMode = /*panOnScrollMode*/
        ctx2[11] === void 0 ? PanOnScrollMode.Free : (
          /*panOnScrollMode*/
          ctx2[11]
        );
      if (dirty[0] & /*preventScrolling*/
      4096)
        zoom_changes.preventScrolling = /*preventScrolling*/
        ctx2[12] === void 0 ? true : (
          /*preventScrolling*/
          ctx2[12]
        );
      if (dirty[0] & /*zoomOnScroll*/
      8192)
        zoom_changes.zoomOnScroll = /*zoomOnScroll*/
        ctx2[13] === void 0 ? true : (
          /*zoomOnScroll*/
          ctx2[13]
        );
      if (dirty[0] & /*zoomOnDoubleClick*/
      16384)
        zoom_changes.zoomOnDoubleClick = /*zoomOnDoubleClick*/
        ctx2[14] === void 0 ? true : (
          /*zoomOnDoubleClick*/
          ctx2[14]
        );
      if (dirty[0] & /*zoomOnPinch*/
      32768)
        zoom_changes.zoomOnPinch = /*zoomOnPinch*/
        ctx2[15] === void 0 ? true : (
          /*zoomOnPinch*/
          ctx2[15]
        );
      if (dirty[0] & /*panOnScroll*/
      65536)
        zoom_changes.panOnScroll = /*panOnScroll*/
        ctx2[16] === void 0 ? false : (
          /*panOnScroll*/
          ctx2[16]
        );
      if (dirty[0] & /*panOnDrag*/
      131072)
        zoom_changes.panOnDrag = /*panOnDrag*/
        ctx2[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx2[17]
        );
      if (dirty[0] & /*panOnDrag, selectionOnDrag, connectionLineContainerStyle, connectionLineStyle, $$slots, defaultEdgeOptions*/
      1076232384 | dirty[2] & /*$$scope*/
      1048576) {
        zoom_changes.$$scope = { dirty, ctx: ctx2 };
      }
      zoom2.$set(zoom_changes);
      const attribution_changes = {};
      if (dirty[0] & /*proOptions*/
      1048576)
        attribution_changes.proOptions = /*proOptions*/
        ctx2[20];
      if (dirty[0] & /*attributionPosition*/
      524288)
        attribution_changes.position = /*attributionPosition*/
        ctx2[19];
      attribution.$set(attribution_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*style*/
        4194304) && { style: (
          /*style*/
          ctx2[22]
        ) },
        (!current || dirty[0] & /*className, $colorModeClass*/
        276824064 && div_class_value !== (div_class_value = cc([
          "svelte-flow",
          /*className*/
          ctx2[23],
          /*$colorModeClass*/
          ctx2[28]
        ]))) && { class: div_class_value },
        { "data-testid": "svelte-flow__wrapper" },
        dirty[0] & /*$$restProps*/
        536870912 && /*$$restProps*/
        ctx2[29],
        { role: "application" }
      ]));
      toggle_class(div, "svelte-12wlba6", true);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(keyhandler.$$.fragment, local2);
      transition_in(zoom2.$$.fragment, local2);
      transition_in(attribution.$$.fragment, local2);
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(keyhandler.$$.fragment, local2);
      transition_out(zoom2.$$.fragment, local2);
      transition_out(attribution.$$.fragment, local2);
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(keyhandler);
      destroy_component(zoom2);
      destroy_component(attribution);
      if (default_slot)
        default_slot.d(detaching);
      ctx[80](null);
      div_resize_listener();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let colorModeClass;
  const omit_props_names = [
    "id",
    "nodes",
    "edges",
    "fitView",
    "fitViewOptions",
    "minZoom",
    "maxZoom",
    "initialViewport",
    "viewport",
    "nodeTypes",
    "edgeTypes",
    "selectionKey",
    "selectionMode",
    "panActivationKey",
    "multiSelectionKey",
    "zoomActivationKey",
    "nodesDraggable",
    "nodesConnectable",
    "nodeDragThreshold",
    "elementsSelectable",
    "snapGrid",
    "deleteKey",
    "connectionRadius",
    "connectionLineType",
    "connectionMode",
    "connectionLineStyle",
    "connectionLineContainerStyle",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "isValidConnection",
    "translateExtent",
    "onlyRenderVisibleElements",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnScroll",
    "panOnDrag",
    "selectionOnDrag",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "onerror",
    "ondelete",
    "attributionPosition",
    "proOptions",
    "defaultEdgeOptions",
    "width",
    "height",
    "colorMode",
    "defaultMarkerColor",
    "style",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $colorModeClass, $$unsubscribe_colorModeClass = noop, $$subscribe_colorModeClass = () => ($$unsubscribe_colorModeClass(), $$unsubscribe_colorModeClass = subscribe(colorModeClass, ($$value) => $$invalidate(28, $colorModeClass = $$value)), colorModeClass);
  $$self.$$.on_destroy.push(() => $$unsubscribe_colorModeClass());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteFlow", slots, ["connectionLine", "default"]);
  const $$slots = compute_slots(slots);
  let { id: id2 = "1" } = $$props;
  let { nodes } = $$props;
  let { edges } = $$props;
  let { fitView: fitView2 = void 0 } = $$props;
  let { fitViewOptions = void 0 } = $$props;
  let { minZoom = void 0 } = $$props;
  let { maxZoom = void 0 } = $$props;
  let { initialViewport = { x: 0, y: 0, zoom: 1 } } = $$props;
  let { viewport = void 0 } = $$props;
  let { nodeTypes = void 0 } = $$props;
  let { edgeTypes = void 0 } = $$props;
  let { selectionKey = void 0 } = $$props;
  let { selectionMode = void 0 } = $$props;
  let { panActivationKey = void 0 } = $$props;
  let { multiSelectionKey = void 0 } = $$props;
  let { zoomActivationKey = void 0 } = $$props;
  let { nodesDraggable = void 0 } = $$props;
  let { nodesConnectable = void 0 } = $$props;
  let { nodeDragThreshold = void 0 } = $$props;
  let { elementsSelectable = void 0 } = $$props;
  let { snapGrid = void 0 } = $$props;
  let { deleteKey = void 0 } = $$props;
  let { connectionRadius = void 0 } = $$props;
  let { connectionLineType = void 0 } = $$props;
  let { connectionMode = ConnectionMode.Strict } = $$props;
  let { connectionLineStyle = "" } = $$props;
  let { connectionLineContainerStyle = "" } = $$props;
  let { onMoveStart = void 0 } = $$props;
  let { onMove = void 0 } = $$props;
  let { onMoveEnd = void 0 } = $$props;
  let { isValidConnection = void 0 } = $$props;
  let { translateExtent = void 0 } = $$props;
  let { onlyRenderVisibleElements = void 0 } = $$props;
  let { panOnScrollMode = PanOnScrollMode.Free } = $$props;
  let { preventScrolling = true } = $$props;
  let { zoomOnScroll = true } = $$props;
  let { zoomOnDoubleClick = true } = $$props;
  let { zoomOnPinch = true } = $$props;
  let { panOnScroll = false } = $$props;
  let { panOnDrag = true } = $$props;
  let { selectionOnDrag = void 0 } = $$props;
  let { autoPanOnConnect = true } = $$props;
  let { autoPanOnNodeDrag = true } = $$props;
  let { onerror = void 0 } = $$props;
  let { ondelete = void 0 } = $$props;
  let { attributionPosition = void 0 } = $$props;
  let { proOptions = void 0 } = $$props;
  let { defaultEdgeOptions = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { colorMode = "light" } = $$props;
  let { defaultMarkerColor = "#b1b1b7" } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let domNode;
  let clientWidth;
  let clientHeight;
  const store = hasContext(key) ? useStore() : createStoreContext({
    nodes: get_store_value(nodes),
    edges: get_store_value(edges),
    width,
    height,
    fitView: fitView2
  });
  onMount(() => {
    store.width.set(clientWidth);
    store.height.set(clientHeight);
    store.domNode.set(domNode);
    store.syncNodeStores(nodes);
    store.syncEdgeStores(edges);
    store.syncViewport(viewport);
    if (fitView2 !== void 0) {
      store.fitViewOnInit.set(fitView2);
    }
    if (fitViewOptions) {
      store.fitViewOptions.set(fitViewOptions);
    }
    updateStore(store, {
      nodeTypes,
      edgeTypes,
      minZoom,
      maxZoom,
      translateExtent
    });
    return () => {
      store.reset();
    };
  });
  $$self.$$.on_mount.push(function() {
    if (nodes === void 0 && !("nodes" in $$props || $$self.$$.bound[$$self.$$.props["nodes"]])) {
      console.warn("<SvelteFlow> was created without expected prop 'nodes'");
    }
    if (edges === void 0 && !("edges" in $$props || $$self.$$.bound[$$self.$$.props["edges"]])) {
      console.warn("<SvelteFlow> was created without expected prop 'edges'");
    }
  });
  function dragover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function drop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connect_handler(event) {
    bubble.call(this, $$self, event);
  }
  function connectend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectionclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectioncontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function paneclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domNode = $$value;
      $$invalidate(26, domNode);
    });
  }
  function div_elementresize_handler() {
    clientWidth = this.clientWidth;
    clientHeight = this.clientHeight;
    $$invalidate(24, clientWidth);
    $$invalidate(25, clientHeight);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(31, id2 = $$new_props.id);
    if ("nodes" in $$new_props)
      $$invalidate(32, nodes = $$new_props.nodes);
    if ("edges" in $$new_props)
      $$invalidate(33, edges = $$new_props.edges);
    if ("fitView" in $$new_props)
      $$invalidate(34, fitView2 = $$new_props.fitView);
    if ("fitViewOptions" in $$new_props)
      $$invalidate(35, fitViewOptions = $$new_props.fitViewOptions);
    if ("minZoom" in $$new_props)
      $$invalidate(36, minZoom = $$new_props.minZoom);
    if ("maxZoom" in $$new_props)
      $$invalidate(37, maxZoom = $$new_props.maxZoom);
    if ("initialViewport" in $$new_props)
      $$invalidate(0, initialViewport = $$new_props.initialViewport);
    if ("viewport" in $$new_props)
      $$invalidate(38, viewport = $$new_props.viewport);
    if ("nodeTypes" in $$new_props)
      $$invalidate(39, nodeTypes = $$new_props.nodeTypes);
    if ("edgeTypes" in $$new_props)
      $$invalidate(40, edgeTypes = $$new_props.edgeTypes);
    if ("selectionKey" in $$new_props)
      $$invalidate(1, selectionKey = $$new_props.selectionKey);
    if ("selectionMode" in $$new_props)
      $$invalidate(41, selectionMode = $$new_props.selectionMode);
    if ("panActivationKey" in $$new_props)
      $$invalidate(2, panActivationKey = $$new_props.panActivationKey);
    if ("multiSelectionKey" in $$new_props)
      $$invalidate(3, multiSelectionKey = $$new_props.multiSelectionKey);
    if ("zoomActivationKey" in $$new_props)
      $$invalidate(4, zoomActivationKey = $$new_props.zoomActivationKey);
    if ("nodesDraggable" in $$new_props)
      $$invalidate(42, nodesDraggable = $$new_props.nodesDraggable);
    if ("nodesConnectable" in $$new_props)
      $$invalidate(43, nodesConnectable = $$new_props.nodesConnectable);
    if ("nodeDragThreshold" in $$new_props)
      $$invalidate(44, nodeDragThreshold = $$new_props.nodeDragThreshold);
    if ("elementsSelectable" in $$new_props)
      $$invalidate(45, elementsSelectable = $$new_props.elementsSelectable);
    if ("snapGrid" in $$new_props)
      $$invalidate(46, snapGrid = $$new_props.snapGrid);
    if ("deleteKey" in $$new_props)
      $$invalidate(5, deleteKey = $$new_props.deleteKey);
    if ("connectionRadius" in $$new_props)
      $$invalidate(47, connectionRadius = $$new_props.connectionRadius);
    if ("connectionLineType" in $$new_props)
      $$invalidate(48, connectionLineType = $$new_props.connectionLineType);
    if ("connectionMode" in $$new_props)
      $$invalidate(49, connectionMode = $$new_props.connectionMode);
    if ("connectionLineStyle" in $$new_props)
      $$invalidate(6, connectionLineStyle = $$new_props.connectionLineStyle);
    if ("connectionLineContainerStyle" in $$new_props)
      $$invalidate(7, connectionLineContainerStyle = $$new_props.connectionLineContainerStyle);
    if ("onMoveStart" in $$new_props)
      $$invalidate(8, onMoveStart = $$new_props.onMoveStart);
    if ("onMove" in $$new_props)
      $$invalidate(9, onMove = $$new_props.onMove);
    if ("onMoveEnd" in $$new_props)
      $$invalidate(10, onMoveEnd = $$new_props.onMoveEnd);
    if ("isValidConnection" in $$new_props)
      $$invalidate(50, isValidConnection = $$new_props.isValidConnection);
    if ("translateExtent" in $$new_props)
      $$invalidate(51, translateExtent = $$new_props.translateExtent);
    if ("onlyRenderVisibleElements" in $$new_props)
      $$invalidate(52, onlyRenderVisibleElements = $$new_props.onlyRenderVisibleElements);
    if ("panOnScrollMode" in $$new_props)
      $$invalidate(11, panOnScrollMode = $$new_props.panOnScrollMode);
    if ("preventScrolling" in $$new_props)
      $$invalidate(12, preventScrolling = $$new_props.preventScrolling);
    if ("zoomOnScroll" in $$new_props)
      $$invalidate(13, zoomOnScroll = $$new_props.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$new_props)
      $$invalidate(14, zoomOnDoubleClick = $$new_props.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$new_props)
      $$invalidate(15, zoomOnPinch = $$new_props.zoomOnPinch);
    if ("panOnScroll" in $$new_props)
      $$invalidate(16, panOnScroll = $$new_props.panOnScroll);
    if ("panOnDrag" in $$new_props)
      $$invalidate(17, panOnDrag = $$new_props.panOnDrag);
    if ("selectionOnDrag" in $$new_props)
      $$invalidate(18, selectionOnDrag = $$new_props.selectionOnDrag);
    if ("autoPanOnConnect" in $$new_props)
      $$invalidate(53, autoPanOnConnect = $$new_props.autoPanOnConnect);
    if ("autoPanOnNodeDrag" in $$new_props)
      $$invalidate(54, autoPanOnNodeDrag = $$new_props.autoPanOnNodeDrag);
    if ("onerror" in $$new_props)
      $$invalidate(55, onerror = $$new_props.onerror);
    if ("ondelete" in $$new_props)
      $$invalidate(56, ondelete = $$new_props.ondelete);
    if ("attributionPosition" in $$new_props)
      $$invalidate(19, attributionPosition = $$new_props.attributionPosition);
    if ("proOptions" in $$new_props)
      $$invalidate(20, proOptions = $$new_props.proOptions);
    if ("defaultEdgeOptions" in $$new_props)
      $$invalidate(21, defaultEdgeOptions = $$new_props.defaultEdgeOptions);
    if ("width" in $$new_props)
      $$invalidate(57, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(58, height = $$new_props.height);
    if ("colorMode" in $$new_props)
      $$invalidate(59, colorMode = $$new_props.colorMode);
    if ("defaultMarkerColor" in $$new_props)
      $$invalidate(60, defaultMarkerColor = $$new_props.defaultMarkerColor);
    if ("style" in $$new_props)
      $$invalidate(22, style = $$new_props.style);
    if ("class" in $$new_props)
      $$invalidate(23, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(82, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    hasContext,
    cc,
    ConnectionMode,
    PanOnScrollMode,
    Zoom: Zoom_default,
    Pane: Pane_default,
    ViewportComponent: Viewport_default,
    NodeRenderer: NodeRenderer_default,
    EdgeRenderer: EdgeRenderer_default,
    UserSelection: UserSelection_default,
    NodeSelection: NodeSelection_default,
    KeyHandler: KeyHandler_default,
    ConnectionLine: ConnectionLine_default,
    Attribution: Attribution_default,
    key,
    useStore,
    createStoreContext,
    updateStore,
    updateStoreByKeys,
    getColorModeClass,
    get: get_store_value,
    useColorModeClass,
    id: id2,
    nodes,
    edges,
    fitView: fitView2,
    fitViewOptions,
    minZoom,
    maxZoom,
    initialViewport,
    viewport,
    nodeTypes,
    edgeTypes,
    selectionKey,
    selectionMode,
    panActivationKey,
    multiSelectionKey,
    zoomActivationKey,
    nodesDraggable,
    nodesConnectable,
    nodeDragThreshold,
    elementsSelectable,
    snapGrid,
    deleteKey,
    connectionRadius,
    connectionLineType,
    connectionMode,
    connectionLineStyle,
    connectionLineContainerStyle,
    onMoveStart,
    onMove,
    onMoveEnd,
    isValidConnection,
    translateExtent,
    onlyRenderVisibleElements,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnScroll,
    panOnDrag,
    selectionOnDrag,
    autoPanOnConnect,
    autoPanOnNodeDrag,
    onerror,
    ondelete,
    attributionPosition,
    proOptions,
    defaultEdgeOptions,
    width,
    height,
    colorMode,
    defaultMarkerColor,
    style,
    className,
    domNode,
    clientWidth,
    clientHeight,
    store,
    colorModeClass,
    $colorModeClass
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(31, id2 = $$new_props.id);
    if ("nodes" in $$props)
      $$invalidate(32, nodes = $$new_props.nodes);
    if ("edges" in $$props)
      $$invalidate(33, edges = $$new_props.edges);
    if ("fitView" in $$props)
      $$invalidate(34, fitView2 = $$new_props.fitView);
    if ("fitViewOptions" in $$props)
      $$invalidate(35, fitViewOptions = $$new_props.fitViewOptions);
    if ("minZoom" in $$props)
      $$invalidate(36, minZoom = $$new_props.minZoom);
    if ("maxZoom" in $$props)
      $$invalidate(37, maxZoom = $$new_props.maxZoom);
    if ("initialViewport" in $$props)
      $$invalidate(0, initialViewport = $$new_props.initialViewport);
    if ("viewport" in $$props)
      $$invalidate(38, viewport = $$new_props.viewport);
    if ("nodeTypes" in $$props)
      $$invalidate(39, nodeTypes = $$new_props.nodeTypes);
    if ("edgeTypes" in $$props)
      $$invalidate(40, edgeTypes = $$new_props.edgeTypes);
    if ("selectionKey" in $$props)
      $$invalidate(1, selectionKey = $$new_props.selectionKey);
    if ("selectionMode" in $$props)
      $$invalidate(41, selectionMode = $$new_props.selectionMode);
    if ("panActivationKey" in $$props)
      $$invalidate(2, panActivationKey = $$new_props.panActivationKey);
    if ("multiSelectionKey" in $$props)
      $$invalidate(3, multiSelectionKey = $$new_props.multiSelectionKey);
    if ("zoomActivationKey" in $$props)
      $$invalidate(4, zoomActivationKey = $$new_props.zoomActivationKey);
    if ("nodesDraggable" in $$props)
      $$invalidate(42, nodesDraggable = $$new_props.nodesDraggable);
    if ("nodesConnectable" in $$props)
      $$invalidate(43, nodesConnectable = $$new_props.nodesConnectable);
    if ("nodeDragThreshold" in $$props)
      $$invalidate(44, nodeDragThreshold = $$new_props.nodeDragThreshold);
    if ("elementsSelectable" in $$props)
      $$invalidate(45, elementsSelectable = $$new_props.elementsSelectable);
    if ("snapGrid" in $$props)
      $$invalidate(46, snapGrid = $$new_props.snapGrid);
    if ("deleteKey" in $$props)
      $$invalidate(5, deleteKey = $$new_props.deleteKey);
    if ("connectionRadius" in $$props)
      $$invalidate(47, connectionRadius = $$new_props.connectionRadius);
    if ("connectionLineType" in $$props)
      $$invalidate(48, connectionLineType = $$new_props.connectionLineType);
    if ("connectionMode" in $$props)
      $$invalidate(49, connectionMode = $$new_props.connectionMode);
    if ("connectionLineStyle" in $$props)
      $$invalidate(6, connectionLineStyle = $$new_props.connectionLineStyle);
    if ("connectionLineContainerStyle" in $$props)
      $$invalidate(7, connectionLineContainerStyle = $$new_props.connectionLineContainerStyle);
    if ("onMoveStart" in $$props)
      $$invalidate(8, onMoveStart = $$new_props.onMoveStart);
    if ("onMove" in $$props)
      $$invalidate(9, onMove = $$new_props.onMove);
    if ("onMoveEnd" in $$props)
      $$invalidate(10, onMoveEnd = $$new_props.onMoveEnd);
    if ("isValidConnection" in $$props)
      $$invalidate(50, isValidConnection = $$new_props.isValidConnection);
    if ("translateExtent" in $$props)
      $$invalidate(51, translateExtent = $$new_props.translateExtent);
    if ("onlyRenderVisibleElements" in $$props)
      $$invalidate(52, onlyRenderVisibleElements = $$new_props.onlyRenderVisibleElements);
    if ("panOnScrollMode" in $$props)
      $$invalidate(11, panOnScrollMode = $$new_props.panOnScrollMode);
    if ("preventScrolling" in $$props)
      $$invalidate(12, preventScrolling = $$new_props.preventScrolling);
    if ("zoomOnScroll" in $$props)
      $$invalidate(13, zoomOnScroll = $$new_props.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props)
      $$invalidate(14, zoomOnDoubleClick = $$new_props.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props)
      $$invalidate(15, zoomOnPinch = $$new_props.zoomOnPinch);
    if ("panOnScroll" in $$props)
      $$invalidate(16, panOnScroll = $$new_props.panOnScroll);
    if ("panOnDrag" in $$props)
      $$invalidate(17, panOnDrag = $$new_props.panOnDrag);
    if ("selectionOnDrag" in $$props)
      $$invalidate(18, selectionOnDrag = $$new_props.selectionOnDrag);
    if ("autoPanOnConnect" in $$props)
      $$invalidate(53, autoPanOnConnect = $$new_props.autoPanOnConnect);
    if ("autoPanOnNodeDrag" in $$props)
      $$invalidate(54, autoPanOnNodeDrag = $$new_props.autoPanOnNodeDrag);
    if ("onerror" in $$props)
      $$invalidate(55, onerror = $$new_props.onerror);
    if ("ondelete" in $$props)
      $$invalidate(56, ondelete = $$new_props.ondelete);
    if ("attributionPosition" in $$props)
      $$invalidate(19, attributionPosition = $$new_props.attributionPosition);
    if ("proOptions" in $$props)
      $$invalidate(20, proOptions = $$new_props.proOptions);
    if ("defaultEdgeOptions" in $$props)
      $$invalidate(21, defaultEdgeOptions = $$new_props.defaultEdgeOptions);
    if ("width" in $$props)
      $$invalidate(57, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(58, height = $$new_props.height);
    if ("colorMode" in $$props)
      $$invalidate(59, colorMode = $$new_props.colorMode);
    if ("defaultMarkerColor" in $$props)
      $$invalidate(60, defaultMarkerColor = $$new_props.defaultMarkerColor);
    if ("style" in $$props)
      $$invalidate(22, style = $$new_props.style);
    if ("className" in $$props)
      $$invalidate(23, className = $$new_props.className);
    if ("domNode" in $$props)
      $$invalidate(26, domNode = $$new_props.domNode);
    if ("clientWidth" in $$props)
      $$invalidate(24, clientWidth = $$new_props.clientWidth);
    if ("clientHeight" in $$props)
      $$invalidate(25, clientHeight = $$new_props.clientHeight);
    if ("colorModeClass" in $$props)
      $$subscribe_colorModeClass($$invalidate(27, colorModeClass = $$new_props.colorModeClass));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*clientWidth, clientHeight*/
    50331648) {
      $: {
        if (clientWidth !== void 0 && clientHeight !== void 0) {
          store.width.set(clientWidth);
          store.height.set(clientHeight);
        }
      }
    }
    if ($$self.$$.dirty[1] & /*id, connectionLineType, connectionRadius, selectionMode, snapGrid, defaultMarkerColor, nodesDraggable, nodesConnectable, elementsSelectable, onlyRenderVisibleElements, isValidConnection, autoPanOnConnect, autoPanOnNodeDrag, onerror, ondelete, connectionMode, nodeDragThreshold*/
    602930177) {
      $: {
        const updatableProps = {
          flowId: id2,
          connectionLineType,
          connectionRadius,
          selectionMode,
          snapGrid,
          defaultMarkerColor,
          nodesDraggable,
          nodesConnectable,
          elementsSelectable,
          onlyRenderVisibleElements,
          isValidConnection,
          autoPanOnConnect,
          autoPanOnNodeDrag,
          onerror,
          ondelete,
          connectionMode,
          nodeDragThreshold
        };
        updateStoreByKeys(store, updatableProps);
      }
    }
    if ($$self.$$.dirty[1] & /*nodeTypes, edgeTypes, minZoom, maxZoom, translateExtent*/
    1049440) {
      $:
        updateStore(store, {
          nodeTypes,
          edgeTypes,
          minZoom,
          maxZoom,
          translateExtent
        });
    }
    if ($$self.$$.dirty[1] & /*colorMode*/
    268435456) {
      $:
        $$subscribe_colorModeClass($$invalidate(27, colorModeClass = useColorModeClass(colorMode)));
    }
  };
  return [
    initialViewport,
    selectionKey,
    panActivationKey,
    multiSelectionKey,
    zoomActivationKey,
    deleteKey,
    connectionLineStyle,
    connectionLineContainerStyle,
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnScroll,
    panOnDrag,
    selectionOnDrag,
    attributionPosition,
    proOptions,
    defaultEdgeOptions,
    style,
    className,
    clientWidth,
    clientHeight,
    domNode,
    colorModeClass,
    $colorModeClass,
    $$restProps,
    $$slots,
    id2,
    nodes,
    edges,
    fitView2,
    fitViewOptions,
    minZoom,
    maxZoom,
    viewport,
    nodeTypes,
    edgeTypes,
    selectionMode,
    nodesDraggable,
    nodesConnectable,
    nodeDragThreshold,
    elementsSelectable,
    snapGrid,
    connectionRadius,
    connectionLineType,
    connectionMode,
    isValidConnection,
    translateExtent,
    onlyRenderVisibleElements,
    autoPanOnConnect,
    autoPanOnNodeDrag,
    onerror,
    ondelete,
    width,
    height,
    colorMode,
    defaultMarkerColor,
    slots,
    dragover_handler,
    drop_handler,
    edgeclick_handler,
    edgecontextmenu_handler,
    nodeclick_handler,
    nodemouseenter_handler,
    nodemousemove_handler,
    nodemouseleave_handler,
    connectstart_handler,
    connect_handler,
    connectend_handler,
    nodedragstart_handler,
    nodedrag_handler,
    nodedragstop_handler,
    nodecontextmenu_handler,
    selectionclick_handler,
    selectioncontextmenu_handler,
    paneclick_handler,
    div_binding,
    div_elementresize_handler,
    $$scope
  ];
}
var SvelteFlow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance28,
      create_fragment28,
      safe_not_equal,
      {
        id: 31,
        nodes: 32,
        edges: 33,
        fitView: 34,
        fitViewOptions: 35,
        minZoom: 36,
        maxZoom: 37,
        initialViewport: 0,
        viewport: 38,
        nodeTypes: 39,
        edgeTypes: 40,
        selectionKey: 1,
        selectionMode: 41,
        panActivationKey: 2,
        multiSelectionKey: 3,
        zoomActivationKey: 4,
        nodesDraggable: 42,
        nodesConnectable: 43,
        nodeDragThreshold: 44,
        elementsSelectable: 45,
        snapGrid: 46,
        deleteKey: 5,
        connectionRadius: 47,
        connectionLineType: 48,
        connectionMode: 49,
        connectionLineStyle: 6,
        connectionLineContainerStyle: 7,
        onMoveStart: 8,
        onMove: 9,
        onMoveEnd: 10,
        isValidConnection: 50,
        translateExtent: 51,
        onlyRenderVisibleElements: 52,
        panOnScrollMode: 11,
        preventScrolling: 12,
        zoomOnScroll: 13,
        zoomOnDoubleClick: 14,
        zoomOnPinch: 15,
        panOnScroll: 16,
        panOnDrag: 17,
        selectionOnDrag: 18,
        autoPanOnConnect: 53,
        autoPanOnNodeDrag: 54,
        onerror: 55,
        ondelete: 56,
        attributionPosition: 19,
        proOptions: 20,
        defaultEdgeOptions: 21,
        width: 57,
        height: 58,
        colorMode: 59,
        defaultMarkerColor: 60,
        style: 22,
        class: 23
      },
      add_css8,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteFlow",
      options,
      id: create_fragment28.name
    });
  }
  get id() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edges() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edges(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitView() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitView(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitViewOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitViewOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minZoom() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minZoom(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxZoom() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxZoom(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialViewport() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialViewport(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewport() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewport(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeTypes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeTypes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edgeTypes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edgeTypes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panActivationKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panActivationKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectionKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectionKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomActivationKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomActivationKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodesDraggable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesDraggable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodesConnectable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesConnectable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeDragThreshold() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeDragThreshold(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elementsSelectable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elementsSelectable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get snapGrid() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set snapGrid(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionRadius() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionRadius(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineType() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineType(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineStyle() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineStyle(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineContainerStyle() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineContainerStyle(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveStart() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveStart(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMove() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMove(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveEnd() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveEnd(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isValidConnection() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isValidConnection(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateExtent() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateExtent(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onlyRenderVisibleElements() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onlyRenderVisibleElements(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScrollMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScrollMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScrolling() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScrolling(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnScroll() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnScroll(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnDoubleClick() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnDoubleClick(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnPinch() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnPinch(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScroll() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScroll(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionOnDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionOnDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPanOnConnect() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPanOnConnect(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPanOnNodeDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPanOnNodeDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onerror() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onerror(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ondelete() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ondelete(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attributionPosition() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributionPosition(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get proOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set proOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultEdgeOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultEdgeOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultMarkerColor() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultMarkerColor(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteFlow_default = SvelteFlow;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte
function create_fragment29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create2() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteFlowProvider", slots, ["default"]);
  let { initialNodes = void 0 } = $$props;
  let { initialEdges = void 0 } = $$props;
  let { initialWidth = void 0 } = $$props;
  let { initialHeight = void 0 } = $$props;
  let { fitView: fitView2 = void 0 } = $$props;
  const store = createStore({
    nodes: initialNodes,
    edges: initialEdges,
    width: initialWidth,
    height: initialHeight,
    fitView: fitView2
  });
  setContext(key, { getStore: () => store });
  onDestroy(() => {
    store.reset();
  });
  const writable_props = ["initialNodes", "initialEdges", "initialWidth", "initialHeight", "fitView"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<SvelteFlowProvider> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("initialNodes" in $$props2)
      $$invalidate(0, initialNodes = $$props2.initialNodes);
    if ("initialEdges" in $$props2)
      $$invalidate(1, initialEdges = $$props2.initialEdges);
    if ("initialWidth" in $$props2)
      $$invalidate(2, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2)
      $$invalidate(3, initialHeight = $$props2.initialHeight);
    if ("fitView" in $$props2)
      $$invalidate(4, fitView2 = $$props2.fitView);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    setContext,
    createStore,
    key,
    initialNodes,
    initialEdges,
    initialWidth,
    initialHeight,
    fitView: fitView2,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("initialNodes" in $$props2)
      $$invalidate(0, initialNodes = $$props2.initialNodes);
    if ("initialEdges" in $$props2)
      $$invalidate(1, initialEdges = $$props2.initialEdges);
    if ("initialWidth" in $$props2)
      $$invalidate(2, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2)
      $$invalidate(3, initialHeight = $$props2.initialHeight);
    if ("fitView" in $$props2)
      $$invalidate(4, fitView2 = $$props2.fitView);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    initialNodes,
    initialEdges,
    initialWidth,
    initialHeight,
    fitView2,
    $$scope,
    slots
  ];
}
var SvelteFlowProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      initialNodes: 0,
      initialEdges: 1,
      initialWidth: 2,
      initialHeight: 3,
      fitView: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteFlowProvider",
      options,
      id: create_fragment29.name
    });
  }
  get initialNodes() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialNodes(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialEdges() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialEdges(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialWidth() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialWidth(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialHeight() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialHeight(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitView() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitView(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteFlowProvider_default = SvelteFlowProvider;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte
var file19 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte";
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ class: "button-svg" });
function create_fragment30(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context
  );
  let button_levels = [
    { type: "button" },
    {
      class: button_class_value = cc([
        "svelte-flow__controls-button",
        /*className*/
        ctx[0]
      ])
    },
    /*$$restProps*/
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create2() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
      set_style(
        button,
        "--controls-button-background-color-props",
        /*bgColor*/
        ctx[1]
      );
      set_style(
        button,
        "--controls-button-background-color-hover-props",
        /*bgColorHover*/
        ctx[2]
      );
      set_style(
        button,
        "--controls-button-color-props",
        /*color*/
        ctx[3]
      );
      set_style(
        button,
        "--controls-button-color-hover-props",
        /*colorHover*/
        ctx[4]
      );
      set_style(
        button,
        "--controls-button-border-color-props",
        /*borderColor*/
        ctx[5]
      );
      add_location(button, file19, 13, 0, 222);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*className*/
        1 && button_class_value !== (button_class_value = cc([
          "svelte-flow__controls-button",
          /*className*/
          ctx2[0]
        ]))) && { class: button_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      set_style(
        button,
        "--controls-button-background-color-props",
        /*bgColor*/
        ctx2[1]
      );
      set_style(
        button,
        "--controls-button-background-color-hover-props",
        /*bgColorHover*/
        ctx2[2]
      );
      set_style(
        button,
        "--controls-button-color-props",
        /*color*/
        ctx2[3]
      );
      set_style(
        button,
        "--controls-button-color-hover-props",
        /*colorHover*/
        ctx2[4]
      );
      set_style(
        button,
        "--controls-button-border-color-props",
        /*borderColor*/
        ctx2[5]
      );
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ControlButton", slots, ["default"]);
  let { class: className } = $$props;
  let bgColor = void 0;
  let bgColorHover = void 0;
  let color2 = void 0;
  let colorHover = void 0;
  let borderColor = void 0;
  $$self.$$.on_mount.push(function() {
    if (className === void 0 && !("class" in $$props || $$self.$$.bound[$$self.$$.props["class"]])) {
      console.warn("<ControlButton> was created without expected prop 'class'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    className,
    bgColor,
    bgColorHover,
    color: color2,
    colorHover,
    borderColor
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("bgColor" in $$props)
      $$invalidate(1, bgColor = $$new_props.bgColor);
    if ("bgColorHover" in $$props)
      $$invalidate(2, bgColorHover = $$new_props.bgColorHover);
    if ("color" in $$props)
      $$invalidate(3, color2 = $$new_props.color);
    if ("colorHover" in $$props)
      $$invalidate(4, colorHover = $$new_props.colorHover);
    if ("borderColor" in $$props)
      $$invalidate(5, borderColor = $$new_props.borderColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    bgColor,
    bgColorHover,
    color2,
    colorHover,
    borderColor,
    $$restProps,
    $$scope,
    slots,
    click_handler
  ];
}
var ControlButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { class: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ControlButton",
      options,
      id: create_fragment30.name
    });
  }
  get class() {
    throw new Error("<ControlButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ControlButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ControlButton_default = ControlButton;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte
var file20 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte";
function create_fragment31(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z");
      add_location(path, file20, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 32");
      add_location(svg, file20, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Plus", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Plus> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Plus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Plus",
      options,
      id: create_fragment31.name
    });
  }
};
var Plus_default = Plus;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte
var file21 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte";
function create_fragment32(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M0 0h32v4.2H0z");
      add_location(path, file21, 1, 2, 62);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 5");
      add_location(svg, file21, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minus", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Minus> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Minus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minus",
      options,
      id: create_fragment32.name
    });
  }
};
var Minus_default = Minus;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte
var file22 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte";
function create_fragment33(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z");
      add_location(path, file22, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 30");
      add_location(svg, file22, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fit", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Fit> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Fit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fit",
      options,
      id: create_fragment33.name
    });
  }
};
var Fit_default = Fit;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte
var file23 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte";
function create_fragment34(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z");
      add_location(path, file23, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 25 32");
      add_location(svg, file23, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Lock", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Lock> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Lock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Lock",
      options,
      id: create_fragment34.name
    });
  }
};
var Lock_default = Lock;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte
var file24 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte";
function create_fragment35(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z");
      add_location(path, file24, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 25 32");
      add_location(svg, file24, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Unlock", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Unlock> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Unlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Unlock",
      options,
      id: create_fragment35.name
    });
  }
};
var Unlock_default = Unlock;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte
function create_if_block_3(ctx) {
  let controlbutton0;
  let t;
  let controlbutton1;
  let current;
  const controlbutton0_spread_levels = [
    { class: "svelte-flow__controls-zoomin" },
    { title: "zoom in" },
    { "aria-label": "zoom in" },
    { disabled: (
      /*maxZoomReached*/
      ctx[5]
    ) },
    /*buttonProps*/
    ctx[13]
  ];
  let controlbutton0_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton0_spread_levels.length; i += 1) {
    controlbutton0_props = assign(controlbutton0_props, controlbutton0_spread_levels[i]);
  }
  controlbutton0 = new ControlButton_default({
    props: controlbutton0_props,
    $$inline: true
  });
  controlbutton0.$on(
    "click",
    /*onZoomInHandler*/
    ctx[14]
  );
  const controlbutton1_spread_levels = [
    { class: "svelte-flow__controls-zoomout" },
    { title: "zoom out" },
    { "aria-label": "zoom out" },
    { disabled: (
      /*minZoomReached*/
      ctx[6]
    ) },
    /*buttonProps*/
    ctx[13]
  ];
  let controlbutton1_props = {
    $$slots: { default: [create_default_slot_3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton1_spread_levels.length; i += 1) {
    controlbutton1_props = assign(controlbutton1_props, controlbutton1_spread_levels[i]);
  }
  controlbutton1 = new ControlButton_default({
    props: controlbutton1_props,
    $$inline: true
  });
  controlbutton1.$on(
    "click",
    /*onZoomOutHandler*/
    ctx[15]
  );
  const block = {
    c: function create2() {
      create_component(controlbutton0.$$.fragment);
      t = space();
      create_component(controlbutton1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton0, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(controlbutton1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton0_changes = dirty[0] & /*maxZoomReached, buttonProps*/
      8224 ? get_spread_update(controlbutton0_spread_levels, [
        controlbutton0_spread_levels[0],
        controlbutton0_spread_levels[1],
        controlbutton0_spread_levels[2],
        dirty[0] & /*maxZoomReached*/
        32 && { disabled: (
          /*maxZoomReached*/
          ctx2[5]
        ) },
        dirty[0] & /*buttonProps*/
        8192 && get_spread_object(
          /*buttonProps*/
          ctx2[13]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2) {
        controlbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton0.$set(controlbutton0_changes);
      const controlbutton1_changes = dirty[0] & /*minZoomReached, buttonProps*/
      8256 ? get_spread_update(controlbutton1_spread_levels, [
        controlbutton1_spread_levels[0],
        controlbutton1_spread_levels[1],
        controlbutton1_spread_levels[2],
        dirty[0] & /*minZoomReached*/
        64 && { disabled: (
          /*minZoomReached*/
          ctx2[6]
        ) },
        dirty[0] & /*buttonProps*/
        8192 && get_spread_object(
          /*buttonProps*/
          ctx2[13]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2) {
        controlbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton1.$set(controlbutton1_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(controlbutton0.$$.fragment, local2);
      transition_in(controlbutton1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(controlbutton0.$$.fragment, local2);
      transition_out(controlbutton1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(controlbutton0, detaching);
      destroy_component(controlbutton1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(60:2) {#if showZoom}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let plusicon;
  let current;
  plusicon = new Plus_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(plusicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(plusicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(plusicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(plusicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(plusicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(61:4) <ControlButton       on:click={onZoomInHandler}       class=\\"svelte-flow__controls-zoomin\\"       title=\\"zoom in\\"       aria-label=\\"zoom in\\"       disabled={maxZoomReached}       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let minusicon;
  let current;
  minusicon = new Minus_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(minusicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(minusicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(minusicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(minusicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minusicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(71:4) <ControlButton       on:click={onZoomOutHandler}       class=\\"svelte-flow__controls-zoomout\\"       title=\\"zoom out\\"       aria-label=\\"zoom out\\"       disabled={minZoomReached}       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let controlbutton;
  let current;
  const controlbutton_spread_levels = [
    { class: "svelte-flow__controls-fitview" },
    { title: "fit view" },
    { "aria-label": "fit view" },
    /*buttonProps*/
    ctx[13]
  ];
  let controlbutton_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton_spread_levels.length; i += 1) {
    controlbutton_props = assign(controlbutton_props, controlbutton_spread_levels[i]);
  }
  controlbutton = new ControlButton_default({
    props: controlbutton_props,
    $$inline: true
  });
  controlbutton.$on(
    "click",
    /*onFitViewHandler*/
    ctx[16]
  );
  const block = {
    c: function create2() {
      create_component(controlbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton_changes = dirty[0] & /*buttonProps*/
      8192 ? get_spread_update(controlbutton_spread_levels, [
        controlbutton_spread_levels[0],
        controlbutton_spread_levels[1],
        controlbutton_spread_levels[2],
        get_spread_object(
          /*buttonProps*/
          ctx2[13]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2) {
        controlbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton.$set(controlbutton_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(controlbutton.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(controlbutton.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(controlbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(82:2) {#if showFitView}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let fitviewicon;
  let current;
  fitviewicon = new Fit_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(fitviewicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(fitviewicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(fitviewicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(fitviewicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(fitviewicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(83:4) <ControlButton       class=\\"svelte-flow__controls-fitview\\"       on:click={onFitViewHandler}       title=\\"fit view\\"       aria-label=\\"fit view\\"       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let controlbutton;
  let current;
  const controlbutton_spread_levels = [
    {
      class: "svelte-flow__controls-interactive"
    },
    { title: "toggle interactivity" },
    { "aria-label": "toggle interactivity" },
    /*buttonProps*/
    ctx[13]
  ];
  let controlbutton_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton_spread_levels.length; i += 1) {
    controlbutton_props = assign(controlbutton_props, controlbutton_spread_levels[i]);
  }
  controlbutton = new ControlButton_default({
    props: controlbutton_props,
    $$inline: true
  });
  controlbutton.$on(
    "click",
    /*onToggleInteractivity*/
    ctx[17]
  );
  const block = {
    c: function create2() {
      create_component(controlbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton_changes = dirty[0] & /*buttonProps*/
      8192 ? get_spread_update(controlbutton_spread_levels, [
        controlbutton_spread_levels[0],
        controlbutton_spread_levels[1],
        controlbutton_spread_levels[2],
        get_spread_object(
          /*buttonProps*/
          ctx2[13]
        )
      ]) : {};
      if (dirty[0] & /*isInteractive*/
      16 | dirty[1] & /*$$scope*/
      2) {
        controlbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton.$set(controlbutton_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(controlbutton.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(controlbutton.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(controlbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(93:2) {#if showLock}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let lockicon;
  let current;
  lockicon = new Lock_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(lockicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(lockicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(lockicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(lockicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lockicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(101:39) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let unlockicon;
  let current;
  unlockicon = new Unlock_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(unlockicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(unlockicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(unlockicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(unlockicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(unlockicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(101:6) {#if isInteractive}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isInteractive*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create2() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(94:4) <ControlButton       class=\\"svelte-flow__controls-interactive\\"       on:click={onToggleInteractivity}       title=\\"toggle interactivity\\"       aria-label=\\"toggle interactivity\\"       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let t02;
  let t12;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*showZoom*/
    ctx[1] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*showFitView*/
    ctx[2] && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*showLock*/
    ctx[3] && create_if_block10(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block0)
        if_block0.c();
      t02 = space();
      if (if_block1)
        if_block1.c();
      t12 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t02, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*showZoom*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*showZoom*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t02.parentNode, t02);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showFitView*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showFitView*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t12.parentNode, t12);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*showLock*/
        ctx2[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*showLock*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(59:0) <Panel class=\\"svelte-flow__controls\\" {position} data-testid=\\"svelte-flow__controls\\">',
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      class: "svelte-flow__controls",
      position: (
        /*position*/
        ctx[0]
      ),
      "data-testid": "svelte-flow__controls",
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty[0] & /*position*/
      1)
        panel_changes.position = /*position*/
        ctx2[0];
      if (dirty[0] & /*isInteractive, showLock, showFitView, minZoomReached, maxZoomReached, showZoom*/
      126 | dirty[1] & /*$$scope*/
      2) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(panel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(panel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let isInteractive;
  let minZoomReached;
  let maxZoomReached;
  let $maxZoom;
  let $viewport;
  let $minZoom;
  let $elementsSelectable;
  let $nodesConnectable;
  let $nodesDraggable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Controls", slots, []);
  let { position = "bottom-left" } = $$props;
  let { showZoom = true } = $$props;
  let { showFitView = true } = $$props;
  let { showLock = true } = $$props;
  let { buttonBgColor = void 0 } = $$props;
  let { buttonBgColorHover = void 0 } = $$props;
  let { buttonColor = void 0 } = $$props;
  let { buttonColorHover = void 0 } = $$props;
  let { buttonBorderColor = void 0 } = $$props;
  const { zoomIn, zoomOut, fitView: fitView2, viewport, minZoom, maxZoom, nodesDraggable, nodesConnectable, elementsSelectable } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(24, $viewport = value));
  validate_store(minZoom, "minZoom");
  component_subscribe($$self, minZoom, (value) => $$invalidate(25, $minZoom = value));
  validate_store(maxZoom, "maxZoom");
  component_subscribe($$self, maxZoom, (value) => $$invalidate(23, $maxZoom = value));
  validate_store(nodesDraggable, "nodesDraggable");
  component_subscribe($$self, nodesDraggable, (value) => $$invalidate(28, $nodesDraggable = value));
  validate_store(nodesConnectable, "nodesConnectable");
  component_subscribe($$self, nodesConnectable, (value) => $$invalidate(27, $nodesConnectable = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(26, $elementsSelectable = value));
  const buttonProps = {
    bgColor: buttonBgColor,
    bgColorHover: buttonBgColorHover,
    color: buttonColor,
    colorHover: buttonColorHover,
    borderColor: buttonBorderColor
  };
  const onZoomInHandler = () => {
    zoomIn();
  };
  const onZoomOutHandler = () => {
    zoomOut();
  };
  const onFitViewHandler = () => {
    fitView2();
  };
  const onToggleInteractivity = () => {
    $$invalidate(4, isInteractive = !isInteractive);
    nodesDraggable.set(isInteractive);
    nodesConnectable.set(isInteractive);
    elementsSelectable.set(isInteractive);
  };
  const writable_props = [
    "position",
    "showZoom",
    "showFitView",
    "showLock",
    "buttonBgColor",
    "buttonBgColorHover",
    "buttonColor",
    "buttonColorHover",
    "buttonBorderColor"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Controls> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("showZoom" in $$props2)
      $$invalidate(1, showZoom = $$props2.showZoom);
    if ("showFitView" in $$props2)
      $$invalidate(2, showFitView = $$props2.showFitView);
    if ("showLock" in $$props2)
      $$invalidate(3, showLock = $$props2.showLock);
    if ("buttonBgColor" in $$props2)
      $$invalidate(18, buttonBgColor = $$props2.buttonBgColor);
    if ("buttonBgColorHover" in $$props2)
      $$invalidate(19, buttonBgColorHover = $$props2.buttonBgColorHover);
    if ("buttonColor" in $$props2)
      $$invalidate(20, buttonColor = $$props2.buttonColor);
    if ("buttonColorHover" in $$props2)
      $$invalidate(21, buttonColorHover = $$props2.buttonColorHover);
    if ("buttonBorderColor" in $$props2)
      $$invalidate(22, buttonBorderColor = $$props2.buttonBorderColor);
  };
  $$self.$capture_state = () => ({
    Panel: Panel_default,
    useStore,
    ControlButton: ControlButton_default,
    PlusIcon: Plus_default,
    MinusIcon: Minus_default,
    FitViewIcon: Fit_default,
    LockIcon: Lock_default,
    UnlockIcon: Unlock_default,
    position,
    showZoom,
    showFitView,
    showLock,
    buttonBgColor,
    buttonBgColorHover,
    buttonColor,
    buttonColorHover,
    buttonBorderColor,
    zoomIn,
    zoomOut,
    fitView: fitView2,
    viewport,
    minZoom,
    maxZoom,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    buttonProps,
    onZoomInHandler,
    onZoomOutHandler,
    onFitViewHandler,
    onToggleInteractivity,
    isInteractive,
    maxZoomReached,
    minZoomReached,
    $maxZoom,
    $viewport,
    $minZoom,
    $elementsSelectable,
    $nodesConnectable,
    $nodesDraggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("showZoom" in $$props2)
      $$invalidate(1, showZoom = $$props2.showZoom);
    if ("showFitView" in $$props2)
      $$invalidate(2, showFitView = $$props2.showFitView);
    if ("showLock" in $$props2)
      $$invalidate(3, showLock = $$props2.showLock);
    if ("buttonBgColor" in $$props2)
      $$invalidate(18, buttonBgColor = $$props2.buttonBgColor);
    if ("buttonBgColorHover" in $$props2)
      $$invalidate(19, buttonBgColorHover = $$props2.buttonBgColorHover);
    if ("buttonColor" in $$props2)
      $$invalidate(20, buttonColor = $$props2.buttonColor);
    if ("buttonColorHover" in $$props2)
      $$invalidate(21, buttonColorHover = $$props2.buttonColorHover);
    if ("buttonBorderColor" in $$props2)
      $$invalidate(22, buttonBorderColor = $$props2.buttonBorderColor);
    if ("isInteractive" in $$props2)
      $$invalidate(4, isInteractive = $$props2.isInteractive);
    if ("maxZoomReached" in $$props2)
      $$invalidate(5, maxZoomReached = $$props2.maxZoomReached);
    if ("minZoomReached" in $$props2)
      $$invalidate(6, minZoomReached = $$props2.minZoomReached);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$nodesDraggable, $nodesConnectable, $elementsSelectable*/
    469762048) {
      $:
        $$invalidate(4, isInteractive = $nodesDraggable || $nodesConnectable || $elementsSelectable);
    }
    if ($$self.$$.dirty[0] & /*$viewport, $minZoom*/
    50331648) {
      $:
        $$invalidate(6, minZoomReached = $viewport.zoom <= $minZoom);
    }
    if ($$self.$$.dirty[0] & /*$viewport, $maxZoom*/
    25165824) {
      $:
        $$invalidate(5, maxZoomReached = $viewport.zoom >= $maxZoom);
    }
  };
  return [
    position,
    showZoom,
    showFitView,
    showLock,
    isInteractive,
    maxZoomReached,
    minZoomReached,
    viewport,
    minZoom,
    maxZoom,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    buttonProps,
    onZoomInHandler,
    onZoomOutHandler,
    onFitViewHandler,
    onToggleInteractivity,
    buttonBgColor,
    buttonBgColorHover,
    buttonColor,
    buttonColorHover,
    buttonBorderColor,
    $maxZoom,
    $viewport,
    $minZoom,
    $elementsSelectable,
    $nodesConnectable,
    $nodesDraggable
  ];
}
var Controls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment36,
      safe_not_equal,
      {
        position: 0,
        showZoom: 1,
        showFitView: 2,
        showLock: 3,
        buttonBgColor: 18,
        buttonBgColorHover: 19,
        buttonColor: 20,
        buttonColorHover: 21,
        buttonBorderColor: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Controls",
      options,
      id: create_fragment36.name
    });
  }
  get position() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showZoom() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showZoom(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showFitView() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showFitView(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLock() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLock(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBgColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBgColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBgColorHover() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBgColorHover(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonColorHover() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonColorHover(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBorderColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBorderColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Controls_default = Controls;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/types.js
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte
var file25 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte";
function create_fragment37(ctx) {
  let circle;
  let circle_class_value;
  const block = {
    c: function create2() {
      circle = svg_element("circle");
      attr_dev(
        circle,
        "cx",
        /*radius*/
        ctx[0]
      );
      attr_dev(
        circle,
        "cy",
        /*radius*/
        ctx[0]
      );
      attr_dev(
        circle,
        "r",
        /*radius*/
        ctx[0]
      );
      attr_dev(circle, "class", circle_class_value = cc([
        "svelte-flow__background-pattern",
        "dots",
        /*className*/
        ctx[1]
      ]));
      add_location(circle, file25, 8, 0, 130);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, circle, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "cx",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "cy",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "r",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*className*/
      2 && circle_class_value !== (circle_class_value = cc([
        "svelte-flow__background-pattern",
        "dots",
        /*className*/
        ctx2[1]
      ]))) {
        attr_dev(circle, "class", circle_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(circle);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DotPattern", slots, []);
  let { radius = 5 } = $$props;
  let { class: className = "" } = $$props;
  const writable_props = ["radius", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<DotPattern> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("radius" in $$props2)
      $$invalidate(0, radius = $$props2.radius);
    if ("class" in $$props2)
      $$invalidate(1, className = $$props2.class);
  };
  $$self.$capture_state = () => ({ cc, radius, className });
  $$self.$inject_state = ($$props2) => {
    if ("radius" in $$props2)
      $$invalidate(0, radius = $$props2.radius);
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [radius, className];
}
var DotPattern = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { radius: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DotPattern",
      options,
      id: create_fragment37.name
    });
  }
  get radius() {
    throw new Error("<DotPattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<DotPattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DotPattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DotPattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DotPattern_default = DotPattern;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte
var file26 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte";
function create_fragment38(ctx) {
  let path;
  let path_d_value;
  let path_class_value;
  const block = {
    c: function create2() {
      path = svg_element("path");
      attr_dev(
        path,
        "stroke-width",
        /*lineWidth*/
        ctx[0]
      );
      attr_dev(path, "d", path_d_value = `M${/*dimensions*/
      ctx[1][0] / 2} 0 V${/*dimensions*/
      ctx[1][1]} M0 ${/*dimensions*/
      ctx[1][1] / 2} H${/*dimensions*/
      ctx[1][0]}`);
      attr_dev(path, "class", path_class_value = cc([
        "svelte-flow__background-pattern",
        /*variant*/
        ctx[2],
        /*className*/
        ctx[3]
      ]));
      add_location(path, file26, 11, 0, 185);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*lineWidth*/
      1) {
        attr_dev(
          path,
          "stroke-width",
          /*lineWidth*/
          ctx2[0]
        );
      }
      if (dirty & /*dimensions*/
      2 && path_d_value !== (path_d_value = `M${/*dimensions*/
      ctx2[1][0] / 2} 0 V${/*dimensions*/
      ctx2[1][1]} M0 ${/*dimensions*/
      ctx2[1][1] / 2} H${/*dimensions*/
      ctx2[1][0]}`)) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*variant, className*/
      12 && path_class_value !== (path_class_value = cc([
        "svelte-flow__background-pattern",
        /*variant*/
        ctx2[2],
        /*className*/
        ctx2[3]
      ]))) {
        attr_dev(path, "class", path_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinePattern", slots, []);
  let { lineWidth = 1 } = $$props;
  let { dimensions } = $$props;
  let { variant = void 0 } = $$props;
  let { class: className = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (dimensions === void 0 && !("dimensions" in $$props || $$self.$$.bound[$$self.$$.props["dimensions"]])) {
      console.warn("<LinePattern> was created without expected prop 'dimensions'");
    }
  });
  const writable_props = ["lineWidth", "dimensions", "variant", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<LinePattern> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lineWidth" in $$props2)
      $$invalidate(0, lineWidth = $$props2.lineWidth);
    if ("dimensions" in $$props2)
      $$invalidate(1, dimensions = $$props2.dimensions);
    if ("variant" in $$props2)
      $$invalidate(2, variant = $$props2.variant);
    if ("class" in $$props2)
      $$invalidate(3, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    lineWidth,
    dimensions,
    variant,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("lineWidth" in $$props2)
      $$invalidate(0, lineWidth = $$props2.lineWidth);
    if ("dimensions" in $$props2)
      $$invalidate(1, dimensions = $$props2.dimensions);
    if ("variant" in $$props2)
      $$invalidate(2, variant = $$props2.variant);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [lineWidth, dimensions, variant, className];
}
var LinePattern = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      lineWidth: 0,
      dimensions: 1,
      variant: 2,
      class: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinePattern",
      options,
      id: create_fragment38.name
    });
  }
  get lineWidth() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dimensions() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dimensions(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinePattern_default = LinePattern;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte
var file27 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte";
function add_css9(target) {
  append_styles(target, "svelte-1r7pe8d", ".svelte-flow__background.svelte-1r7pe8d{position:absolute;width:100%;height:100%;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFja2dyb3VuZC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUVFLHVDQUF5QixDQUN2QixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FDUiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQmFja2dyb3VuZC5zdmVsdGUiXX0= */");
}
function create_else_block2(ctx) {
  let linepattern;
  let current;
  linepattern = new LinePattern_default({
    props: {
      dimensions: (
        /*patternDimensions*/
        ctx[6]
      ),
      variant: (
        /*variant*/
        ctx[0]
      ),
      lineWidth: (
        /*lineWidth*/
        ctx[1]
      ),
      class: (
        /*patternClass*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(linepattern.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(linepattern, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const linepattern_changes = {};
      if (dirty & /*patternDimensions*/
      64)
        linepattern_changes.dimensions = /*patternDimensions*/
        ctx2[6];
      if (dirty & /*variant*/
      1)
        linepattern_changes.variant = /*variant*/
        ctx2[0];
      if (dirty & /*lineWidth*/
      2)
        linepattern_changes.lineWidth = /*lineWidth*/
        ctx2[1];
      if (dirty & /*patternClass*/
      16)
        linepattern_changes.class = /*patternClass*/
        ctx2[4];
      linepattern.$set(linepattern_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(linepattern.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(linepattern.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linepattern, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(58:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let dotpattern;
  let current;
  dotpattern = new DotPattern_default({
    props: {
      radius: (
        /*scaledSize*/
        ctx[7] / 2
      ),
      class: (
        /*patternClass*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(dotpattern.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(dotpattern, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dotpattern_changes = {};
      if (dirty & /*scaledSize*/
      128)
        dotpattern_changes.radius = /*scaledSize*/
        ctx2[7] / 2;
      if (dirty & /*patternClass*/
      16)
        dotpattern_changes.class = /*patternClass*/
        ctx2[4];
      dotpattern.$set(dotpattern_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(dotpattern.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(dotpattern.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dotpattern, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(56:4) {#if isDots}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let svg;
  let pattern;
  let current_block_type_index;
  let if_block;
  let pattern_x_value;
  let pattern_y_value;
  let pattern_width_value;
  let pattern_height_value;
  let pattern_patternTransform_value;
  let rect;
  let rect_fill_value;
  let svg_class_value;
  let current;
  const if_block_creators = [create_if_block11, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isDots*/
      ctx2[14]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      pattern = svg_element("pattern");
      if_block.c();
      rect = svg_element("rect");
      attr_dev(
        pattern,
        "id",
        /*patternId*/
        ctx[11]
      );
      attr_dev(pattern, "x", pattern_x_value = /*$viewport*/
      ctx[9].x % /*scaledGap*/
      ctx[8][0]);
      attr_dev(pattern, "y", pattern_y_value = /*$viewport*/
      ctx[9].y % /*scaledGap*/
      ctx[8][1]);
      attr_dev(pattern, "width", pattern_width_value = /*scaledGap*/
      ctx[8][0]);
      attr_dev(pattern, "height", pattern_height_value = /*scaledGap*/
      ctx[8][1]);
      attr_dev(pattern, "patternUnits", "userSpaceOnUse");
      attr_dev(pattern, "patternTransform", pattern_patternTransform_value = `translate(-${/*patternOffset*/
      ctx[10][0]},-${/*patternOffset*/
      ctx[10][1]})`);
      add_location(pattern, file27, 50, 2, 1534);
      attr_dev(rect, "x", "0");
      attr_dev(rect, "y", "0");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      attr_dev(rect, "fill", rect_fill_value = `url(#${/*patternId*/
      ctx[11]})`);
      add_location(rect, file27, 65, 2, 2015);
      attr_dev(svg, "class", svg_class_value = null_to_empty(cc([
        "svelte-flow__background",
        /*className*/
        ctx[5]
      ])) + " svelte-1r7pe8d");
      attr_dev(svg, "data-testid", "svelte-flow__background");
      set_style(
        svg,
        "--background-color-props",
        /*bgColor*/
        ctx[2]
      );
      set_style(
        svg,
        "--background-pattern-color-props",
        /*patternColor*/
        ctx[3]
      );
      add_location(svg, file27, 44, 0, 1333);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, pattern);
      if_blocks[current_block_type_index].m(pattern, null);
      append_dev(svg, rect);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
      if (!current || dirty & /*patternId*/
      2048) {
        attr_dev(
          pattern,
          "id",
          /*patternId*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*$viewport, scaledGap*/
      768 && pattern_x_value !== (pattern_x_value = /*$viewport*/
      ctx2[9].x % /*scaledGap*/
      ctx2[8][0])) {
        attr_dev(pattern, "x", pattern_x_value);
      }
      if (!current || dirty & /*$viewport, scaledGap*/
      768 && pattern_y_value !== (pattern_y_value = /*$viewport*/
      ctx2[9].y % /*scaledGap*/
      ctx2[8][1])) {
        attr_dev(pattern, "y", pattern_y_value);
      }
      if (!current || dirty & /*scaledGap*/
      256 && pattern_width_value !== (pattern_width_value = /*scaledGap*/
      ctx2[8][0])) {
        attr_dev(pattern, "width", pattern_width_value);
      }
      if (!current || dirty & /*scaledGap*/
      256 && pattern_height_value !== (pattern_height_value = /*scaledGap*/
      ctx2[8][1])) {
        attr_dev(pattern, "height", pattern_height_value);
      }
      if (!current || dirty & /*patternOffset*/
      1024 && pattern_patternTransform_value !== (pattern_patternTransform_value = `translate(-${/*patternOffset*/
      ctx2[10][0]},-${/*patternOffset*/
      ctx2[10][1]})`)) {
        attr_dev(pattern, "patternTransform", pattern_patternTransform_value);
      }
      if (!current || dirty & /*patternId*/
      2048 && rect_fill_value !== (rect_fill_value = `url(#${/*patternId*/
      ctx2[11]})`)) {
        attr_dev(rect, "fill", rect_fill_value);
      }
      if (!current || dirty & /*className*/
      32 && svg_class_value !== (svg_class_value = null_to_empty(cc([
        "svelte-flow__background",
        /*className*/
        ctx2[5]
      ])) + " svelte-1r7pe8d")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*bgColor*/
      4) {
        set_style(
          svg,
          "--background-color-props",
          /*bgColor*/
          ctx2[2]
        );
      }
      if (dirty & /*patternColor*/
      8) {
        set_style(
          svg,
          "--background-pattern-color-props",
          /*patternColor*/
          ctx2[3]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
function instance39($$self, $$props, $$invalidate) {
  let patternId;
  let scaledGap;
  let scaledSize;
  let patternDimensions;
  let patternOffset;
  let $viewport;
  let $flowId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Background", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { variant = BackgroundVariant.Dots } = $$props;
  let { gap = 20 } = $$props;
  let { size = 1 } = $$props;
  let { lineWidth = 1 } = $$props;
  let { bgColor = void 0 } = $$props;
  let { patternColor = void 0 } = $$props;
  let { patternClass = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const { viewport, flowId } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(9, $viewport = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(18, $flowId = value));
  const patternSize = size || defaultSize[variant];
  const isDots = variant === BackgroundVariant.Dots;
  const isCross = variant === BackgroundVariant.Cross;
  const gapXY = Array.isArray(gap) ? gap : [gap, gap];
  const writable_props = [
    "id",
    "variant",
    "gap",
    "size",
    "lineWidth",
    "bgColor",
    "patternColor",
    "patternClass",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Background> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(15, id2 = $$props2.id);
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("gap" in $$props2)
      $$invalidate(16, gap = $$props2.gap);
    if ("size" in $$props2)
      $$invalidate(17, size = $$props2.size);
    if ("lineWidth" in $$props2)
      $$invalidate(1, lineWidth = $$props2.lineWidth);
    if ("bgColor" in $$props2)
      $$invalidate(2, bgColor = $$props2.bgColor);
    if ("patternColor" in $$props2)
      $$invalidate(3, patternColor = $$props2.patternColor);
    if ("patternClass" in $$props2)
      $$invalidate(4, patternClass = $$props2.patternClass);
    if ("class" in $$props2)
      $$invalidate(5, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    defaultSize,
    cc,
    DotPattern: DotPattern_default,
    LinePattern: LinePattern_default,
    useStore,
    BackgroundVariant,
    id: id2,
    variant,
    gap,
    size,
    lineWidth,
    bgColor,
    patternColor,
    patternClass,
    className,
    viewport,
    flowId,
    patternSize,
    isDots,
    isCross,
    gapXY,
    patternDimensions,
    scaledSize,
    patternOffset,
    scaledGap,
    patternId,
    $viewport,
    $flowId
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(15, id2 = $$props2.id);
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("gap" in $$props2)
      $$invalidate(16, gap = $$props2.gap);
    if ("size" in $$props2)
      $$invalidate(17, size = $$props2.size);
    if ("lineWidth" in $$props2)
      $$invalidate(1, lineWidth = $$props2.lineWidth);
    if ("bgColor" in $$props2)
      $$invalidate(2, bgColor = $$props2.bgColor);
    if ("patternColor" in $$props2)
      $$invalidate(3, patternColor = $$props2.patternColor);
    if ("patternClass" in $$props2)
      $$invalidate(4, patternClass = $$props2.patternClass);
    if ("className" in $$props2)
      $$invalidate(5, className = $$props2.className);
    if ("patternDimensions" in $$props2)
      $$invalidate(6, patternDimensions = $$props2.patternDimensions);
    if ("scaledSize" in $$props2)
      $$invalidate(7, scaledSize = $$props2.scaledSize);
    if ("patternOffset" in $$props2)
      $$invalidate(10, patternOffset = $$props2.patternOffset);
    if ("scaledGap" in $$props2)
      $$invalidate(8, scaledGap = $$props2.scaledGap);
    if ("patternId" in $$props2)
      $$invalidate(11, patternId = $$props2.patternId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$flowId, id*/
    294912) {
      $:
        $$invalidate(11, patternId = `background-pattern-${$flowId}-${id2 ? id2 : ""}`);
    }
    if ($$self.$$.dirty & /*$viewport*/
    512) {
      $:
        $$invalidate(8, scaledGap = [gapXY[0] * $viewport.zoom || 1, gapXY[1] * $viewport.zoom || 1]);
    }
    if ($$self.$$.dirty & /*$viewport*/
    512) {
      $:
        $$invalidate(7, scaledSize = patternSize * $viewport.zoom);
    }
    if ($$self.$$.dirty & /*scaledSize, scaledGap*/
    384) {
      $:
        $$invalidate(6, patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap);
    }
    if ($$self.$$.dirty & /*scaledSize, patternDimensions*/
    192) {
      $:
        $$invalidate(10, patternOffset = isDots ? [scaledSize / 2, scaledSize / 2] : [patternDimensions[0] / 2, patternDimensions[1] / 2]);
    }
  };
  return [
    variant,
    lineWidth,
    bgColor,
    patternColor,
    patternClass,
    className,
    patternDimensions,
    scaledSize,
    scaledGap,
    $viewport,
    patternOffset,
    patternId,
    viewport,
    flowId,
    isDots,
    id2,
    gap,
    size,
    $flowId
  ];
}
var Background = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance39,
      create_fragment39,
      safe_not_equal,
      {
        id: 15,
        variant: 0,
        gap: 16,
        size: 17,
        lineWidth: 1,
        bgColor: 2,
        patternColor: 3,
        patternClass: 4,
        class: 5
      },
      add_css9
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Background",
      options,
      id: create_fragment39.name
    });
  }
  get id() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternColor() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternColor(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternClass() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternClass(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Background_default = Background;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte
var file28 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte";
function create_fragment40(ctx) {
  let rect;
  let rect_class_value;
  let rect_style_value;
  const block = {
    c: function create2() {
      rect = svg_element("rect");
      attr_dev(rect, "class", rect_class_value = cc([
        "svelte-flow__minimap-node",
        /*className*/
        ctx[10]
      ]));
      attr_dev(
        rect,
        "x",
        /*x*/
        ctx[0]
      );
      attr_dev(
        rect,
        "y",
        /*y*/
        ctx[1]
      );
      attr_dev(
        rect,
        "rx",
        /*borderRadius*/
        ctx[4]
      );
      attr_dev(
        rect,
        "ry",
        /*borderRadius*/
        ctx[4]
      );
      attr_dev(
        rect,
        "width",
        /*width*/
        ctx[2]
      );
      attr_dev(
        rect,
        "height",
        /*height*/
        ctx[3]
      );
      attr_dev(rect, "style", rect_style_value = `${/*color*/
      ctx[5] ? `fill: ${/*color*/
      ctx[5]};` : ""}${/*strokeColor*/
      ctx[7] ? `stroke: ${/*strokeColor*/
      ctx[7]};` : ""}${/*strokeWidth*/
      ctx[8] ? `stroke-width: ${/*strokeWidth*/
      ctx[8]};` : ""}`);
      attr_dev(
        rect,
        "shape-rendering",
        /*shapeRendering*/
        ctx[6]
      );
      toggle_class(
        rect,
        "selected",
        /*selected*/
        ctx[9]
      );
      add_location(rect, file28, 17, 0, 353);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, rect, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*className*/
      1024 && rect_class_value !== (rect_class_value = cc([
        "svelte-flow__minimap-node",
        /*className*/
        ctx2[10]
      ]))) {
        attr_dev(rect, "class", rect_class_value);
      }
      if (dirty & /*x*/
      1) {
        attr_dev(
          rect,
          "x",
          /*x*/
          ctx2[0]
        );
      }
      if (dirty & /*y*/
      2) {
        attr_dev(
          rect,
          "y",
          /*y*/
          ctx2[1]
        );
      }
      if (dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "rx",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "ry",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*width*/
      4) {
        attr_dev(
          rect,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      8) {
        attr_dev(
          rect,
          "height",
          /*height*/
          ctx2[3]
        );
      }
      if (dirty & /*color, strokeColor, strokeWidth*/
      416 && rect_style_value !== (rect_style_value = `${/*color*/
      ctx2[5] ? `fill: ${/*color*/
      ctx2[5]};` : ""}${/*strokeColor*/
      ctx2[7] ? `stroke: ${/*strokeColor*/
      ctx2[7]};` : ""}${/*strokeWidth*/
      ctx2[8] ? `stroke-width: ${/*strokeWidth*/
      ctx2[8]};` : ""}`)) {
        attr_dev(rect, "style", rect_style_value);
      }
      if (dirty & /*shapeRendering*/
      64) {
        attr_dev(
          rect,
          "shape-rendering",
          /*shapeRendering*/
          ctx2[6]
        );
      }
      if (dirty & /*className, selected*/
      1536) {
        toggle_class(
          rect,
          "selected",
          /*selected*/
          ctx2[9]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(rect);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinimapNode", slots, []);
  let { x } = $$props;
  let { y } = $$props;
  let { width = 0 } = $$props;
  let { height = 0 } = $$props;
  let { borderRadius = 5 } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { shapeRendering } = $$props;
  let { strokeColor = void 0 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { selected = false } = $$props;
  let { class: className = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (x === void 0 && !("x" in $$props || $$self.$$.bound[$$self.$$.props["x"]])) {
      console.warn("<MinimapNode> was created without expected prop 'x'");
    }
    if (y === void 0 && !("y" in $$props || $$self.$$.bound[$$self.$$.props["y"]])) {
      console.warn("<MinimapNode> was created without expected prop 'y'");
    }
    if (shapeRendering === void 0 && !("shapeRendering" in $$props || $$self.$$.bound[$$self.$$.props["shapeRendering"]])) {
      console.warn("<MinimapNode> was created without expected prop 'shapeRendering'");
    }
  });
  const writable_props = [
    "x",
    "y",
    "width",
    "height",
    "borderRadius",
    "color",
    "shapeRendering",
    "strokeColor",
    "strokeWidth",
    "selected",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<MinimapNode> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("borderRadius" in $$props2)
      $$invalidate(4, borderRadius = $$props2.borderRadius);
    if ("color" in $$props2)
      $$invalidate(5, color2 = $$props2.color);
    if ("shapeRendering" in $$props2)
      $$invalidate(6, shapeRendering = $$props2.shapeRendering);
    if ("strokeColor" in $$props2)
      $$invalidate(7, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(8, strokeWidth = $$props2.strokeWidth);
    if ("selected" in $$props2)
      $$invalidate(9, selected = $$props2.selected);
    if ("class" in $$props2)
      $$invalidate(10, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    x,
    y,
    width,
    height,
    borderRadius,
    color: color2,
    shapeRendering,
    strokeColor,
    strokeWidth,
    selected,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("borderRadius" in $$props2)
      $$invalidate(4, borderRadius = $$props2.borderRadius);
    if ("color" in $$props2)
      $$invalidate(5, color2 = $$props2.color);
    if ("shapeRendering" in $$props2)
      $$invalidate(6, shapeRendering = $$props2.shapeRendering);
    if ("strokeColor" in $$props2)
      $$invalidate(7, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(8, strokeWidth = $$props2.strokeWidth);
    if ("selected" in $$props2)
      $$invalidate(9, selected = $$props2.selected);
    if ("className" in $$props2)
      $$invalidate(10, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    x,
    y,
    width,
    height,
    borderRadius,
    color2,
    shapeRendering,
    strokeColor,
    strokeWidth,
    selected,
    className
  ];
}
var MinimapNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      x: 0,
      y: 1,
      width: 2,
      height: 3,
      borderRadius: 4,
      color: 5,
      shapeRendering: 6,
      strokeColor: 7,
      strokeWidth: 8,
      selected: 9,
      class: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinimapNode",
      options,
      id: create_fragment40.name
    });
  }
  get x() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shapeRendering() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shapeRendering(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeColor() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeColor(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinimapNode_default = MinimapNode;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/interactive.js
function interactive(domNode, params) {
  const minimap = XYMinimap({
    domNode,
    panZoom: params.panZoom,
    getTransform: () => {
      const viewport = get_store_value(params.viewport);
      return [viewport.x, viewport.y, viewport.zoom];
    },
    getViewScale: params.getViewScale
  });
  function update(params2) {
    minimap.update({
      translateExtent: params2.translateExtent,
      width: params2.width,
      height: params2.height,
      inversePan: params2.inversePan,
      zoomStep: params2.zoomStep,
      pannable: params2.pannable,
      zoomable: params2.zoomable
    });
  }
  return {
    update,
    destroy() {
      minimap.destroy();
    }
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte
var file29 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[53] = list[i];
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getNodePositionWithOrigin(
    /*node*/
    child_ctx[53]
  ).positionAbsolute;
  child_ctx[56] = constants_0;
  return child_ctx;
}
function create_if_block12(ctx) {
  let svg;
  let if_block_anchor;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let path;
  let path_d_value;
  let svg_viewBox_value;
  let interactive_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*ariaLabel*/
    ctx[1] && create_if_block_22(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*$nodes*/
    ctx[18]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[53].id
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block4(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      path = svg_element("path");
      attr_dev(path, "class", "svelte-flow__minimap-mask");
      attr_dev(path, "d", path_d_value = "M" + /*x*/
      (ctx[24] - /*offset*/
      ctx[14]) + "," + /*y*/
      (ctx[23] - /*offset*/
      ctx[14]) + "h" + /*viewboxWidth*/
      (ctx[22] + /*offset*/
      ctx[14] * 2) + "v" + /*viewboxHeight*/
      (ctx[21] + /*offset*/
      ctx[14] * 2) + "h" + (-/*viewboxWidth*/
      ctx[22] - /*offset*/
      ctx[14] * 2) + "z\n      M" + /*viewBB*/
      ctx[17].x + "," + /*viewBB*/
      ctx[17].y + "h" + /*viewBB*/
      ctx[17].width + "v" + /*viewBB*/
      ctx[17].height + "h" + -/*viewBB*/
      ctx[17].width + "z");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "pointer-events", "none");
      add_location(path, file29, 133, 6, 4191);
      attr_dev(
        svg,
        "width",
        /*elementWidth*/
        ctx[16]
      );
      attr_dev(
        svg,
        "height",
        /*elementHeight*/
        ctx[15]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = /*x*/
      ctx[24] + " " + /*y*/
      ctx[23] + " " + /*viewboxWidth*/
      ctx[22] + " " + /*viewboxHeight*/
      ctx[21]);
      attr_dev(svg, "role", "img");
      attr_dev(
        svg,
        "aria-labelledby",
        /*labelledBy*/
        ctx[38]
      );
      set_style(
        svg,
        "--minimap-background-color-props",
        /*bgColor*/
        ctx[4]
      );
      set_style(
        svg,
        "--minimap-mask-color-props",
        /*maskColor*/
        ctx[5]
      );
      set_style(
        svg,
        "--minimap-mask-stroke-color-props",
        /*maskStrokeColor*/
        ctx[6]
      );
      set_style(
        svg,
        "--minimap-mask-stroke-width-props",
        /*maskStrokeWidth*/
        ctx[7]
      );
      add_location(svg, file29, 90, 4, 2700);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append_dev(svg, path);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(interactive_action = interactive.call(null, svg, {
          panZoom: (
            /*$panZoom*/
            ctx[25]
          ),
          viewport: (
            /*viewport*/
            ctx[28]
          ),
          getViewScale: (
            /*getViewScale*/
            ctx[39]
          ),
          translateExtent: (
            /*$translateExtent*/
            ctx[26]
          ),
          width: (
            /*$containerWidth*/
            ctx[20]
          ),
          height: (
            /*$containerHeight*/
            ctx[19]
          ),
          inversePan: (
            /*inversePan*/
            ctx[10]
          ),
          zoomStep: (
            /*zoomStep*/
            ctx[11]
          ),
          pannable: (
            /*pannable*/
            ctx[8]
          ),
          zoomable: (
            /*zoomable*/
            ctx[9]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*ariaLabel*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(svg, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*$nodes, nodeBorderRadius, nodeStrokeWidth*/
      262156 | dirty[1] & /*nodeColorFunc, nodeStrokeColorFunc, shapeRendering, nodeClassFunc*/
      120) {
        each_value = ensure_array_like_dev(
          /*$nodes*/
          ctx2[18]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svg, outro_and_destroy_block, create_each_block4, path, get_each_context4);
        check_outros();
      }
      if (!current || dirty[0] & /*x, offset, y, viewboxWidth, viewboxHeight, viewBB*/
      31604736 && path_d_value !== (path_d_value = "M" + /*x*/
      (ctx2[24] - /*offset*/
      ctx2[14]) + "," + /*y*/
      (ctx2[23] - /*offset*/
      ctx2[14]) + "h" + /*viewboxWidth*/
      (ctx2[22] + /*offset*/
      ctx2[14] * 2) + "v" + /*viewboxHeight*/
      (ctx2[21] + /*offset*/
      ctx2[14] * 2) + "h" + (-/*viewboxWidth*/
      ctx2[22] - /*offset*/
      ctx2[14] * 2) + "z\n      M" + /*viewBB*/
      ctx2[17].x + "," + /*viewBB*/
      ctx2[17].y + "h" + /*viewBB*/
      ctx2[17].width + "v" + /*viewBB*/
      ctx2[17].height + "h" + -/*viewBB*/
      ctx2[17].width + "z")) {
        attr_dev(path, "d", path_d_value);
      }
      if (!current || dirty[0] & /*elementWidth*/
      65536) {
        attr_dev(
          svg,
          "width",
          /*elementWidth*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*elementHeight*/
      32768) {
        attr_dev(
          svg,
          "height",
          /*elementHeight*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*x, y, viewboxWidth, viewboxHeight*/
      31457280 && svg_viewBox_value !== (svg_viewBox_value = /*x*/
      ctx2[24] + " " + /*y*/
      ctx2[23] + " " + /*viewboxWidth*/
      ctx2[22] + " " + /*viewboxHeight*/
      ctx2[21])) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (interactive_action && is_function(interactive_action.update) && dirty[0] & /*$panZoom, $translateExtent, $containerWidth, $containerHeight, inversePan, zoomStep, pannable, zoomable*/
      10224e4)
        interactive_action.update.call(null, {
          panZoom: (
            /*$panZoom*/
            ctx2[25]
          ),
          viewport: (
            /*viewport*/
            ctx2[28]
          ),
          getViewScale: (
            /*getViewScale*/
            ctx2[39]
          ),
          translateExtent: (
            /*$translateExtent*/
            ctx2[26]
          ),
          width: (
            /*$containerWidth*/
            ctx2[20]
          ),
          height: (
            /*$containerHeight*/
            ctx2[19]
          ),
          inversePan: (
            /*inversePan*/
            ctx2[10]
          ),
          zoomStep: (
            /*zoomStep*/
            ctx2[11]
          ),
          pannable: (
            /*pannable*/
            ctx2[8]
          ),
          zoomable: (
            /*zoomable*/
            ctx2[9]
          )
        });
      if (dirty[0] & /*bgColor*/
      16) {
        set_style(
          svg,
          "--minimap-background-color-props",
          /*bgColor*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*maskColor*/
      32) {
        set_style(
          svg,
          "--minimap-mask-color-props",
          /*maskColor*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*maskStrokeColor*/
      64) {
        set_style(
          svg,
          "--minimap-mask-stroke-color-props",
          /*maskStrokeColor*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*maskStrokeWidth*/
      128) {
        set_style(
          svg,
          "--minimap-mask-stroke-width-props",
          /*maskStrokeWidth*/
          ctx2[7]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(88:2) {#if $panZoom}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let title;
  let t;
  const block = {
    c: function create2() {
      title = svg_element("title");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      attr_dev(
        title,
        "id",
        /*labelledBy*/
        ctx[38]
      );
      add_location(title, file29, 113, 21, 3412);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title, anchor);
      append_dev(title, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(112:6) {#if ariaLabel}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  var _a, _b, _c;
  let minimapnode;
  let current;
  minimapnode = new MinimapNode_default({
    props: {
      x: (
        /*pos*/
        ctx[56].x
      ),
      y: (
        /*pos*/
        ctx[56].y
      ),
      width: (
        /*node*/
        ((_a = ctx[53].computed) == null ? void 0 : _a.width) ?? /*node*/
        ctx[53].width ?? 0
      ),
      height: (
        /*node*/
        ((_b = ctx[53].computed) == null ? void 0 : _b.height) ?? /*node*/
        ctx[53].height ?? 0
      ),
      selected: (
        /*node*/
        ctx[53].selected
      ),
      color: (
        /*nodeColorFunc*/
        (_c = ctx[34]) == null ? void 0 : _c.call(
          ctx,
          /*node*/
          ctx[53]
        )
      ),
      borderRadius: (
        /*nodeBorderRadius*/
        ctx[2]
      ),
      strokeColor: (
        /*nodeStrokeColorFunc*/
        ctx[35](
          /*node*/
          ctx[53]
        )
      ),
      strokeWidth: (
        /*nodeStrokeWidth*/
        ctx[3]
      ),
      shapeRendering: (
        /*shapeRendering*/
        ctx[37]
      ),
      class: (
        /*nodeClassFunc*/
        ctx[36](
          /*node*/
          ctx[53]
        )
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(minimapnode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(minimapnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c2;
      const minimapnode_changes = {};
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.x = /*pos*/
        ctx2[56].x;
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.y = /*pos*/
        ctx2[56].y;
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.width = /*node*/
        ((_a2 = ctx2[53].computed) == null ? void 0 : _a2.width) ?? /*node*/
        ctx2[53].width ?? 0;
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.height = /*node*/
        ((_b2 = ctx2[53].computed) == null ? void 0 : _b2.height) ?? /*node*/
        ctx2[53].height ?? 0;
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.selected = /*node*/
        ctx2[53].selected;
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.color = /*nodeColorFunc*/
        (_c2 = ctx2[34]) == null ? void 0 : _c2.call(
          ctx2,
          /*node*/
          ctx2[53]
        );
      if (dirty[0] & /*nodeBorderRadius*/
      4)
        minimapnode_changes.borderRadius = /*nodeBorderRadius*/
        ctx2[2];
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.strokeColor = /*nodeStrokeColorFunc*/
        ctx2[35](
          /*node*/
          ctx2[53]
        );
      if (dirty[0] & /*nodeStrokeWidth*/
      8)
        minimapnode_changes.strokeWidth = /*nodeStrokeWidth*/
        ctx2[3];
      if (dirty[0] & /*$nodes*/
      262144)
        minimapnode_changes.class = /*nodeClassFunc*/
        ctx2[36](
          /*node*/
          ctx2[53]
        );
      minimapnode.$set(minimapnode_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(minimapnode.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(minimapnode.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minimapnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(115:8) {#if (node.computed?.width || node?.width) && (node.computed?.height || node.height)}",
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  var _a, _b, _c;
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*node*/
    (((_a = ctx[53].computed) == null ? void 0 : _a.width) || /*node*/
    ((_b = ctx[53]) == null ? void 0 : _b.width)) && /*node*/
    (((_c = ctx[53].computed) == null ? void 0 : _c.height) || /*node*/
    ctx[53].height) && create_if_block_15(get_if_ctx(ctx))
  );
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2, _c2;
      ctx = new_ctx;
      if (
        /*node*/
        (((_a2 = ctx[53].computed) == null ? void 0 : _a2.width) || /*node*/
        ((_b2 = ctx[53]) == null ? void 0 : _b2.width)) && /*node*/
        (((_c2 = ctx[53].computed) == null ? void 0 : _c2.height) || /*node*/
        ctx[53].height)
      ) {
        if (if_block) {
          if_block.p(get_if_ctx(ctx), dirty);
          if (dirty[0] & /*$nodes*/
          262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(get_if_ctx(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(114:6) {#each $nodes as node (node.id)}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$panZoom*/
    ctx[25] && create_if_block12(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$panZoom*/
        ctx2[25]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$panZoom*/
          33554432) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: `(82:0) <Panel   {position}   {style}   class={cc(['svelte-flow__minimap', className])}   data-testid=\\"svelte-flow__minimap\\" >`,
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      position: (
        /*position*/
        ctx[0]
      ),
      style: (
        /*style*/
        ctx[12]
      ),
      class: cc([
        "svelte-flow__minimap",
        /*className*/
        ctx[13]
      ]),
      "data-testid": "svelte-flow__minimap",
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty[0] & /*position*/
      1)
        panel_changes.position = /*position*/
        ctx2[0];
      if (dirty[0] & /*style*/
      4096)
        panel_changes.style = /*style*/
        ctx2[12];
      if (dirty[0] & /*className*/
      8192)
        panel_changes.class = cc([
          "svelte-flow__minimap",
          /*className*/
          ctx2[13]
        ]);
      if (dirty[0] & /*elementWidth, elementHeight, x, y, viewboxWidth, viewboxHeight, $panZoom, $translateExtent, $containerWidth, $containerHeight, inversePan, zoomStep, pannable, zoomable, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, offset, viewBB, $nodes, nodeBorderRadius, nodeStrokeWidth, ariaLabel*/
      134205438 | dirty[1] & /*$$scope*/
      67108864) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(panel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(panel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var getAttrFunction = (func2) => func2 instanceof Function ? func2 : () => func2;
var defaultWidth = 200;
var defaultHeight = 150;
function instance41($$self, $$props, $$invalidate) {
  let viewBB;
  let boundingRect;
  let elementWidth;
  let elementHeight;
  let scaledWidth;
  let scaledHeight;
  let viewScale;
  let viewWidth;
  let viewHeight;
  let offset;
  let x;
  let y;
  let viewboxWidth;
  let viewboxHeight;
  let $nodes;
  let $viewport;
  let $containerHeight;
  let $containerWidth;
  let $flowId;
  let $panZoom;
  let $translateExtent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minimap", slots, []);
  let { position = "bottom-right" } = $$props;
  let { ariaLabel = "Mini map" } = $$props;
  let { nodeStrokeColor = "transparent" } = $$props;
  let { nodeColor = void 0 } = $$props;
  let { nodeClass = "" } = $$props;
  let { nodeBorderRadius = 5 } = $$props;
  let { nodeStrokeWidth = 2 } = $$props;
  let { bgColor = void 0 } = $$props;
  let { maskColor = void 0 } = $$props;
  let { maskStrokeColor = void 0 } = $$props;
  let { maskStrokeWidth = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { pannable = true } = $$props;
  let { zoomable = true } = $$props;
  let { inversePan = void 0 } = $$props;
  let { zoomStep = void 0 } = $$props;
  let { style = "" } = $$props;
  let { class: className = "" } = $$props;
  const { nodes, viewport, width: containerWidth, height: containerHeight, flowId, panZoom, translateExtent } = useStore();
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(18, $nodes = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(51, $viewport = value));
  validate_store(containerWidth, "containerWidth");
  component_subscribe($$self, containerWidth, (value) => $$invalidate(20, $containerWidth = value));
  validate_store(containerHeight, "containerHeight");
  component_subscribe($$self, containerHeight, (value) => $$invalidate(19, $containerHeight = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(52, $flowId = value));
  validate_store(panZoom, "panZoom");
  component_subscribe($$self, panZoom, (value) => $$invalidate(25, $panZoom = value));
  validate_store(translateExtent, "translateExtent");
  component_subscribe($$self, translateExtent, (value) => $$invalidate(26, $translateExtent = value));
  const nodeColorFunc = nodeColor === void 0 ? void 0 : getAttrFunction(nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
  const nodeClassFunc = getAttrFunction(nodeClass);
  const shapeRendering = typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision";
  const labelledBy = `svelte-flow__minimap-desc-${$flowId}`;
  const getViewScale = () => viewScale;
  const writable_props = [
    "position",
    "ariaLabel",
    "nodeStrokeColor",
    "nodeColor",
    "nodeClass",
    "nodeBorderRadius",
    "nodeStrokeWidth",
    "bgColor",
    "maskColor",
    "maskStrokeColor",
    "maskStrokeWidth",
    "width",
    "height",
    "pannable",
    "zoomable",
    "inversePan",
    "zoomStep",
    "style",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Minimap> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("ariaLabel" in $$props2)
      $$invalidate(1, ariaLabel = $$props2.ariaLabel);
    if ("nodeStrokeColor" in $$props2)
      $$invalidate(40, nodeStrokeColor = $$props2.nodeStrokeColor);
    if ("nodeColor" in $$props2)
      $$invalidate(41, nodeColor = $$props2.nodeColor);
    if ("nodeClass" in $$props2)
      $$invalidate(42, nodeClass = $$props2.nodeClass);
    if ("nodeBorderRadius" in $$props2)
      $$invalidate(2, nodeBorderRadius = $$props2.nodeBorderRadius);
    if ("nodeStrokeWidth" in $$props2)
      $$invalidate(3, nodeStrokeWidth = $$props2.nodeStrokeWidth);
    if ("bgColor" in $$props2)
      $$invalidate(4, bgColor = $$props2.bgColor);
    if ("maskColor" in $$props2)
      $$invalidate(5, maskColor = $$props2.maskColor);
    if ("maskStrokeColor" in $$props2)
      $$invalidate(6, maskStrokeColor = $$props2.maskStrokeColor);
    if ("maskStrokeWidth" in $$props2)
      $$invalidate(7, maskStrokeWidth = $$props2.maskStrokeWidth);
    if ("width" in $$props2)
      $$invalidate(43, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(44, height = $$props2.height);
    if ("pannable" in $$props2)
      $$invalidate(8, pannable = $$props2.pannable);
    if ("zoomable" in $$props2)
      $$invalidate(9, zoomable = $$props2.zoomable);
    if ("inversePan" in $$props2)
      $$invalidate(10, inversePan = $$props2.inversePan);
    if ("zoomStep" in $$props2)
      $$invalidate(11, zoomStep = $$props2.zoomStep);
    if ("style" in $$props2)
      $$invalidate(12, style = $$props2.style);
    if ("class" in $$props2)
      $$invalidate(13, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    getAttrFunction,
    cc,
    getBoundsOfRects,
    getNodePositionWithOrigin,
    getNodesBounds,
    useStore,
    Panel: Panel_default,
    MinimapNode: MinimapNode_default,
    interactive,
    position,
    ariaLabel,
    nodeStrokeColor,
    nodeColor,
    nodeClass,
    nodeBorderRadius,
    nodeStrokeWidth,
    bgColor,
    maskColor,
    maskStrokeColor,
    maskStrokeWidth,
    width,
    height,
    pannable,
    zoomable,
    inversePan,
    zoomStep,
    style,
    className,
    defaultWidth,
    defaultHeight,
    nodes,
    viewport,
    containerWidth,
    containerHeight,
    flowId,
    panZoom,
    translateExtent,
    nodeColorFunc,
    nodeStrokeColorFunc,
    nodeClassFunc,
    shapeRendering,
    labelledBy,
    getViewScale,
    viewScale,
    offset,
    viewHeight,
    viewboxHeight,
    viewWidth,
    viewboxWidth,
    boundingRect,
    y,
    x,
    elementHeight,
    elementWidth,
    scaledHeight,
    scaledWidth,
    viewBB,
    $nodes,
    $viewport,
    $containerHeight,
    $containerWidth,
    $flowId,
    $panZoom,
    $translateExtent
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("ariaLabel" in $$props2)
      $$invalidate(1, ariaLabel = $$props2.ariaLabel);
    if ("nodeStrokeColor" in $$props2)
      $$invalidate(40, nodeStrokeColor = $$props2.nodeStrokeColor);
    if ("nodeColor" in $$props2)
      $$invalidate(41, nodeColor = $$props2.nodeColor);
    if ("nodeClass" in $$props2)
      $$invalidate(42, nodeClass = $$props2.nodeClass);
    if ("nodeBorderRadius" in $$props2)
      $$invalidate(2, nodeBorderRadius = $$props2.nodeBorderRadius);
    if ("nodeStrokeWidth" in $$props2)
      $$invalidate(3, nodeStrokeWidth = $$props2.nodeStrokeWidth);
    if ("bgColor" in $$props2)
      $$invalidate(4, bgColor = $$props2.bgColor);
    if ("maskColor" in $$props2)
      $$invalidate(5, maskColor = $$props2.maskColor);
    if ("maskStrokeColor" in $$props2)
      $$invalidate(6, maskStrokeColor = $$props2.maskStrokeColor);
    if ("maskStrokeWidth" in $$props2)
      $$invalidate(7, maskStrokeWidth = $$props2.maskStrokeWidth);
    if ("width" in $$props2)
      $$invalidate(43, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(44, height = $$props2.height);
    if ("pannable" in $$props2)
      $$invalidate(8, pannable = $$props2.pannable);
    if ("zoomable" in $$props2)
      $$invalidate(9, zoomable = $$props2.zoomable);
    if ("inversePan" in $$props2)
      $$invalidate(10, inversePan = $$props2.inversePan);
    if ("zoomStep" in $$props2)
      $$invalidate(11, zoomStep = $$props2.zoomStep);
    if ("style" in $$props2)
      $$invalidate(12, style = $$props2.style);
    if ("className" in $$props2)
      $$invalidate(13, className = $$props2.className);
    if ("viewScale" in $$props2)
      $$invalidate(45, viewScale = $$props2.viewScale);
    if ("offset" in $$props2)
      $$invalidate(14, offset = $$props2.offset);
    if ("viewHeight" in $$props2)
      $$invalidate(46, viewHeight = $$props2.viewHeight);
    if ("viewboxHeight" in $$props2)
      $$invalidate(21, viewboxHeight = $$props2.viewboxHeight);
    if ("viewWidth" in $$props2)
      $$invalidate(47, viewWidth = $$props2.viewWidth);
    if ("viewboxWidth" in $$props2)
      $$invalidate(22, viewboxWidth = $$props2.viewboxWidth);
    if ("boundingRect" in $$props2)
      $$invalidate(48, boundingRect = $$props2.boundingRect);
    if ("y" in $$props2)
      $$invalidate(23, y = $$props2.y);
    if ("x" in $$props2)
      $$invalidate(24, x = $$props2.x);
    if ("elementHeight" in $$props2)
      $$invalidate(15, elementHeight = $$props2.elementHeight);
    if ("elementWidth" in $$props2)
      $$invalidate(16, elementWidth = $$props2.elementWidth);
    if ("scaledHeight" in $$props2)
      $$invalidate(49, scaledHeight = $$props2.scaledHeight);
    if ("scaledWidth" in $$props2)
      $$invalidate(50, scaledWidth = $$props2.scaledWidth);
    if ("viewBB" in $$props2)
      $$invalidate(17, viewBB = $$props2.viewBB);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$containerWidth, $containerHeight*/
    1572864 | $$self.$$.dirty[1] & /*$viewport*/
    1048576) {
      $:
        $$invalidate(17, viewBB = {
          x: -$viewport.x / $viewport.zoom,
          y: -$viewport.y / $viewport.zoom,
          width: $containerWidth / $viewport.zoom,
          height: $containerHeight / $viewport.zoom
        });
    }
    if ($$self.$$.dirty[0] & /*$nodes, viewBB*/
    393216) {
      $:
        $$invalidate(48, boundingRect = $nodes.length > 0 ? getBoundsOfRects(getNodesBounds($nodes), viewBB) : viewBB);
    }
    if ($$self.$$.dirty[1] & /*width*/
    4096) {
      $:
        $$invalidate(16, elementWidth = width ?? defaultWidth);
    }
    if ($$self.$$.dirty[1] & /*height*/
    8192) {
      $:
        $$invalidate(15, elementHeight = height ?? defaultHeight);
    }
    if ($$self.$$.dirty[0] & /*elementWidth*/
    65536 | $$self.$$.dirty[1] & /*boundingRect*/
    131072) {
      $:
        $$invalidate(50, scaledWidth = boundingRect.width / elementWidth);
    }
    if ($$self.$$.dirty[0] & /*elementHeight*/
    32768 | $$self.$$.dirty[1] & /*boundingRect*/
    131072) {
      $:
        $$invalidate(49, scaledHeight = boundingRect.height / elementHeight);
    }
    if ($$self.$$.dirty[1] & /*scaledWidth, scaledHeight*/
    786432) {
      $:
        $$invalidate(45, viewScale = Math.max(scaledWidth, scaledHeight));
    }
    if ($$self.$$.dirty[0] & /*elementWidth*/
    65536 | $$self.$$.dirty[1] & /*viewScale*/
    16384) {
      $:
        $$invalidate(47, viewWidth = viewScale * elementWidth);
    }
    if ($$self.$$.dirty[0] & /*elementHeight*/
    32768 | $$self.$$.dirty[1] & /*viewScale*/
    16384) {
      $:
        $$invalidate(46, viewHeight = viewScale * elementHeight);
    }
    if ($$self.$$.dirty[1] & /*viewScale*/
    16384) {
      $:
        $$invalidate(14, offset = 5 * viewScale);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    16384 | $$self.$$.dirty[1] & /*boundingRect, viewWidth*/
    196608) {
      $:
        $$invalidate(24, x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    16384 | $$self.$$.dirty[1] & /*boundingRect, viewHeight*/
    163840) {
      $:
        $$invalidate(23, y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    16384 | $$self.$$.dirty[1] & /*viewWidth*/
    65536) {
      $:
        $$invalidate(22, viewboxWidth = viewWidth + offset * 2);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    16384 | $$self.$$.dirty[1] & /*viewHeight*/
    32768) {
      $:
        $$invalidate(21, viewboxHeight = viewHeight + offset * 2);
    }
  };
  return [
    position,
    ariaLabel,
    nodeBorderRadius,
    nodeStrokeWidth,
    bgColor,
    maskColor,
    maskStrokeColor,
    maskStrokeWidth,
    pannable,
    zoomable,
    inversePan,
    zoomStep,
    style,
    className,
    offset,
    elementHeight,
    elementWidth,
    viewBB,
    $nodes,
    $containerHeight,
    $containerWidth,
    viewboxHeight,
    viewboxWidth,
    y,
    x,
    $panZoom,
    $translateExtent,
    nodes,
    viewport,
    containerWidth,
    containerHeight,
    flowId,
    panZoom,
    translateExtent,
    nodeColorFunc,
    nodeStrokeColorFunc,
    nodeClassFunc,
    shapeRendering,
    labelledBy,
    getViewScale,
    nodeStrokeColor,
    nodeColor,
    nodeClass,
    width,
    height,
    viewScale,
    viewHeight,
    viewWidth,
    boundingRect,
    scaledHeight,
    scaledWidth,
    $viewport
  ];
}
var Minimap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        position: 0,
        ariaLabel: 1,
        nodeStrokeColor: 40,
        nodeColor: 41,
        nodeClass: 42,
        nodeBorderRadius: 2,
        nodeStrokeWidth: 3,
        bgColor: 4,
        maskColor: 5,
        maskStrokeColor: 6,
        maskStrokeWidth: 7,
        width: 43,
        height: 44,
        pannable: 8,
        zoomable: 9,
        inversePan: 10,
        zoomStep: 11,
        style: 12,
        class: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minimap",
      options,
      id: create_fragment41.name
    });
  }
  get position() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeStrokeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeStrokeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClass() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClass(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeBorderRadius() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeBorderRadius(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeStrokeWidth() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeStrokeWidth(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskStrokeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskStrokeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskStrokeWidth() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskStrokeWidth(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pannable() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pannable(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomable() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomable(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inversePan() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inversePan(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomStep() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomStep(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Minimap_default = Minimap;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte
var file30 = "node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte";
function create_if_block13(ctx) {
  let div;
  let div_data_id_value;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "data-id", div_data_id_value = /*toolbarNodes*/
      ctx[0].reduce(func, "").trim());
      attr_dev(div, "class", "svelte-flow__node-toolbar");
      set_style(div, "position", `absolute`);
      set_style(
        div,
        "transform",
        /*transform*/
        ctx[1]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[3]
      );
      add_location(div, file30, 84, 2, 1917);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, { domNode: (
          /*$domNode*/
          ctx[4]
        ) }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*toolbarNodes*/
      1 && div_data_id_value !== (div_data_id_value = /*toolbarNodes*/
      ctx2[0].reduce(func, "").trim())) {
        attr_dev(div, "data-id", div_data_id_value);
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      16)
        portal_action.update.call(null, { domNode: (
          /*$domNode*/
          ctx2[4]
        ) });
      if (dirty & /*transform*/
      2) {
        set_style(
          div,
          "transform",
          /*transform*/
          ctx2[1]
        );
      }
      if (dirty & /*zIndex*/
      8) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[3]
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(58:0) {#if $domNode && isActive && toolbarNodes}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$domNode*/
    ctx[4] && /*isActive*/
    ctx[2] && /*toolbarNodes*/
    ctx[0] && create_if_block13(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$domNode*/
        ctx2[4] && /*isActive*/
        ctx2[2] && /*toolbarNodes*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$domNode, isActive, toolbarNodes*/
          21) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = (acc, node) => `${acc}${node.id} `;
function instance42($$self, $$props, $$invalidate) {
  let zIndex;
  let selectedNodesCount;
  let isActive;
  let $nodes;
  let $viewport;
  let $nodeOrigin;
  let $nodeLookup;
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeToolbar", slots, ["default"]);
  let { nodeId = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { align = void 0 } = $$props;
  let { offset = void 0 } = $$props;
  let { isVisible = void 0 } = $$props;
  const { domNode, viewport, nodeLookup, nodes, nodeOrigin } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(4, $domNode = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(17, $viewport = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(19, $nodeLookup = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(16, $nodes = value));
  validate_store(nodeOrigin, "nodeOrigin");
  component_subscribe($$self, nodeOrigin, (value) => $$invalidate(18, $nodeOrigin = value));
  const contextNodeId = getContext("svelteflow__node_id");
  let transform2;
  let toolbarNodes = [];
  let _offset = offset !== void 0 ? offset : 10;
  let _position = position !== void 0 ? position : Position.Top;
  let _align = align !== void 0 ? align : "center";
  const writable_props = ["nodeId", "position", "align", "offset", "isVisible"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<NodeToolbar> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2)
      $$invalidate(11, position = $$props2.position);
    if ("align" in $$props2)
      $$invalidate(12, align = $$props2.align);
    if ("offset" in $$props2)
      $$invalidate(13, offset = $$props2.offset);
    if ("isVisible" in $$props2)
      $$invalidate(14, isVisible = $$props2.isVisible);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    getNodesBounds,
    Position,
    internalsSymbol,
    getNodeToolbarTransform,
    portal: portal_default,
    useStore,
    nodeId,
    position,
    align,
    offset,
    isVisible,
    domNode,
    viewport,
    nodeLookup,
    nodes,
    nodeOrigin,
    contextNodeId,
    transform: transform2,
    toolbarNodes,
    _offset,
    _position,
    _align,
    selectedNodesCount,
    isActive,
    zIndex,
    $nodes,
    $viewport,
    $nodeOrigin,
    $nodeLookup,
    $domNode
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2)
      $$invalidate(11, position = $$props2.position);
    if ("align" in $$props2)
      $$invalidate(12, align = $$props2.align);
    if ("offset" in $$props2)
      $$invalidate(13, offset = $$props2.offset);
    if ("isVisible" in $$props2)
      $$invalidate(14, isVisible = $$props2.isVisible);
    if ("transform" in $$props2)
      $$invalidate(1, transform2 = $$props2.transform);
    if ("toolbarNodes" in $$props2)
      $$invalidate(0, toolbarNodes = $$props2.toolbarNodes);
    if ("_offset" in $$props2)
      $$invalidate(23, _offset = $$props2._offset);
    if ("_position" in $$props2)
      $$invalidate(24, _position = $$props2._position);
    if ("_align" in $$props2)
      $$invalidate(25, _align = $$props2._align);
    if ("selectedNodesCount" in $$props2)
      $$invalidate(15, selectedNodesCount = $$props2.selectedNodesCount);
    if ("isActive" in $$props2)
      $$invalidate(2, isActive = $$props2.isActive);
    if ("zIndex" in $$props2)
      $$invalidate(3, zIndex = $$props2.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty & /*$nodes, nodeId, $nodeLookup*/
    590848) {
      $: {
        if ($nodes) {
          const nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId];
          $$invalidate(0, toolbarNodes = nodeIds.reduce(
            (res, nodeId2) => {
              const node = $nodeLookup.get(nodeId2);
              if (node) {
                res.push(node);
              }
              return res;
            },
            []
          ));
        }
      }
    }
    if ($$self.$$.dirty & /*toolbarNodes, $nodeOrigin, $viewport*/
    393217) {
      $: {
        let nodeRect = void 0;
        if (toolbarNodes.length === 1) {
          const toolbarNode = toolbarNodes[0];
          nodeRect = {
            ...toolbarNode.position,
            width: ((_a = toolbarNode.computed) == null ? void 0 : _a.width) ?? toolbarNode.width ?? 0,
            height: ((_b = toolbarNode.computed) == null ? void 0 : _b.height) ?? toolbarNode.height ?? 0
          };
        } else if (toolbarNodes.length > 1) {
          nodeRect = getNodesBounds(toolbarNodes, $nodeOrigin);
        }
        if (nodeRect) {
          $$invalidate(1, transform2 = getNodeToolbarTransform(nodeRect, $viewport, _position, _offset, _align));
        }
      }
    }
    if ($$self.$$.dirty & /*toolbarNodes*/
    1) {
      $:
        $$invalidate(3, zIndex = toolbarNodes.length === 0 ? 1 : Math.max(...toolbarNodes.map((node) => {
          var _a2;
          return (((_a2 = node[internalsSymbol]) == null ? void 0 : _a2.z) || 5) + 1;
        })));
    }
    if ($$self.$$.dirty & /*$nodes*/
    65536) {
      $:
        $$invalidate(15, selectedNodesCount = $nodes.filter((node) => node.selected).length);
    }
    if ($$self.$$.dirty & /*isVisible, toolbarNodes, selectedNodesCount*/
    49153) {
      $:
        $$invalidate(2, isActive = typeof isVisible === "boolean" ? isVisible : toolbarNodes.length === 1 && toolbarNodes[0].selected && selectedNodesCount === 1);
    }
  };
  return [
    toolbarNodes,
    transform2,
    isActive,
    zIndex,
    $domNode,
    domNode,
    viewport,
    nodeLookup,
    nodes,
    nodeOrigin,
    nodeId,
    position,
    align,
    offset,
    isVisible,
    selectedNodesCount,
    $nodes,
    $viewport,
    $nodeOrigin,
    $nodeLookup,
    $$scope,
    slots
  ];
}
var NodeToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {
      nodeId: 10,
      position: 11,
      align: 12,
      offset: 13,
      isVisible: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeToolbar",
      options,
      id: create_fragment42.name
    });
  }
  get nodeId() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeToolbar_default = NodeToolbar;

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/hooks/useSvelteFlow.js
function useSvelteFlow() {
  const { zoomIn, zoomOut, fitView: fitView2, snapGrid, viewport, width, height, minZoom, maxZoom, panZoom, nodes, edges, domNode } = useStore();
  const getNodeRect = (nodeOrRect) => {
    const isRect = isRectObject(nodeOrRect);
    const node = isRect ? null : get_store_value(nodes).find((n) => n.id === nodeOrRect.id);
    if (!isRect && !node) {
      return [null, null, isRect];
    }
    const nodeRect = isRect ? nodeOrRect : nodeToRect(node);
    return [nodeRect, node, isRect];
  };
  return {
    zoomIn,
    zoomOut,
    setZoom: (zoomLevel, options) => {
      var _a;
      (_a = get_store_value(panZoom)) == null ? void 0 : _a.scaleTo(zoomLevel, { duration: options == null ? void 0 : options.duration });
    },
    getZoom: () => get_store_value(viewport).zoom,
    setViewport: (vieport, options) => {
      var _a;
      const currentViewport = get_store_value(viewport);
      (_a = get_store_value(panZoom)) == null ? void 0 : _a.setViewport({
        x: vieport.x ?? currentViewport.x,
        y: vieport.y ?? currentViewport.y,
        zoom: vieport.zoom ?? currentViewport.zoom
      }, { duration: options == null ? void 0 : options.duration });
    },
    getViewport: () => get_store_value(viewport),
    setCenter: (x, y, options) => {
      var _a;
      const nextZoom = typeof (options == null ? void 0 : options.zoom) !== "undefined" ? options.zoom : get_store_value(maxZoom);
      (_a = get_store_value(panZoom)) == null ? void 0 : _a.setViewport({
        x: get_store_value(width) / 2 - x * nextZoom,
        y: get_store_value(height) / 2 - y * nextZoom,
        zoom: nextZoom
      }, { duration: options == null ? void 0 : options.duration });
    },
    fitView: fitView2,
    fitBounds: (bounds, options) => {
      var _a;
      const viewport2 = getViewportForBounds(bounds, get_store_value(width), get_store_value(height), get_store_value(minZoom), get_store_value(maxZoom), (options == null ? void 0 : options.padding) ?? 0.1);
      (_a = get_store_value(panZoom)) == null ? void 0 : _a.setViewport(viewport2, { duration: options == null ? void 0 : options.duration });
    },
    getIntersectingNodes: (nodeOrRect, partially = true, nodesToIntersect) => {
      const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);
      if (!nodeRect || !node) {
        return [];
      }
      return (nodesToIntersect || get_store_value(nodes)).filter((n) => {
        var _a;
        if (!isRect && (n.id === node.id || !((_a = n.computed) == null ? void 0 : _a.positionAbsolute))) {
          return false;
        }
        const currNodeRect = nodeToRect(n);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    },
    isNodeIntersecting: (nodeOrRect, area, partially = true) => {
      const [nodeRect] = getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    },
    deleteElements: (nodesToRemove = [], edgesToRemove = []) => {
      const _nodes = get_store_value(nodes);
      const _edges = get_store_value(edges);
      const { matchingNodes, matchingEdges } = getElementsToRemove({
        nodesToRemove,
        edgesToRemove,
        nodes: _nodes,
        edges: _edges
      });
      if (matchingNodes) {
        nodes.set(_nodes.filter((node) => !matchingNodes.some(({ id: id2 }) => id2 === node.id)));
      }
      if (matchingEdges) {
        edges.set(_edges.filter((edge) => !matchingEdges.some(({ id: id2 }) => id2 === edge.id)));
      }
      return {
        deletedNodes: matchingNodes,
        deletedEdges: matchingEdges
      };
    },
    screenToFlowPosition: (position) => {
      const _domNode = get_store_value(domNode);
      if (!_domNode) {
        return position;
      }
      const _snapGrid = get_store_value(snapGrid);
      const { x, y, zoom: zoom2 } = get_store_value(viewport);
      const { x: domX, y: domY } = _domNode.getBoundingClientRect();
      const correctedPosition = {
        x: position.x - domX,
        y: position.y - domY
      };
      return pointToRendererPoint(correctedPosition, [x, y, zoom2], _snapGrid !== null, _snapGrid || [1, 1]);
    },
    flowToScreenPosition: (position) => {
      const _domNode = get_store_value(domNode);
      if (!_domNode) {
        return position;
      }
      const { x, y, zoom: zoom2 } = get_store_value(viewport);
      const { x: domX, y: domY } = _domNode.getBoundingClientRect();
      const rendererPosition = rendererPointToPoint(position, [x, y, zoom2]);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    },
    getConnectedEdges: (node) => {
      const nodeIds = /* @__PURE__ */ new Set();
      if (typeof node === "string") {
        nodeIds.add(node);
      } else if (node.length >= 1) {
        node.forEach((n) => {
          nodeIds.add(n.id);
        });
      }
      return get_store_value(edges).filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
    },
    getIncomers: (node) => {
      const _node = typeof node === "string" ? { id: node } : node;
      return getIncomersBase(_node, get_store_value(nodes), get_store_value(edges));
    },
    getOutgoers: (node) => {
      const _node = typeof node === "string" ? { id: node } : node;
      return getOutgoersBase(_node, get_store_value(nodes), get_store_value(edges));
    },
    toObject: () => {
      return {
        nodes: get_store_value(nodes).map((node) => ({
          ...node,
          // we want to make sure that changes to the nodes object that gets returned by toObject
          // do not affect the nodes object
          position: { ...node.position },
          data: { ...node.data }
        })),
        edges: get_store_value(edges).map((edge) => ({ ...edge })),
        viewport: { ...get_store_value(viewport) }
      };
    },
    viewport
  };
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/hooks/useUpdateNodeInternals.js
function useUpdateNodeInternals() {
  const { domNode, updateNodeDimensions: updateNodeDimensions2 } = useStore();
  const updateInternals = (id2) => {
    const updateIds = Array.isArray(id2) ? id2 : [id2];
    const updates = /* @__PURE__ */ new Map();
    updateIds.forEach((updateId) => {
      var _a;
      const nodeElement = (_a = get_store_value(domNode)) == null ? void 0 : _a.querySelector(`.svelte-flow__node[data-id="${updateId}"]`);
      if (nodeElement) {
        updates.set(updateId, { id: updateId, nodeElement, forceUpdate: true });
      }
    });
    requestAnimationFrame(() => updateNodeDimensions2(updates));
  };
  return updateInternals;
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/hooks/useConnection.js
function useConnection() {
  const { connection } = useStore();
  return connection;
}

// node_modules/.pnpm/@xyflow+svelte@0.0.28_svelte@4.2.17/node_modules/@xyflow/svelte/dist/lib/hooks/useNodesEdges.js
function useNodes() {
  const { nodes } = useStore();
  return nodes;
}
function useEdges() {
  const { edges } = useStore();
  return edges;
}
export {
  Background_default as Background,
  BackgroundVariant,
  BaseEdge_default as BaseEdge,
  BezierEdge_default as BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  ControlButton_default as ControlButton,
  Controls_default as Controls,
  EdgeLabelRenderer_default as EdgeLabelRenderer,
  Handle_default as Handle,
  MarkerType,
  Minimap_default as MiniMap,
  NodeToolbar_default as NodeToolbar,
  PanOnScrollMode,
  Panel_default as Panel,
  Position,
  SelectionMode,
  SmoothStepEdge_default as SmoothStepEdge,
  StepEdge_default as StepEdge,
  StraightEdge_default as StraightEdge,
  SvelteFlow_default as SvelteFlow,
  SvelteFlowProvider_default as SvelteFlowProvider,
  addEdge,
  getBezierEdgeCenter,
  getBezierPath,
  getConnectedEdges,
  getEdgeCenter,
  getIncomers,
  getNodesBounds,
  getOutgoers,
  getSmoothStepPath,
  getStraightPath,
  getViewportForBounds,
  isEdge,
  isNode,
  updateEdge,
  useConnection,
  useEdges,
  useNodes,
  useStore,
  useSvelteFlow,
  useUpdateNodeInternals
};
//# sourceMappingURL=@xyflow_svelte.js.map
